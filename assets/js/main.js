/*!For license information please see main.js.LICENSE.txt*/
(() => {
    var t = {
        884: (t, e, n) => {
            const i = n(440);
            t.exports = function (t, e, n, r, s = 60) {
                if (void 0 === r) return i(t, e, n);
                const o = r / (1 / s),
                    a = 1 - n;
                return i(t, e, 1 - Math.pow(a, o))
            }
        },
        52: function (t) {
            var e;
            e = () => (() => {
                "use strict";
                var t = [, (t, e, n) => {
                    n.r(e), n.d(e, {
                        default: () => s
                    });
                    var i, r = (i = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, function (t = {}) {
                        var e, n, r = t;

                        function s() {
                            function t(t) {
                                const s = i;
                                n = e = 0, i = new Map, s.forEach((e => {
                                    try {
                                        e(t)
                                    } catch (t) {
                                        console.error(t)
                                    }
                                })), this.pc(), r && r.Yc()
                            }
                            let e = 0,
                                n = 0,
                                i = new Map,
                                r = null,
                                s = null;
                            this.requestAnimationFrame = function (r) {
                                e || (e = requestAnimationFrame(t.bind(this)));
                                const s = ++n;
                                return i.set(s, r), s
                            }, this.cancelAnimationFrame = function (t) {
                                i.delete(t), e && 0 == i.size && (cancelAnimationFrame(e), e = 0)
                            }, this.Wc = function (t) {
                                s && (document.body.remove(s), s = null), t || (s = document.createElement("div"), s.style.backgroundColor = "black", s.style.position = "fixed", s.style.right = 0, s.style.top = 0, s.style.color = "white", s.style.padding = "4px", s.innerHTML = "RIVE FPS", t = function (t) {
                                    s.innerHTML = "RIVE FPS " + t.toFixed(1)
                                }, document.body.appendChild(s)), r = new function () {
                                    let e = 0,
                                        n = 0;
                                    this.Yc = function () {
                                        var i = performance.now();
                                        n ? (++e, 1e3 < (i -= n) && (t(1e3 * e / i), e = n = 0)) : (n = i, e = 0)
                                    }
                                }
                            }, this.Tc = function () {
                                s && (document.body.remove(s), s = null), r = null
                            }, this.pc = function () { }
                        }

                        function o(t) {
                            console.assert(!0);
                            const e = new Map;
                            let n = -1 / 0;
                            this.push = function (i) {
                                return i = i + ((1 << t) - 1) >> t, e.has(i) && clearTimeout(e.get(i)), e.set(i, setTimeout((function () {
                                    e.delete(i), 0 == e.length ? n = -1 / 0 : i == n && (n = Math.max(...e.keys()), console.assert(n < i))
                                }), 1e3)), n = Math.max(i, n), n << t
                            }
                        }
                        r.ready = new Promise(((t, i) => {
                            e = t, n = i
                        }));
                        const a = "createConicGradient createImageData createLinearGradient createPattern createRadialGradient getContextAttributes getImageData getLineDash getTransform isContextLost isPointInPath isPointInStroke measureText".split(" "),
                            l = new function () {
                                function t() {
                                    if (!e) {
                                        var t = document.createElement("canvas"),
                                            o = {
                                                alpha: 1,
                                                depth: 0,
                                                stencil: 0,
                                                antialias: 0,
                                                premultipliedAlpha: 1,
                                                preserveDrawingBuffer: 0,
                                                preferLowPowerToHighPerformance: 0,
                                                failIfMajorPerformanceCaveat: 0,
                                                enableExtensionsByDefault: 1,
                                                explicitSwapControl: 1,
                                                renderViaOffscreenBackBuffer: 1
                                            };
                                        let a;
                                        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                                            if (a = t.getContext("webgl", o), n = 1, !a) return console.log("No WebGL support. Image mesh will not be drawn."), !1
                                        } else if (a = t.getContext("webgl2", o)) n = 2;
                                        else {
                                            if (!(a = t.getContext("webgl", o))) return console.log("No WebGL support. Image mesh will not be drawn."), !1;
                                            n = 1
                                        }

                                        function l(t, e, n) {
                                            if (e = a.createShader(e), a.shaderSource(e, n), a.compileShader(e), 0 < ((n = a.getShaderInfoLog(e)) || "").length) throw n;
                                            a.attachShader(t, e)
                                        }
                                        if (a = new Proxy(a, {
                                            get: (t, e) => t.isContextLost() ? (u || (console.error("Cannot render the mesh because the GL Context was lost. Tried to invoke ", e), u = !0), "function" == typeof t[e] ? function () { } : void 0) : "function" == typeof t[e] ? function (...n) {
                                                return t[e].apply(t, n)
                                            } : t[e],
                                            set(t, e, n) {
                                                if (!t.isContextLost()) return t[e] = n, !0;
                                                u || (console.error("Cannot render the mesh because the GL Context was lost. Tried to set property " + e), u = !0)
                                            }
                                        }), i = Math.min(a.getParameter(a.MAX_RENDERBUFFER_SIZE), a.getParameter(a.MAX_TEXTURE_SIZE)), l(t = a.createProgram(), a.VERTEX_SHADER, "attribute vec2 vertex;\n                attribute vec2 uv;\n                uniform vec4 mat;\n                uniform vec2 translate;\n                varying vec2 st;\n                void main() {\n                    st = uv;\n                    gl_Position = vec4(mat2(mat) * vertex + translate, 0, 1);\n                }"), l(t, a.FRAGMENT_SHADER, "precision highp float;\n                uniform sampler2D image;\n                varying vec2 st;\n                void main() {\n                    gl_FragColor = texture2D(image, st);\n                }"), a.bindAttribLocation(t, 0, "vertex"), a.bindAttribLocation(t, 1, "uv"), a.linkProgram(t), 0 < ((o = a.getProgramInfoLog(t)) || "").trim().length) throw o;
                                        r = a.getUniformLocation(t, "mat"), s = a.getUniformLocation(t, "translate"), a.useProgram(t), a.bindBuffer(a.ARRAY_BUFFER, a.createBuffer()), a.enableVertexAttribArray(0), a.enableVertexAttribArray(1), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, a.createBuffer()), a.uniform1i(a.getUniformLocation(t, "image"), 0), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), e = a
                                    }
                                    return !0
                                }
                                let e = null,
                                    n = 0,
                                    i = 0,
                                    r = null,
                                    s = null,
                                    a = 0,
                                    l = 0,
                                    u = !1;
                                t(), this.md = function () {
                                    return t(), i
                                }, this.Qc = function (t) {
                                    e.deleteTexture && e.deleteTexture(t)
                                }, this.Oc = function (i) {
                                    if (!t()) return null;
                                    const r = e.createTexture();
                                    return r ? (e.bindTexture(e.TEXTURE_2D, r), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), 2 == n ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR_MIPMAP_LINEAR), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), r) : null
                                };
                                const c = new o(8),
                                    h = new o(8),
                                    d = new o(10),
                                    f = new o(10);
                                this.Vc = function (n, i, o, u, p) {
                                    if (t()) {
                                        var m = c.push(n),
                                            g = h.push(i);
                                        if (e.canvas) {
                                            for (var v of (e.canvas.width == m && e.canvas.height == g || (e.canvas.width = m, e.canvas.height = g), e.viewport(0, g - i, n, i), e.disable(e.SCISSOR_TEST), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), e.enable(e.SCISSOR_TEST), o.sort(((t, e) => e.xc - t.xc)), m = d.push(u), a != m && (e.bufferData(e.ARRAY_BUFFER, 8 * m, e.DYNAMIC_DRAW), a = m), m = 0, o)) e.bufferSubData(e.ARRAY_BUFFER, m, v.Ub), m += 4 * v.Ub.length;
                                            for (var y of (console.assert(m == 4 * u), o)) e.bufferSubData(e.ARRAY_BUFFER, m, y.Ec), m += 4 * y.Ec.length;
                                            for (var b of (console.assert(m == 8 * u), m = f.push(p), l != m && (e.bufferData(e.ELEMENT_ARRAY_BUFFER, 2 * m, e.DYNAMIC_DRAW), l = m), v = 0, o)) e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, v, b.indices), v += 2 * b.indices.length;
                                            console.assert(v == 2 * p), b = 0, y = !0, m = v = 0;
                                            for (const t of o) {
                                                t.image.Kb != b && (e.bindTexture(e.TEXTURE_2D, t.image.Jb || null), b = t.image.Kb), t.sd ? (e.scissor(t.Zb, g - t.$b - t.jc, t.Id, t.jc), y = !0) : y && (e.scissor(0, g - i, n, i), y = !1), o = 2 / n;
                                                const a = -2 / i;
                                                e.uniform4f(r, t.hb[0] * o * t.Bb, t.hb[1] * a * t.Cb, t.hb[2] * o * t.Bb, t.hb[3] * a * t.Cb), e.uniform2f(s, t.hb[4] * o * t.Bb + o * (t.Zb - t.nd * t.Bb) - 1, t.hb[5] * a * t.Cb + a * (t.$b - t.od * t.Cb) + 1), e.vertexAttribPointer(0, 2, e.FLOAT, !1, 0, m), e.vertexAttribPointer(1, 2, e.FLOAT, !1, 0, m + 4 * u), e.drawElements(e.TRIANGLES, t.indices.length, e.UNSIGNED_SHORT, v), m += 4 * t.Ub.length, v += 2 * t.indices.length
                                            }
                                            console.assert(m == 4 * u), console.assert(v == 2 * p)
                                        }
                                    }
                                }, this.canvas = function () {
                                    return t() && e.canvas
                                }
                            },
                            u = r.onRuntimeInitialized;
                        r.onRuntimeInitialized = function () {
                            function t(t) {
                                switch (t) {
                                    case p.srcOver:
                                        return "source-over";
                                    case p.screen:
                                        return "screen";
                                    case p.overlay:
                                        return "overlay";
                                    case p.darken:
                                        return "darken";
                                    case p.lighten:
                                        return "lighten";
                                    case p.colorDodge:
                                        return "color-dodge";
                                    case p.colorBurn:
                                        return "color-burn";
                                    case p.hardLight:
                                        return "hard-light";
                                    case p.softLight:
                                        return "soft-light";
                                    case p.difference:
                                        return "difference";
                                    case p.exclusion:
                                        return "exclusion";
                                    case p.multiply:
                                        return "multiply";
                                    case p.hue:
                                        return "hue";
                                    case p.saturation:
                                        return "saturation";
                                    case p.color:
                                        return "color";
                                    case p.luminosity:
                                        return "luminosity"
                                }
                            }

                            function e(t) {
                                return "rgba(" + ((16711680 & t) >>> 16) + "," + ((65280 & t) >>> 8) + "," + ((255 & t) >>> 0) + "," + ((4278190080 & t) >>> 24) / 255 + ")"
                            }

                            function n() {
                                0 < S.length && (l.Vc(M.drawWidth(), M.drawHeight(), S, T, E), S = [], E = T = 0, M.reset(512, 512));
                                for (const t of w) {
                                    for (const e of t.Ja) e();
                                    t.Ja = []
                                }
                                w.clear()
                            }
                            u && u();
                            var i = r.RenderPaintStyle;
                            const o = r.RenderPath,
                                c = r.RenderPaint,
                                h = r.Renderer,
                                d = r.StrokeCap,
                                f = r.StrokeJoin,
                                p = r.BlendMode,
                                m = i.fill,
                                g = i.stroke,
                                v = r.FillRule.evenOdd;
                            let y = 1;
                            var b = r.RenderImage.extend("CanvasRenderImage", {
                                __construct: function ({
                                    lb: t,
                                    yb: e
                                } = {}) {
                                    this.__parent.__construct.call(this), this.Kb = y, y = y + 1 & 2147483647 || 1, this.lb = t, this.yb = e
                                },
                                __destruct: function () {
                                    this.Jb && (l.Qc(this.Jb), URL.revokeObjectURL(this.Xb)), this.__parent.__destruct.call(this)
                                },
                                decode: function (t) {
                                    var e = this;
                                    e.yb && e.yb(e);
                                    var n = new Image;
                                    e.Xb = URL.createObjectURL(new Blob([t], {
                                        type: "image/png"
                                    })), n.src = e.Xb, n.onload = function () {
                                        e.Gc = n, e.Jb = l.Oc(n), e.size(n.width, n.height), e.lb && e.lb(e)
                                    }
                                }
                            }),
                                _ = o.extend("CanvasRenderPath", {
                                    __construct: function () {
                                        this.__parent.__construct.call(this), this.Ta = new Path2D
                                    },
                                    rewind: function () {
                                        this.Ta = new Path2D
                                    },
                                    addPath: function (t, e, n, i, r, s, o) {
                                        var a = this.Ta,
                                            l = a.addPath;
                                        t = t.Ta;
                                        const u = new DOMMatrix;
                                        u.a = e, u.b = n, u.c = i, u.d = r, u.e = s, u.f = o, l.call(a, t, u)
                                    },
                                    fillRule: function (t) {
                                        this.Wb = t
                                    },
                                    moveTo: function (t, e) {
                                        this.Ta.moveTo(t, e)
                                    },
                                    lineTo: function (t, e) {
                                        this.Ta.lineTo(t, e)
                                    },
                                    cubicTo: function (t, e, n, i, r, s) {
                                        this.Ta.bezierCurveTo(t, e, n, i, r, s)
                                    },
                                    close: function () {
                                        this.Ta.closePath()
                                    }
                                }),
                                x = c.extend("CanvasRenderPaint", {
                                    color: function (t) {
                                        this.Yb = e(t)
                                    },
                                    thickness: function (t) {
                                        this.Jc = t
                                    },
                                    join: function (t) {
                                        switch (t) {
                                            case f.miter:
                                                this.Ib = "miter";
                                                break;
                                            case f.round:
                                                this.Ib = "round";
                                                break;
                                            case f.bevel:
                                                this.Ib = "bevel"
                                        }
                                    },
                                    cap: function (t) {
                                        switch (t) {
                                            case d.butt:
                                                this.Hb = "butt";
                                                break;
                                            case d.round:
                                                this.Hb = "round";
                                                break;
                                            case d.square:
                                                this.Hb = "square"
                                        }
                                    },
                                    style: function (t) {
                                        this.Ic = t
                                    },
                                    blendMode: function (e) {
                                        this.Fc = t(e)
                                    },
                                    clearGradient: function () {
                                        this.jb = null
                                    },
                                    linearGradient: function (t, e, n, i) {
                                        this.jb = {
                                            zc: t,
                                            Ac: e,
                                            cc: n,
                                            dc: i,
                                            Sb: []
                                        }
                                    },
                                    radialGradient: function (t, e, n, i) {
                                        this.jb = {
                                            zc: t,
                                            Ac: e,
                                            cc: n,
                                            dc: i,
                                            Sb: [],
                                            kd: !0
                                        }
                                    },
                                    addStop: function (t, e) {
                                        this.jb.Sb.push({
                                            color: t,
                                            stop: e
                                        })
                                    },
                                    completeGradient: function () { },
                                    draw: function (t, n, i) {
                                        let r = this.Ic;
                                        var s = this.Yb,
                                            o = this.jb;
                                        if (t.globalCompositeOperation = this.Fc, null != o) {
                                            s = o.zc;
                                            var a = o.Ac;
                                            const n = o.cc;
                                            var l = o.dc;
                                            const i = o.Sb;
                                            o.kd ? (o = n - s, l -= a, s = t.createRadialGradient(s, a, 0, s, a, Math.sqrt(o * o + l * l))) : s = t.createLinearGradient(s, a, n, l);
                                            for (let t = 0, n = i.length; t < n; t++) a = i[t], s.addColorStop(a.stop, e(a.color));
                                            this.Yb = s, this.jb = null
                                        }
                                        switch (r) {
                                            case g:
                                                t.strokeStyle = s, t.lineWidth = this.Jc, t.lineCap = this.Hb, t.lineJoin = this.Ib, t.stroke(n);
                                                break;
                                            case m:
                                                t.fillStyle = s, t.fill(n, i)
                                        }
                                    }
                                });
                            const w = new Set;
                            let M = null,
                                S = [],
                                T = 0,
                                E = 0;
                            var D = r.CanvasRenderer = h.extend("Renderer", {
                                __construct: function (t) {
                                    this.__parent.__construct.call(this), this.Sa = [1, 0, 0, 1, 0, 0], this.Da = t.getContext("2d"), this.Vb = t, this.Ja = []
                                },
                                save: function () {
                                    this.Sa.push(...this.Sa.slice(this.Sa.length - 6)), this.Ja.push(this.Da.save.bind(this.Da))
                                },
                                restore: function () {
                                    const t = this.Sa.length - 6;
                                    if (6 > t) throw "restore() called without matching save().";
                                    this.Sa.splice(t), this.Ja.push(this.Da.restore.bind(this.Da))
                                },
                                transform: function (t, e, n, i, r, s) {
                                    const o = this.Sa,
                                        a = o.length - 6;
                                    o.splice(a, 6, o[a] * t + o[a + 2] * e, o[a + 1] * t + o[a + 3] * e, o[a] * n + o[a + 2] * i, o[a + 1] * n + o[a + 3] * i, o[a] * r + o[a + 2] * s + o[a + 4], o[a + 1] * r + o[a + 3] * s + o[a + 5]), this.Ja.push(this.Da.transform.bind(this.Da, t, e, n, i, r, s))
                                },
                                rotate: function (t) {
                                    const e = Math.sin(t);
                                    t = Math.cos(t), this.transform(t, e, -e, t, 0, 0)
                                },
                                _drawPath: function (t, e) {
                                    this.Ja.push(e.draw.bind(e, this.Da, t.Ta, t.Wb === v ? "evenodd" : "nonzero"))
                                },
                                _drawRiveImage: function (e, n, i) {
                                    var r = e.Gc;
                                    if (r) {
                                        var s = this.Da,
                                            o = t(n);
                                        this.Ja.push((function () {
                                            s.globalCompositeOperation = o, s.globalAlpha = i, s.drawImage(r, 0, 0), s.globalAlpha = 1
                                        }))
                                    }
                                },
                                _getMatrix: function (t) {
                                    const e = this.Sa,
                                        n = e.length - 6;
                                    for (let i = 0; 6 > i; ++i) t[i] = e[n + i]
                                },
                                _drawImageMesh: function (e, i, s, o, a, u, c, h, d, f) {
                                    var p = this.Da.canvas.width,
                                        m = this.Da.canvas.height;
                                    const g = d - c,
                                        v = f - h;
                                    c = Math.max(c, 0), h = Math.max(h, 0), d = Math.min(d, p), f = Math.min(f, m);
                                    const y = d - c,
                                        b = f - h;
                                    if (console.assert(y <= Math.min(g, p)), console.assert(b <= Math.min(v, m)), !(0 >= y || 0 >= b)) {
                                        d = y < g || b < v, p = f = 1;
                                        var _ = Math.ceil(y * f),
                                            x = Math.ceil(b * p);
                                        m = l.md(), _ > m && (f *= m / _, _ = m), x > m && (p *= m / x, x = m), M || (M = new r.DynamicRectanizer(m), M.reset(512, 512)), 0 > (m = M.addRect(_, x)) && (n(), w.add(this), m = M.addRect(_, x), console.assert(0 <= m));
                                        var D = 65535 & m,
                                            C = m >> 16;
                                        S.push({
                                            hb: this.Sa.slice(this.Sa.length - 6),
                                            image: e,
                                            Zb: D,
                                            $b: C,
                                            nd: c,
                                            od: h,
                                            Id: _,
                                            jc: x,
                                            Bb: f,
                                            Cb: p,
                                            Ub: new Float32Array(o),
                                            Ec: new Float32Array(a),
                                            indices: new Uint16Array(u),
                                            sd: d,
                                            xc: e.Kb << 1 | (d ? 1 : 0)
                                        }), T += o.length, E += u.length;
                                        var A = this.Da,
                                            P = t(i);
                                        this.Ja.push((function () {
                                            A.save(), A.resetTransform(), A.globalCompositeOperation = P, A.globalAlpha = s;
                                            const t = l.canvas();
                                            t && A.drawImage(t, D, C, _, x, c, h, y, b), A.restore()
                                        }))
                                    }
                                },
                                _clipPath: function (t) {
                                    this.Ja.push(this.Da.clip.bind(this.Da, t.Ta, t.Wb === v ? "evenodd" : "nonzero"))
                                },
                                clear: function () {
                                    w.add(this), this.Ja.push(this.Da.clearRect.bind(this.Da, 0, 0, this.Vb.width, this.Vb.height))
                                },
                                flush: function () { },
                                translate: function (t, e) {
                                    this.transform(1, 0, 0, 1, t, e)
                                }
                            });
                            r.makeRenderer = function (t) {
                                const e = new D(t),
                                    n = e.Da;
                                return new Proxy(e, {
                                    get(t, i) {
                                        if ("function" == typeof t[i]) return function (...e) {
                                            return t[i].apply(t, e)
                                        };
                                        if ("function" == typeof n[i]) {
                                            if (-1 < a.indexOf(i)) throw Error("RiveException: Method call to '" + i + "()' is not allowed, as the renderer cannot immediately pass through the return                 values of any canvas 2d context methods.");
                                            return function (...t) {
                                                e.Ja.push(n[i].bind(n, ...t))
                                            }
                                        }
                                        return t[i]
                                    },
                                    set(t, e, i) {
                                        if (e in n) return n[e] = i, !0
                                    }
                                })
                            }, r.decodeImage = function (t, e) {
                                new b({
                                    lb: e
                                }).decode(t)
                            }, r.renderFactory = {
                                makeRenderPaint: function () {
                                    return new x
                                },
                                makeRenderPath: function () {
                                    return new _
                                },
                                makeRenderImage: function () {
                                    let t = A;
                                    return new b({
                                        yb: () => {
                                            t.total++
                                        },
                                        lb: () => {
                                            if (t.loaded++, t.loaded === t.total) {
                                                const e = t.ready;
                                                e && (e(), t.ready = null)
                                            }
                                        }
                                    })
                                }
                            };
                            let C = r.load,
                                A = null;
                            r.load = function (t, e, n = !0) {
                                const i = new r.FallbackFileAssetLoader;
                                return void 0 !== e && i.addLoader(e), n && (e = new r.CDNFileAssetLoader, i.addLoader(e)), new Promise((function (e) {
                                    let n = null;
                                    A = {
                                        total: 0,
                                        loaded: 0,
                                        ready: function () {
                                            e(n)
                                        }
                                    }, n = C(t, i), 0 == A.total && e(n)
                                }))
                            }, i = new s, r.requestAnimationFrame = i.requestAnimationFrame.bind(i), r.cancelAnimationFrame = i.cancelAnimationFrame.bind(i), r.enableFPSCounter = i.Wc.bind(i), r.disableFPSCounter = i.Tc, i.pc = n, r.resolveAnimationFrame = n, r.cleanup = function () {
                                M && M.delete()
                            }
                        };
                        const c = r.onRuntimeInitialized;
                        r.onRuntimeInitialized = function () {
                            c && c();
                            let t = r.decodeFont;
                            r.decodeFont = function (e, n) {
                                n(e = t(e))
                            };
                            const e = r.FileAssetLoader;
                            r.ptrToAsset = t => {
                                let e = r.ptrToFileAsset(t);
                                return e.isImage ? r.ptrToImageAsset(t) : e.isFont ? r.ptrToFontAsset(t) : e
                            }, r.CustomFileAssetLoader = e.extend("CustomFileAssetLoader", {
                                __construct: function ({
                                    loadContents: t
                                }) {
                                    this.__parent.__construct.call(this), this.Hc = t
                                },
                                loadContents: function (t, e) {
                                    return t = r.ptrToAsset(t), this.Hc(t, e)
                                }
                            }), r.CDNFileAssetLoader = e.extend("CDNFileAssetLoader", {
                                __construct: function () {
                                    this.__parent.__construct.call(this)
                                },
                                loadContents: function (t) {
                                    let e = r.ptrToAsset(t);
                                    return "" !== (t = e.cdnUuid) && (n = e.cdnBaseUrl + "/" + t, (i = new XMLHttpRequest).responseType = "arraybuffer", i.onreadystatechange = function () {
                                        4 == i.readyState && 200 == i.status && (t => {
                                            e.decode(new Uint8Array(t.response))
                                        })(i)
                                    }, i.open("GET", n, !0), i.send(null), !0);
                                    var n, i
                                }
                            }), r.FallbackFileAssetLoader = e.extend("FallbackFileAssetLoader", {
                                __construct: function () {
                                    this.__parent.__construct.call(this), this.lc = []
                                },
                                addLoader: function (t) {
                                    this.lc.push(t)
                                },
                                loadContents: function (t, e) {
                                    for (let n of this.lc)
                                        if (n.loadContents(t, e)) return !0;
                                    return !1
                                }
                            })
                        };
                        var h, d, f = Object.assign({}, r),
                            p = "./this.program",
                            m = "object" == typeof window,
                            g = "function" == typeof importScripts,
                            v = "";
                        (m || g) && (g ? v = self.location.href : "undefined" != typeof document && document.currentScript && (v = document.currentScript.src), i && (v = i), v = 0 !== v.indexOf("blob:") ? v.substr(0, v.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", g && (d = t => {
                            var e = new XMLHttpRequest;
                            return e.open("GET", t, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response)
                        }), h = (t, e, n) => {
                            var i = new XMLHttpRequest;
                            i.open("GET", t, !0), i.responseType = "arraybuffer", i.onload = () => {
                                200 == i.status || 0 == i.status && i.response ? e(i.response) : n()
                            }, i.onerror = n, i.send(null)
                        });
                        var y, b = r.print || console.log.bind(console),
                            _ = r.printErr || console.error.bind(console);
                        Object.assign(r, f), f = null, r.thisProgram && (p = r.thisProgram), r.wasmBinary && (y = r.wasmBinary), r.noExitRuntime, "object" != typeof WebAssembly && H("no native wasm support detected");
                        var x, w, M, S, T, E, D, C, A, P, L = !1;

                        function R() {
                            var t = x.buffer;
                            r.HEAP8 = M = new Int8Array(t), r.HEAP16 = T = new Int16Array(t), r.HEAP32 = D = new Int32Array(t), r.HEAPU8 = S = new Uint8Array(t), r.HEAPU16 = E = new Uint16Array(t), r.HEAPU32 = C = new Uint32Array(t), r.HEAPF32 = A = new Float32Array(t), r.HEAPF64 = P = new Float64Array(t)
                        }
                        var k, O = [],
                            I = [],
                            F = [];

                        function N() {
                            var t = r.preRun.shift();
                            O.unshift(t)
                        }
                        var z, U = 0,
                            B = null,
                            j = null;

                        function H(t) {
                            throw r.onAbort && r.onAbort(t), _(t = "Aborted(" + t + ")"), L = !0, t = new WebAssembly.RuntimeError(t + ". Build with -sASSERTIONS for more info."), n(t), t
                        }

                        function V(t) {
                            return t.startsWith("data:application/octet-stream;base64,")
                        }
                        if (!V(z = "canvas_advanced.wasm")) {
                            var G = z;
                            z = r.locateFile ? r.locateFile(G, v) : v + G
                        }

                        function W(t) {
                            if (t == z && y) return new Uint8Array(y);
                            if (d) return d(t);
                            throw "both async and sync fetching of the wasm failed"
                        }

                        function $(t, e, n) {
                            return function (t) {
                                if (!y && (m || g)) {
                                    if ("function" == typeof fetch && !t.startsWith("file://")) return fetch(t, {
                                        credentials: "same-origin"
                                    }).then((e => {
                                        if (!e.ok) throw "failed to load wasm binary file at '" + t + "'";
                                        return e.arrayBuffer()
                                    })).catch((() => W(t)));
                                    if (h) return new Promise(((e, n) => {
                                        h(t, (t => e(new Uint8Array(t))), n)
                                    }))
                                }
                                return Promise.resolve().then((() => W(t)))
                            }(t).then((t => WebAssembly.instantiate(t, e))).then((t => t)).then(n, (t => {
                                _("failed to asynchronously prepare wasm: " + t), H(t)
                            }))
                        }
                        var X, q, Y = {
                            167540: (t, e, n, i, r) => {
                                if ("undefined" == typeof window || void 0 === (window.AudioContext || window.webkitAudioContext)) return 0;
                                if (void 0 === window.sa) {
                                    window.sa = {
                                        Ab: 0
                                    }, window.sa.Ha = {}, window.sa.Ha.zb = t, window.sa.Ha.capture = e, window.sa.Ha.Lb = n, window.sa.gb = {}, window.sa.gb.stopped = i, window.sa.gb.yc = r;
                                    let s = window.sa;
                                    s.Ea = [], s.Gd = function (t) {
                                        for (var e = 0; e < s.Ea.length; ++e)
                                            if (null == s.Ea[e]) return s.Ea[e] = t, e;
                                        return s.Ea.push(t), s.Ea.length - 1
                                    }, s.Dc = function (t) {
                                        for (s.Ea[t] = null; 0 < s.Ea.length && null == s.Ea[s.Ea.length - 1];) s.Ea.pop()
                                    }, s.Sd = function (t) {
                                        for (var e = 0; e < s.Ea.length; ++e)
                                            if (s.Ea[e] == t) return s.Dc(e)
                                    }, s.sb = function (t) {
                                        return s.Ea[t]
                                    }, s.Cc = ["touchend", "click"], s.unlock = function () {
                                        for (var t = 0; t < s.Ea.length; ++t) {
                                            var e = s.Ea[t];
                                            null != e && null != e.Ia && e.state === s.gb.yc && e.Ia.resume().then((() => {
                                                Cn(e.qc)
                                            }), (t => {
                                                console.error("Failed to resume audiocontext", t)
                                            }))
                                        }
                                        s.Cc.map((function (t) {
                                            document.removeEventListener(t, s.unlock, !0)
                                        }))
                                    }, s.Cc.map((function (t) {
                                        document.addEventListener(t, s.unlock, !0)
                                    }))
                                }
                                return window.sa.Ab += 1, 1
                            },
                            169718: () => {
                                void 0 !== window.sa && (--window.sa.Ab, 0 === window.sa.Ab && delete window.sa)
                            },
                            169882: () => void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getUserMedia,
                            169986: () => {
                                try {
                                    var t = new (window.AudioContext || window.webkitAudioContext),
                                        e = t.sampleRate;
                                    return t.close(), e
                                } catch (t) {
                                    return 0
                                }
                            },
                            170157: (t, e, n, i, r, s) => {
                                if (void 0 === window.sa) return -1;
                                var o = {},
                                    a = {};
                                return t == window.sa.Ha.zb && 0 != n && (a.sampleRate = n), o.Ia = new (window.AudioContext || window.webkitAudioContext)(a), o.Ia.suspend(), o.state = window.sa.gb.stopped, n = 0, t != window.sa.Ha.zb && (n = e), o.Za = o.Ia.createScriptProcessor(i, n, e), o.Za.onaudioprocess = function (n) {
                                    if (null != o.tb && 0 != o.tb.length || (o.tb = new Float32Array(A.buffer, r, i * e)), t == window.sa.Ha.capture || t == window.sa.Ha.Lb) {
                                        for (var a = 0; a < e; a += 1)
                                            for (var l = n.inputBuffer.getChannelData(a), u = o.tb, c = 0; c < i; c += 1) u[c * e + a] = l[c];
                                        Pn(s, i, r)
                                    }
                                    if (t == window.sa.Ha.zb || t == window.sa.Ha.Lb)
                                        for (Ln(s, i, r), a = 0; a < n.outputBuffer.numberOfChannels; ++a)
                                            for (l = n.outputBuffer.getChannelData(a), u = o.tb, c = 0; c < i; c += 1) l[c] = u[c * e + a];
                                    else
                                        for (a = 0; a < n.outputBuffer.numberOfChannels; ++a) n.outputBuffer.getChannelData(a).fill(0)
                                }, t != window.sa.Ha.capture && t != window.sa.Ha.Lb || navigator.mediaDevices.getUserMedia({
                                    audio: !0,
                                    video: !1
                                }).then((function (t) {
                                    o.Db = o.Ia.createMediaStreamSource(t), o.Db.connect(o.Za), o.Za.connect(o.Ia.destination)
                                })).catch((function (t) {
                                    console.log("Failed to get user media: " + t)
                                })), t == window.sa.Ha.zb && o.Za.connect(o.Ia.destination), o.qc = s, window.sa.Gd(o)
                            },
                            173034: t => window.sa.sb(t).Ia.sampleRate,
                            173107: t => {
                                void 0 !== (t = window.sa.sb(t)).Za && (t.Za.onaudioprocess = function () { }, t.Za.disconnect(), t.Za = void 0), void 0 !== t.Db && (t.Db.disconnect(), t.Db = void 0), t.Ia.close(), t.Ia = void 0, t.qc = void 0
                            },
                            173507: t => {
                                window.sa.Dc(t)
                            },
                            173557: t => {
                                (t = window.sa.sb(t)).Ia.resume(), t.state = window.sa.gb.yc
                            },
                            173696: t => {
                                (t = window.sa.sb(t)).Ia.suspend(), t.state = window.sa.gb.stopped
                            }
                        },
                            K = t => {
                                for (; 0 < t.length;) t.shift()(r)
                            },
                            J = (t, e) => {
                                for (var n = 0, i = t.length - 1; 0 <= i; i--) {
                                    var r = t[i];
                                    "." === r ? t.splice(i, 1) : ".." === r ? (t.splice(i, 1), n++) : n && (t.splice(i, 1), n--)
                                }
                                if (e)
                                    for (; n; n--) t.unshift("..");
                                return t
                            },
                            Z = t => {
                                var e = "/" === t.charAt(0),
                                    n = "/" === t.substr(-1);
                                return (t = J(t.split("/").filter((t => !!t)), !e).join("/")) || e || (t = "."), t && n && (t += "/"), (e ? "/" : "") + t
                            },
                            Q = t => {
                                var e = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(t).slice(1);
                                return t = e[0], e = e[1], t || e ? (e && (e = e.substr(0, e.length - 1)), t + e) : "."
                            },
                            tt = t => {
                                if ("/" === t) return "/";
                                var e = (t = (t = Z(t)).replace(/\/$/, "")).lastIndexOf("/");
                                return -1 === e ? t : t.substr(e + 1)
                            },
                            et = t => (et = (() => {
                                if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) return t => crypto.getRandomValues(t);
                                H("initRandomDevice")
                            })())(t);

                        function nt() {
                            for (var t = "", e = !1, n = arguments.length - 1; - 1 <= n && !e; n--) {
                                if ("string" != typeof (e = 0 <= n ? arguments[n] : "/")) throw new TypeError("Arguments to path.resolve must be strings");
                                if (!e) return "";
                                t = e + "/" + t, e = "/" === e.charAt(0)
                            }
                            return (e ? "/" : "") + (t = J(t.split("/").filter((t => !!t)), !e).join("/")) || "."
                        }
                        var it = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0,
                            rt = (t, e, n) => {
                                var i = e + n;
                                for (n = e; t[n] && !(n >= i);) ++n;
                                if (16 < n - e && t.buffer && it) return it.decode(t.subarray(e, n));
                                for (i = ""; e < n;) {
                                    var r = t[e++];
                                    if (128 & r) {
                                        var s = 63 & t[e++];
                                        if (192 == (224 & r)) i += String.fromCharCode((31 & r) << 6 | s);
                                        else {
                                            var o = 63 & t[e++];
                                            65536 > (r = 224 == (240 & r) ? (15 & r) << 12 | s << 6 | o : (7 & r) << 18 | s << 12 | o << 6 | 63 & t[e++]) ? i += String.fromCharCode(r) : (r -= 65536, i += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r))
                                        }
                                    } else i += String.fromCharCode(r)
                                }
                                return i
                            },
                            st = [],
                            ot = t => {
                                for (var e = 0, n = 0; n < t.length; ++n) {
                                    var i = t.charCodeAt(n);
                                    127 >= i ? e++ : 2047 >= i ? e += 2 : 55296 <= i && 57343 >= i ? (e += 4, ++n) : e += 3
                                }
                                return e
                            },
                            at = (t, e, n, i) => {
                                if (!(0 < i)) return 0;
                                var r = n;
                                i = n + i - 1;
                                for (var s = 0; s < t.length; ++s) {
                                    var o = t.charCodeAt(s);
                                    if (55296 <= o && 57343 >= o && (o = 65536 + ((1023 & o) << 10) | 1023 & t.charCodeAt(++s)), 127 >= o) {
                                        if (n >= i) break;
                                        e[n++] = o
                                    } else {
                                        if (2047 >= o) {
                                            if (n + 1 >= i) break;
                                            e[n++] = 192 | o >> 6
                                        } else {
                                            if (65535 >= o) {
                                                if (n + 2 >= i) break;
                                                e[n++] = 224 | o >> 12
                                            } else {
                                                if (n + 3 >= i) break;
                                                e[n++] = 240 | o >> 18, e[n++] = 128 | o >> 12 & 63
                                            }
                                            e[n++] = 128 | o >> 6 & 63
                                        }
                                        e[n++] = 128 | 63 & o
                                    }
                                }
                                return e[n] = 0, n - r
                            };

                        function lt(t, e) {
                            var n = Array(ot(t) + 1);
                            return t = at(t, n, 0, n.length), e && (n.length = t), n
                        }
                        var ut = [];

                        function ct(t, e) {
                            ut[t] = {
                                input: [],
                                Fa: [],
                                Va: e
                            }, Ut(t, ht)
                        }
                        var ht = {
                            open: function (t) {
                                var e = ut[t.node.mb];
                                if (!e) throw new Et(43);
                                t.ya = e, t.seekable = !1
                            },
                            close: function (t) {
                                t.ya.Va.rb(t.ya)
                            },
                            rb: function (t) {
                                t.ya.Va.rb(t.ya)
                            },
                            read: function (t, e, n, i) {
                                if (!t.ya || !t.ya.Va.ic) throw new Et(60);
                                for (var r = 0, s = 0; s < i; s++) {
                                    try {
                                        var o = t.ya.Va.ic(t.ya)
                                    } catch (t) {
                                        throw new Et(29)
                                    }
                                    if (void 0 === o && 0 === r) throw new Et(6);
                                    if (null == o) break;
                                    r++, e[n + s] = o
                                }
                                return r && (t.node.timestamp = Date.now()), r
                            },
                            write: function (t, e, n, i) {
                                if (!t.ya || !t.ya.Va.Pb) throw new Et(60);
                                try {
                                    for (var r = 0; r < i; r++) t.ya.Va.Pb(t.ya, e[n + r])
                                } catch (t) {
                                    throw new Et(29)
                                }
                                return i && (t.node.timestamp = Date.now()), r
                            }
                        },
                            dt = {
                                ic: function () {
                                    t: {
                                        if (!st.length) {
                                            var t = null;
                                            if ("undefined" != typeof window && "function" == typeof window.prompt ? null !== (t = window.prompt("Input: ")) && (t += "\n") : "function" == typeof readline && null !== (t = readline()) && (t += "\n"), !t) {
                                                t = null;
                                                break t
                                            }
                                            st = lt(t, !0)
                                        }
                                        t = st.shift()
                                    }
                                    return t
                                },
                                Pb: function (t, e) {
                                    null === e || 10 === e ? (b(rt(t.Fa, 0)), t.Fa = []) : 0 != e && t.Fa.push(e)
                                },
                                rb: function (t) {
                                    t.Fa && 0 < t.Fa.length && (b(rt(t.Fa, 0)), t.Fa = [])
                                },
                                gd: function () {
                                    return {
                                        Ld: 25856,
                                        Nd: 5,
                                        Kd: 191,
                                        Md: 35387,
                                        Jd: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                                    }
                                },
                                hd: function () {
                                    return 0
                                },
                                jd: function () {
                                    return [24, 80]
                                }
                            },
                            ft = {
                                Pb: function (t, e) {
                                    null === e || 10 === e ? (_(rt(t.Fa, 0)), t.Fa = []) : 0 != e && t.Fa.push(e)
                                },
                                rb: function (t) {
                                    t.Fa && 0 < t.Fa.length && (_(rt(t.Fa, 0)), t.Fa = [])
                                }
                            };

                        function pt(t, e) {
                            var n = t.va ? t.va.length : 0;
                            n >= e || (e = Math.max(e, n * (1048576 > n ? 2 : 1.125) >>> 0), 0 != n && (e = Math.max(e, 256)), n = t.va, t.va = new Uint8Array(e), 0 < t.Aa && t.va.set(n.subarray(0, t.Aa), 0))
                        }
                        var mt, gt, vt, yt, bt = {
                            Pa: null,
                            Ua: () => bt.createNode(null, "/", 16895, 0),
                            createNode(t, e, n, i) {
                                if (24576 == (61440 & n) || 4096 == (61440 & n)) throw new Et(63);
                                return bt.Pa || (bt.Pa = {
                                    dir: {
                                        node: {
                                            Na: bt.ua.Na,
                                            Qa: bt.ua.Qa,
                                            kb: bt.ua.kb,
                                            wb: bt.ua.wb,
                                            vc: bt.ua.vc,
                                            Bc: bt.ua.Bc,
                                            wc: bt.ua.wc,
                                            tc: bt.ua.tc,
                                            Eb: bt.ua.Eb
                                        },
                                        stream: {
                                            ab: bt.wa.ab
                                        }
                                    },
                                    file: {
                                        node: {
                                            Na: bt.ua.Na,
                                            Qa: bt.ua.Qa
                                        },
                                        stream: {
                                            ab: bt.wa.ab,
                                            read: bt.wa.read,
                                            write: bt.wa.write,
                                            qb: bt.wa.qb,
                                            mc: bt.wa.mc,
                                            oc: bt.wa.oc
                                        }
                                    },
                                    link: {
                                        node: {
                                            Na: bt.ua.Na,
                                            Qa: bt.ua.Qa,
                                            nb: bt.ua.nb
                                        },
                                        stream: {}
                                    },
                                    ac: {
                                        node: {
                                            Na: bt.ua.Na,
                                            Qa: bt.ua.Qa
                                        },
                                        stream: zt
                                    }
                                }), 16384 == (61440 & (n = Rt(t, e, n, i)).mode) ? (n.ua = bt.Pa.dir.node, n.wa = bt.Pa.dir.stream, n.va = {}) : 32768 == (61440 & n.mode) ? (n.ua = bt.Pa.file.node, n.wa = bt.Pa.file.stream, n.Aa = 0, n.va = null) : 40960 == (61440 & n.mode) ? (n.ua = bt.Pa.link.node, n.wa = bt.Pa.link.stream) : 8192 == (61440 & n.mode) && (n.ua = bt.Pa.ac.node, n.wa = bt.Pa.ac.stream), n.timestamp = Date.now(), t && (t.va[e] = n, t.timestamp = n.timestamp), n
                            },
                            Od: t => t.va ? t.va.subarray ? t.va.subarray(0, t.Aa) : new Uint8Array(t.va) : new Uint8Array(0),
                            ua: {
                                Na(t) {
                                    var e = {};
                                    return e.Sc = 8192 == (61440 & t.mode) ? t.id : 1, e.kc = t.id, e.mode = t.mode, e.td = 1, e.uid = 0, e.dd = 0, e.mb = t.mb, 16384 == (61440 & t.mode) ? e.size = 4096 : 32768 == (61440 & t.mode) ? e.size = t.Aa : 40960 == (61440 & t.mode) ? e.size = t.link.length : e.size = 0, e.Kc = new Date(t.timestamp), e.qd = new Date(t.timestamp), e.Pc = new Date(t.timestamp), e.Lc = 4096, e.Mc = Math.ceil(e.size / e.Lc), e
                                },
                                Qa(t, e) {
                                    if (void 0 !== e.mode && (t.mode = e.mode), void 0 !== e.timestamp && (t.timestamp = e.timestamp), void 0 !== e.size && (e = e.size, t.Aa != e))
                                        if (0 == e) t.va = null, t.Aa = 0;
                                        else {
                                            var n = t.va;
                                            t.va = new Uint8Array(e), n && t.va.set(n.subarray(0, Math.min(e, t.Aa))), t.Aa = e
                                        }
                                },
                                kb() {
                                    throw Dt[44]
                                },
                                wb: (t, e, n, i) => bt.createNode(t, e, n, i),
                                vc(t, e, n) {
                                    if (16384 == (61440 & t.mode)) {
                                        try {
                                            var i = Lt(e, n)
                                        } catch (t) { }
                                        if (i)
                                            for (var r in i.va) throw new Et(55)
                                    }
                                    delete t.parent.va[t.name], t.parent.timestamp = Date.now(), t.name = n, e.va[n] = t, e.timestamp = t.parent.timestamp, t.parent = e
                                },
                                Bc(t, e) {
                                    delete t.va[e], t.timestamp = Date.now()
                                },
                                wc(t, e) {
                                    var n, i = Lt(t, e);
                                    for (n in i.va) throw new Et(55);
                                    delete t.va[e], t.timestamp = Date.now()
                                },
                                tc(t) {
                                    var e, n = [".", ".."];
                                    for (e in t.va) t.va.hasOwnProperty(e) && n.push(e);
                                    return n
                                },
                                Eb: (t, e, n) => ((t = bt.createNode(t, e, 41471, 0)).link = n, t),
                                nb(t) {
                                    if (40960 != (61440 & t.mode)) throw new Et(28);
                                    return t.link
                                }
                            },
                            wa: {
                                read(t, e, n, i, r) {
                                    var s = t.node.va;
                                    if (r >= t.node.Aa) return 0;
                                    if (8 < (t = Math.min(t.node.Aa - r, i)) && s.subarray) e.set(s.subarray(r, r + t), n);
                                    else
                                        for (i = 0; i < t; i++) e[n + i] = s[r + i];
                                    return t
                                },
                                write(t, e, n, i, r, s) {
                                    if (e.buffer === M.buffer && (s = !1), !i) return 0;
                                    if ((t = t.node).timestamp = Date.now(), e.subarray && (!t.va || t.va.subarray)) {
                                        if (s) return t.va = e.subarray(n, n + i), t.Aa = i;
                                        if (0 === t.Aa && 0 === r) return t.va = e.slice(n, n + i), t.Aa = i;
                                        if (r + i <= t.Aa) return t.va.set(e.subarray(n, n + i), r), i
                                    }
                                    if (pt(t, r + i), t.va.subarray && e.subarray) t.va.set(e.subarray(n, n + i), r);
                                    else
                                        for (s = 0; s < i; s++) t.va[r + s] = e[n + s];
                                    return t.Aa = Math.max(t.Aa, r + i), i
                                },
                                ab(t, e, n) {
                                    if (1 === n ? e += t.position : 2 === n && 32768 == (61440 & t.node.mode) && (e += t.node.Aa), 0 > e) throw new Et(28);
                                    return e
                                },
                                qb(t, e, n) {
                                    pt(t.node, e + n), t.node.Aa = Math.max(t.node.Aa, e + n)
                                },
                                mc(t, e, n, i, r) {
                                    if (32768 != (61440 & t.node.mode)) throw new Et(43);
                                    if (t = t.node.va, 2 & r || t.buffer !== M.buffer) {
                                        if ((0 < n || n + e < t.length) && (t = t.subarray ? t.subarray(n, n + e) : Array.prototype.slice.call(t, n, n + e)), n = !0, H(), !(e = void 0)) throw new Et(48);
                                        M.set(t, e)
                                    } else n = !1, e = t.byteOffset;
                                    return {
                                        xa: e,
                                        Ma: n
                                    }
                                },
                                oc: (t, e, n, i) => (bt.wa.write(t, e, 0, i, n, !1), 0)
                            }
                        },
                            _t = null,
                            xt = {},
                            wt = [],
                            Mt = 1,
                            St = null,
                            Tt = !0,
                            Et = null,
                            Dt = {},
                            Ct = (t, e = {}) => {
                                if (!(t = nt(t))) return {
                                    path: "",
                                    node: null
                                };
                                if (8 < (e = Object.assign({
                                    fc: !0,
                                    Rb: 0
                                }, e)).Rb) throw new Et(32);
                                t = t.split("/").filter((t => !!t));
                                for (var n = _t, i = "/", r = 0; r < t.length; r++) {
                                    var s = r === t.length - 1;
                                    if (s && e.parent) break;
                                    if (n = Lt(n, t[r]), i = Z(i + "/" + t[r]), n.xb && (!s || s && e.fc) && (n = n.xb.root), !s || e.Mb)
                                        for (s = 0; 40960 == (61440 & n.mode);)
                                            if (n = Gt(i), i = nt(Q(i), n), n = Ct(i, {
                                                Rb: e.Rb + 1
                                            }).node, 40 < s++) throw new Et(32)
                                }
                                return {
                                    path: i,
                                    node: n
                                }
                            },
                            At = t => {
                                for (var e; ;) {
                                    if (t === t.parent) return t = t.Ua.nc, e ? "/" !== t[t.length - 1] ? `${t}/${e}` : t + e : t;
                                    e = e ? `${t.name}/${e}` : t.name, t = t.parent
                                }
                            },
                            Pt = (t, e) => {
                                for (var n = 0, i = 0; i < e.length; i++) n = (n << 5) - n + e.charCodeAt(i) | 0;
                                return (t + n >>> 0) % St.length
                            },
                            Lt = (t, e) => {
                                var n;
                                if (n = (n = Ot(t, "x")) ? n : t.ua.kb ? 0 : 2) throw new Et(n, t);
                                for (n = St[Pt(t.id, e)]; n; n = n.rd) {
                                    var i = n.name;
                                    if (n.parent.id === t.id && i === e) return n
                                }
                                return t.ua.kb(t, e)
                            },
                            Rt = (t, e, n, i) => (t = new wn(t, e, n, i), e = Pt(t.parent.id, t.name), t.rd = St[e], St[e] = t),
                            kt = t => {
                                var e = ["r", "w", "rw"][3 & t];
                                return 512 & t && (e += "w"), e
                            },
                            Ot = (t, e) => Tt ? 0 : !e.includes("r") || 292 & t.mode ? e.includes("w") && !(146 & t.mode) || e.includes("x") && !(73 & t.mode) ? 2 : 0 : 2,
                            It = (t, e) => {
                                try {
                                    return Lt(t, e), 20
                                } catch (t) { }
                                return Ot(t, "wx")
                            },
                            Ft = t => {
                                if (!(t = wt[t])) throw new Et(8);
                                return t
                            },
                            Nt = (t, e = -1) => (vt || ((vt = function () {
                                this.sa = {}
                            }).prototype = {}, Object.defineProperties(vt.prototype, {
                                object: {
                                    get() {
                                        return this.node
                                    },
                                    set(t) {
                                        this.node = t
                                    }
                                },
                                flags: {
                                    get() {
                                        return this.sa.flags
                                    },
                                    set(t) {
                                        this.sa.flags = t
                                    }
                                },
                                position: {
                                    get() {
                                        return this.sa.position
                                    },
                                    set(t) {
                                        this.sa.position = t
                                    }
                                }
                            })), t = Object.assign(new vt, t), -1 == e && (e = (() => {
                                for (var t = 0; 4096 >= t; t++)
                                    if (!wt[t]) return t;
                                throw new Et(33)
                            })()), t.Ya = e, wt[e] = t),
                            zt = {
                                open: t => {
                                    t.wa = xt[t.node.mb].wa, t.wa.open && t.wa.open(t)
                                },
                                ab: () => {
                                    throw new Et(70)
                                }
                            },
                            Ut = (t, e) => {
                                xt[t] = {
                                    wa: e
                                }
                            },
                            Bt = (t, e) => {
                                var n = "/" === e,
                                    i = !e;
                                if (n && _t) throw new Et(10);
                                if (!n && !i) {
                                    var r = Ct(e, {
                                        fc: !1
                                    });
                                    if (e = r.path, (r = r.node).xb) throw new Et(10);
                                    if (16384 != (61440 & r.mode)) throw new Et(54)
                                }
                                e = {
                                    type: t,
                                    Qd: {},
                                    nc: e,
                                    pd: []
                                }, (t = t.Ua(e)).Ua = e, e.root = t, n ? _t = t : r && (r.xb = e, r.Ua && r.Ua.pd.push(e))
                            },
                            jt = (t, e, n) => {
                                var i = Ct(t, {
                                    parent: !0
                                }).node;
                                if (!(t = tt(t)) || "." === t || ".." === t) throw new Et(28);
                                var r = It(i, t);
                                if (r) throw new Et(r);
                                if (!i.ua.wb) throw new Et(63);
                                return i.ua.wb(i, t, e, n)
                            },
                            Ht = (t, e, n) => {
                                void 0 === n && (n = e, e = 438), jt(t, 8192 | e, n)
                            },
                            Vt = (t, e) => {
                                if (!nt(t)) throw new Et(44);
                                var n = Ct(e, {
                                    parent: !0
                                }).node;
                                if (!n) throw new Et(44);
                                e = tt(e);
                                var i = It(n, e);
                                if (i) throw new Et(i);
                                if (!n.ua.Eb) throw new Et(63);
                                n.ua.Eb(n, e, t)
                            },
                            Gt = t => {
                                if (!(t = Ct(t).node)) throw new Et(44);
                                if (!t.ua.nb) throw new Et(28);
                                return nt(At(t.parent), t.ua.nb(t))
                            },
                            Wt = (t, e, n) => {
                                if ("" === t) throw new Et(44);
                                if ("string" == typeof e) {
                                    var i = {
                                        r: 0,
                                        "r+": 2,
                                        w: 577,
                                        "w+": 578,
                                        a: 1089,
                                        "a+": 1090
                                    }[e];
                                    if (void 0 === i) throw Error(`Unknown file open mode: ${e}`);
                                    e = i
                                }
                                if (n = 64 & e ? 4095 & (void 0 === n ? 438 : n) | 32768 : 0, "object" == typeof t) var s = t;
                                else {
                                    t = Z(t);
                                    try {
                                        s = Ct(t, {
                                            Mb: !(131072 & e)
                                        }).node
                                    } catch (t) { }
                                }
                                if (i = !1, 64 & e)
                                    if (s) {
                                        if (128 & e) throw new Et(20)
                                    } else s = jt(t, n, 0), i = !0;
                                if (!s) throw new Et(44);
                                if (8192 == (61440 & s.mode) && (e &= -513), 65536 & e && 16384 != (61440 & s.mode)) throw new Et(54);
                                if (!i && (n = s ? 40960 == (61440 & s.mode) ? 32 : 16384 == (61440 & s.mode) && ("r" !== kt(e) || 512 & e) ? 31 : Ot(s, kt(e)) : 44)) throw new Et(n);
                                if (512 & e && !i) {
                                    if (!(n = "string" == typeof (n = s) ? Ct(n, {
                                        Mb: !0
                                    }).node : n).ua.Qa) throw new Et(63);
                                    if (16384 == (61440 & n.mode)) throw new Et(31);
                                    if (32768 != (61440 & n.mode)) throw new Et(28);
                                    if (i = Ot(n, "w")) throw new Et(i);
                                    n.ua.Qa(n, {
                                        size: 0,
                                        timestamp: Date.now()
                                    })
                                }
                                return e &= -131713, (s = Nt({
                                    node: s,
                                    path: At(s),
                                    flags: e,
                                    seekable: !0,
                                    position: 0,
                                    wa: s.wa,
                                    Hd: [],
                                    error: !1
                                })).wa.open && s.wa.open(s), !r.logReadFiles || 1 & e || (yt || (yt = {}), t in yt || (yt[t] = 1)), s
                            },
                            $t = (t, e, n) => {
                                if (null === t.Ya) throw new Et(8);
                                if (!t.seekable || !t.wa.ab) throw new Et(70);
                                if (0 != n && 1 != n && 2 != n) throw new Et(28);
                                t.position = t.wa.ab(t, e, n), t.Hd = []
                            },
                            Xt = () => {
                                Et || ((Et = function (t, e) {
                                    this.name = "ErrnoError", this.node = e, this.xd = function (t) {
                                        this.Xa = t
                                    }, this.xd(t), this.message = "FS error"
                                }).prototype = Error(), Et.prototype.constructor = Et, [44].forEach((t => {
                                    Dt[t] = new Et(t), Dt[t].stack = "<generic error, no stack>"
                                })))
                            },
                            qt = (t, e, n) => {
                                t = Z("/dev/" + t);
                                var i = function (t, e) {
                                    var n = 0;
                                    return t && (n |= 365), e && (n |= 146), n
                                }(!!e, !!n);
                                gt || (gt = 64);
                                var r = gt++ << 8;
                                Ut(r, {
                                    open: t => {
                                        t.seekable = !1
                                    },
                                    close: () => {
                                        n && n.buffer && n.buffer.length && n(10)
                                    },
                                    read: (t, n, i, r) => {
                                        for (var s = 0, o = 0; o < r; o++) {
                                            try {
                                                var a = e()
                                            } catch (t) {
                                                throw new Et(29)
                                            }
                                            if (void 0 === a && 0 === s) throw new Et(6);
                                            if (null == a) break;
                                            s++, n[i + o] = a
                                        }
                                        return s && (t.node.timestamp = Date.now()), s
                                    },
                                    write: (t, e, i, r) => {
                                        for (var s = 0; s < r; s++) try {
                                            n(e[i + s])
                                        } catch (t) {
                                            throw new Et(29)
                                        }
                                        return r && (t.node.timestamp = Date.now()), s
                                    }
                                }), Ht(t, i, r)
                            },
                            Yt = {},
                            Kt = void 0;

                        function Jt() {
                            return D[(Kt += 4) - 4 >> 2]
                        }

                        function Zt(t) {
                            if (void 0 === t) return "_unknown";
                            var e = (t = t.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0);
                            return 48 <= e && 57 >= e ? `_${t}` : t
                        }

                        function Qt(t, e) {
                            return t = Zt(t), {
                                [t]: function () {
                                    return e.apply(this, arguments)
                                }
                            }[t]
                        }

                        function te() {
                            this.Ma = [void 0], this.hc = []
                        }
                        var ee = new te,
                            ne = void 0;

                        function ie(t) {
                            throw new ne(t)
                        }
                        var re = t => (t || ie("Cannot use deleted val. handle = " + t), ee.get(t).value),
                            se = t => {
                                switch (t) {
                                    case void 0:
                                        return 1;
                                    case null:
                                        return 2;
                                    case !0:
                                        return 3;
                                    case !1:
                                        return 4;
                                    default:
                                        return ee.qb({
                                            uc: 1,
                                            value: t
                                        })
                                }
                            };

                        function oe(t) {
                            var e = Error,
                                n = Qt(t, (function (e) {
                                    this.name = t, this.message = e, void 0 !== (e = Error(e).stack) && (this.stack = this.toString() + "\n" + e.replace(/^Error(:[^\n]*)?\n/, ""))
                                }));
                            return n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.prototype.toString = function () {
                                return void 0 === this.message ? this.name : `${this.name}: ${this.message}`
                            }, n
                        }
                        var ae = void 0,
                            le = void 0;

                        function ue(t) {
                            for (var e = ""; S[t];) e += le[S[t++]];
                            return e
                        }
                        var ce = [];

                        function he() {
                            for (; ce.length;) {
                                var t = ce.pop();
                                t.ra.fb = !1, t.delete()
                            }
                        }
                        var de = void 0,
                            fe = {};

                        function pe(t, e) {
                            for (void 0 === e && ie("ptr should not be undefined"); t.Ba;) e = t.ob(e), t = t.Ba;
                            return e
                        }
                        var me = {};

                        function ge(t) {
                            var e = ue(t = kn(t));
                            return En(t), e
                        }

                        function ve(t, e) {
                            var n = me[t];
                            return void 0 === n && ie(e + " has unknown type " + ge(t)), n
                        }

                        function ye() { }
                        var be = !1;

                        function _e(t) {
                            --t.count.value, 0 === t.count.value && (t.Ga ? t.La.Wa(t.Ga) : t.za.ta.Wa(t.xa))
                        }

                        function xe(t, e, n) {
                            return e === n ? t : void 0 === n.Ba || null === (t = xe(t, e, n.Ba)) ? null : n.Uc(t)
                        }
                        var we = {},
                            Me = void 0;

                        function Se(t) {
                            throw new Me(t)
                        }

                        function Te(t, e) {
                            return e.za && e.xa || Se("makeClassHandle requires ptr and ptrType"), !!e.La != !!e.Ga && Se("Both smartPtrType and smartPtr must be specified"), e.count = {
                                value: 1
                            }, Ee(Object.create(t, {
                                ra: {
                                    value: e
                                }
                            }))
                        }

                        function Ee(t) {
                            return "undefined" == typeof FinalizationRegistry ? (Ee = t => t, t) : (be = new FinalizationRegistry((t => {
                                _e(t.ra)
                            })), ye = t => {
                                be.unregister(t)
                            }, (Ee = t => {
                                var e = t.ra;
                                return e.Ga && be.register(t, {
                                    ra: e
                                }, t), t
                            })(t))
                        }
                        var De = {};

                        function Ce(t) {
                            for (; t.length;) {
                                var e = t.pop();
                                t.pop()(e)
                            }
                        }

                        function Ae(t) {
                            return this.fromWireType(D[t >> 2])
                        }
                        var Pe = {},
                            Le = {};

                        function Re(t, e, n) {
                            function i(e) {
                                (e = n(e)).length !== t.length && Se("Mismatched type converter count");
                                for (var i = 0; i < t.length; ++i) Oe(t[i], e[i])
                            }
                            t.forEach((function (t) {
                                Le[t] = e
                            }));
                            var r = Array(e.length),
                                s = [],
                                o = 0;
                            e.forEach(((t, e) => {
                                me.hasOwnProperty(t) ? r[e] = me[t] : (s.push(t), Pe.hasOwnProperty(t) || (Pe[t] = []), Pe[t].push((() => {
                                    r[e] = me[t], ++o === s.length && i(r)
                                })))
                            })), 0 === s.length && i(r)
                        }

                        function ke(t) {
                            switch (t) {
                                case 1:
                                    return 0;
                                case 2:
                                    return 1;
                                case 4:
                                    return 2;
                                case 8:
                                    return 3;
                                default:
                                    throw new TypeError(`Unknown type size: ${t}`)
                            }
                        }

                        function Oe(t, e, n = {}) {
                            if (!("argPackAdvance" in e)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
                            ! function (t, e, n = {}) {
                                var i = e.name;
                                if (t || ie(`type "${i}" must have a positive integer typeid pointer`), me.hasOwnProperty(t)) {
                                    if (n.ed) return;
                                    ie(`Cannot register type '${i}' twice`)
                                }
                                me[t] = e, delete Le[t], Pe.hasOwnProperty(t) && (e = Pe[t], delete Pe[t], e.forEach((t => t())))
                            }(t, e, n)
                        }

                        function Ie(t) {
                            ie(t.ra.za.ta.name + " instance already deleted")
                        }

                        function Fe() { }

                        function Ne(t, e, n) {
                            if (void 0 === t[e].Ca) {
                                var i = t[e];
                                t[e] = function () {
                                    return t[e].Ca.hasOwnProperty(arguments.length) || ie(`Function '${n}' called with an invalid number of arguments (${arguments.length}) - expects one of (${t[e].Ca})!`), t[e].Ca[arguments.length].apply(this, arguments)
                                }, t[e].Ca = [], t[e].Ca[i.eb] = i
                            }
                        }

                        function ze(t, e, n) {
                            r.hasOwnProperty(t) ? ((void 0 === n || void 0 !== r[t].Ca && void 0 !== r[t].Ca[n]) && ie(`Cannot register public name '${t}' twice`), Ne(r, t, t), r.hasOwnProperty(n) && ie(`Cannot register multiple overloads of a function with the same number of arguments (${n})!`), r[t].Ca[n] = e) : (r[t] = e, void 0 !== n && (r[t].Pd = n))
                        }

                        function Ue(t, e, n, i, r, s, o, a) {
                            this.name = t, this.constructor = e, this.Oa = n, this.Wa = i, this.Ba = r, this.Zc = s, this.ob = o, this.Uc = a, this.rc = []
                        }

                        function Be(t, e, n) {
                            for (; e !== n;) e.ob || ie(`Expected null or instance of ${n.name}, got an instance of ${e.name}`), t = e.ob(t), e = e.Ba;
                            return t
                        }

                        function je(t, e) {
                            return null === e ? (this.Ob && ie(`null is not a valid ${this.name}`), 0) : (e.ra || ie(`Cannot pass "${tn(e)}" as a ${this.name}`), e.ra.xa || ie(`Cannot pass deleted object as a pointer of type ${this.name}`), Be(e.ra.xa, e.ra.za.ta, this.ta))
                        }

                        function He(t, e) {
                            if (null === e) {
                                if (this.Ob && ie(`null is not a valid ${this.name}`), this.vb) {
                                    var n = this.Qb();
                                    return null !== t && t.push(this.Wa, n), n
                                }
                                return 0
                            }
                            if (e.ra || ie(`Cannot pass "${tn(e)}" as a ${this.name}`), e.ra.xa || ie(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.ub && e.ra.za.ub && ie(`Cannot convert argument of type ${e.ra.La ? e.ra.La.name : e.ra.za.name} to parameter type ${this.name}`), n = Be(e.ra.xa, e.ra.za.ta, this.ta), this.vb) switch (void 0 === e.ra.Ga && ie("Passing raw pointer to smart pointer is illegal"), this.Bd) {
                                case 0:
                                    e.ra.La === this ? n = e.ra.Ga : ie(`Cannot convert argument of type ${e.ra.La ? e.ra.La.name : e.ra.za.name} to parameter type ${this.name}`);
                                    break;
                                case 1:
                                    n = e.ra.Ga;
                                    break;
                                case 2:
                                    if (e.ra.La === this) n = e.ra.Ga;
                                    else {
                                        var i = e.clone();
                                        n = this.vd(n, se((function () {
                                            i.delete()
                                        }))), null !== t && t.push(this.Wa, n)
                                    }
                                    break;
                                default:
                                    ie("Unsupporting sharing policy")
                            }
                            return n
                        }

                        function Ve(t, e) {
                            return null === e ? (this.Ob && ie(`null is not a valid ${this.name}`), 0) : (e.ra || ie(`Cannot pass "${tn(e)}" as a ${this.name}`), e.ra.xa || ie(`Cannot pass deleted object as a pointer of type ${this.name}`), e.ra.za.ub && ie(`Cannot convert argument of type ${e.ra.za.name} to parameter type ${this.name}`), Be(e.ra.xa, e.ra.za.ta, this.ta))
                        }

                        function Ge(t, e, n, i) {
                            this.name = t, this.ta = e, this.Ob = n, this.ub = i, this.vb = !1, this.Wa = this.vd = this.Qb = this.sc = this.Bd = this.ud = void 0, void 0 !== e.Ba ? this.toWireType = He : (this.toWireType = i ? je : Ve, this.Ka = null)
                        }

                        function We(t, e, n) {
                            r.hasOwnProperty(t) || Se("Replacing nonexistant public symbol"), void 0 !== r[t].Ca && void 0 !== n ? r[t].Ca[n] = e : (r[t] = e, r[t].eb = n)
                        }

                        function $e(t, e) {
                            var n = (t = ue(t)).includes("j") ? ((t, e) => {
                                var n = [];
                                return function () {
                                    if (n.length = 0, Object.assign(n, arguments), t.includes("j")) {
                                        var i = r["dynCall_" + t];
                                        i = n && n.length ? i.apply(null, [e].concat(n)) : i.call(null, e)
                                    } else i = k.get(e).apply(null, n);
                                    return i
                                }
                            })(t, e) : k.get(e);
                            return "function" != typeof n && ie(`unknown function pointer with signature ${t}: ${e}`), n
                        }
                        var Xe = void 0;

                        function qe(t, e) {
                            var n = [],
                                i = {};
                            throw e.forEach((function t(e) {
                                i[e] || me[e] || (Le[e] ? Le[e].forEach(t) : (n.push(e), i[e] = !0))
                            })), new Xe(`${t}: ` + n.map(ge).join([", "]))
                        }

                        function Ye(t, e, n, i, r) {
                            var s = e.length;
                            2 > s && ie("argTypes array size mismatch! Must at least get return value and 'this' types!");
                            var o = null !== e[1] && null !== n,
                                a = !1;
                            for (n = 1; n < e.length; ++n)
                                if (null !== e[n] && void 0 === e[n].Ka) {
                                    a = !0;
                                    break
                                } var l = "void" !== e[0].name,
                                    u = s - 2,
                                    c = Array(u),
                                    h = [],
                                    d = [];
                            return function () {
                                if (arguments.length !== u && ie(`function ${t} called with ${arguments.length} arguments, expected ${u} args!`), d.length = 0, h.length = o ? 2 : 1, h[0] = r, o) {
                                    var n = e[1].toWireType(d, this);
                                    h[1] = n
                                }
                                for (var s = 0; s < u; ++s) c[s] = e[s + 2].toWireType(d, arguments[s]), h.push(c[s]);
                                if (s = i.apply(null, h), a) Ce(d);
                                else
                                    for (var f = o ? 1 : 2; f < e.length; f++) {
                                        var p = 1 === f ? n : c[f - 2];
                                        null !== e[f].Ka && e[f].Ka(p)
                                    }
                                return l ? e[0].fromWireType(s) : void 0
                            }
                        }

                        function Ke(t, e) {
                            for (var n = [], i = 0; i < t; i++) n.push(C[e + 4 * i >> 2]);
                            return n
                        }

                        function Je(t, e, n) {
                            return t instanceof Object || ie(`${n} with invalid "this": ${t}`), t instanceof e.ta.constructor || ie(`${n} incompatible with "this" of type ${t.constructor.name}`), t.ra.xa || ie(`cannot call emscripten binding method ${n} on deleted object`), Be(t.ra.xa, t.ra.za.ta, e.ta)
                        }

                        function Ze(t) {
                            t >= ee.sa && 0 == --ee.get(t).uc && ee.wd(t)
                        }

                        function Qe(t, e, n) {
                            switch (e) {
                                case 0:
                                    return function (t) {
                                        return this.fromWireType((n ? M : S)[t])
                                    };
                                case 1:
                                    return function (t) {
                                        return this.fromWireType((n ? T : E)[t >> 1])
                                    };
                                case 2:
                                    return function (t) {
                                        return this.fromWireType((n ? D : C)[t >> 2])
                                    };
                                default:
                                    throw new TypeError("Unknown integer type: " + t)
                            }
                        }

                        function tn(t) {
                            if (null === t) return "null";
                            var e = typeof t;
                            return "object" === e || "array" === e || "function" === e ? t.toString() : "" + t
                        }

                        function en(t, e) {
                            switch (e) {
                                case 2:
                                    return function (t) {
                                        return this.fromWireType(A[t >> 2])
                                    };
                                case 3:
                                    return function (t) {
                                        return this.fromWireType(P[t >> 3])
                                    };
                                default:
                                    throw new TypeError("Unknown float type: " + t)
                            }
                        }

                        function nn(t, e, n) {
                            switch (e) {
                                case 0:
                                    return n ? function (t) {
                                        return M[t]
                                    } : function (t) {
                                        return S[t]
                                    };
                                case 1:
                                    return n ? function (t) {
                                        return T[t >> 1]
                                    } : function (t) {
                                        return E[t >> 1]
                                    };
                                case 2:
                                    return n ? function (t) {
                                        return D[t >> 2]
                                    } : function (t) {
                                        return C[t >> 2]
                                    };
                                default:
                                    throw new TypeError("Unknown integer type: " + t)
                            }
                        }
                        var rn = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0,
                            sn = (t, e) => {
                                for (var n = t >> 1, i = n + e / 2; !(n >= i) && E[n];) ++n;
                                if (32 < (n <<= 1) - t && rn) return rn.decode(S.subarray(t, n));
                                for (n = "", i = 0; !(i >= e / 2); ++i) {
                                    var r = T[t + 2 * i >> 1];
                                    if (0 == r) break;
                                    n += String.fromCharCode(r)
                                }
                                return n
                            },
                            on = (t, e, n) => {
                                if (void 0 === n && (n = 2147483647), 2 > n) return 0;
                                var i = e;
                                n = (n -= 2) < 2 * t.length ? n / 2 : t.length;
                                for (var r = 0; r < n; ++r) T[e >> 1] = t.charCodeAt(r), e += 2;
                                return T[e >> 1] = 0, e - i
                            },
                            an = t => 2 * t.length,
                            ln = (t, e) => {
                                for (var n = 0, i = ""; !(n >= e / 4);) {
                                    var r = D[t + 4 * n >> 2];
                                    if (0 == r) break;
                                    ++n, 65536 <= r ? (r -= 65536, i += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : i += String.fromCharCode(r)
                                }
                                return i
                            },
                            un = (t, e, n) => {
                                if (void 0 === n && (n = 2147483647), 4 > n) return 0;
                                var i = e;
                                n = i + n - 4;
                                for (var r = 0; r < t.length; ++r) {
                                    var s = t.charCodeAt(r);
                                    if (55296 <= s && 57343 >= s && (s = 65536 + ((1023 & s) << 10) | 1023 & t.charCodeAt(++r)), D[e >> 2] = s, (e += 4) + 4 > n) break
                                }
                                return D[e >> 2] = 0, e - i
                            },
                            cn = t => {
                                for (var e = 0, n = 0; n < t.length; ++n) {
                                    var i = t.charCodeAt(n);
                                    55296 <= i && 57343 >= i && ++n, e += 4
                                }
                                return e
                            },
                            hn = {};

                        function dn(t) {
                            var e = hn[t];
                            return void 0 === e ? ue(t) : e
                        }
                        var fn, pn = [],
                            mn = [],
                            gn = [],
                            vn = {},
                            yn = () => {
                                if (!fn) {
                                    var t, e = {
                                        USER: "web_user",
                                        LOGNAME: "web_user",
                                        PATH: "/",
                                        PWD: "/",
                                        HOME: "/home/web_user",
                                        LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                                        _: p || "./this.program"
                                    };
                                    for (t in vn) void 0 === vn[t] ? delete e[t] : e[t] = vn[t];
                                    var n = [];
                                    for (t in e) n.push(`${t}=${e[t]}`);
                                    fn = n
                                }
                                return fn
                            },
                            bn = t => 0 == t % 4 && (0 != t % 100 || 0 == t % 400),
                            _n = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                            xn = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

                        function wn(t, e, n, i) {
                            t || (t = this), this.parent = t, this.Ua = t.Ua, this.xb = null, this.id = Mt++, this.name = e, this.mode = n, this.ua = {}, this.wa = {}, this.mb = i
                        }
                        Object.defineProperties(wn.prototype, {
                            read: {
                                get: function () {
                                    return !(365 & ~this.mode)
                                },
                                set: function (t) {
                                    t ? this.mode |= 365 : this.mode &= -366
                                }
                            },
                            write: {
                                get: function () {
                                    return !(146 & ~this.mode)
                                },
                                set: function (t) {
                                    t ? this.mode |= 146 : this.mode &= -147
                                }
                            }
                        }), Xt(), St = Array(4096), Bt(bt, "/"), jt("/tmp", 16895, 0), jt("/home", 16895, 0), jt("/home/web_user", 16895, 0), (() => {
                            jt("/dev", 16895, 0), Ut(259, {
                                read: () => 0,
                                write: (t, e, n, i) => i
                            }), Ht("/dev/null", 259), ct(1280, dt), ct(1536, ft), Ht("/dev/tty", 1280), Ht("/dev/tty1", 1536);
                            var t = new Uint8Array(1024),
                                e = 0,
                                n = () => (0 === e && (e = et(t).byteLength), t[--e]);
                            qt("random", n), qt("urandom", n), jt("/dev/shm", 16895, 0), jt("/dev/shm/tmp", 16895, 0)
                        })(), (() => {
                            jt("/proc", 16895, 0);
                            var t = jt("/proc/self", 16895, 0);
                            jt("/proc/self/fd", 16895, 0), Bt({
                                Ua: () => {
                                    var e = Rt(t, "fd", 16895, 73);
                                    return e.ua = {
                                        kb: (t, e) => {
                                            var n = Ft(+e);
                                            return (t = {
                                                parent: null,
                                                Ua: {
                                                    nc: "fake"
                                                },
                                                ua: {
                                                    nb: () => n.path
                                                }
                                            }).parent = t
                                        }
                                    }, e
                                }
                            }, "/proc/self/fd")
                        })(), Object.assign(te.prototype, {
                            get(t) {
                                return this.Ma[t]
                            },
                            has(t) {
                                return void 0 !== this.Ma[t]
                            },
                            qb(t) {
                                var e = this.hc.pop() || this.Ma.length;
                                return this.Ma[e] = t, e
                            },
                            wd(t) {
                                this.Ma[t] = void 0, this.hc.push(t)
                            }
                        }), ne = r.BindingError = class extends Error {
                            constructor(t) {
                                super(t), this.name = "BindingError"
                            }
                        }, ee.Ma.push({
                            value: void 0
                        }, {
                            value: null
                        }, {
                            value: !0
                        }, {
                            value: !1
                        }), ee.sa = ee.Ma.length, r.count_emval_handles = function () {
                            for (var t = 0, e = ee.sa; e < ee.Ma.length; ++e) void 0 !== ee.Ma[e] && ++t;
                            return t
                        }, ae = r.PureVirtualError = oe("PureVirtualError");
                        for (var Mn = Array(256), Sn = 0; 256 > Sn; ++Sn) Mn[Sn] = String.fromCharCode(Sn);
                        le = Mn, r.getInheritedInstanceCount = function () {
                            return Object.keys(fe).length
                        }, r.getLiveInheritedInstances = function () {
                            var t, e = [];
                            for (t in fe) fe.hasOwnProperty(t) && e.push(fe[t]);
                            return e
                        }, r.flushPendingDeletes = he, r.setDelayFunction = function (t) {
                            de = t, ce.length && de && de(he)
                        }, Me = r.InternalError = class extends Error {
                            constructor(t) {
                                super(t), this.name = "InternalError"
                            }
                        }, Fe.prototype.isAliasOf = function (t) {
                            if (!(this instanceof Fe && t instanceof Fe)) return !1;
                            var e = this.ra.za.ta,
                                n = this.ra.xa,
                                i = t.ra.za.ta;
                            for (t = t.ra.xa; e.Ba;) n = e.ob(n), e = e.Ba;
                            for (; i.Ba;) t = i.ob(t), i = i.Ba;
                            return e === i && n === t
                        }, Fe.prototype.clone = function () {
                            if (this.ra.xa || Ie(this), this.ra.ib) return this.ra.count.value += 1, this;
                            var t = Ee,
                                e = Object,
                                n = e.create,
                                i = Object.getPrototypeOf(this),
                                r = this.ra;
                            return (t = t(n.call(e, i, {
                                ra: {
                                    value: {
                                        count: r.count,
                                        fb: r.fb,
                                        ib: r.ib,
                                        xa: r.xa,
                                        za: r.za,
                                        Ga: r.Ga,
                                        La: r.La
                                    }
                                }
                            }))).ra.count.value += 1, t.ra.fb = !1, t
                        }, Fe.prototype.delete = function () {
                            this.ra.xa || Ie(this), this.ra.fb && !this.ra.ib && ie("Object already scheduled for deletion"), ye(this), _e(this.ra), this.ra.ib || (this.ra.Ga = void 0, this.ra.xa = void 0)
                        }, Fe.prototype.isDeleted = function () {
                            return !this.ra.xa
                        }, Fe.prototype.deleteLater = function () {
                            return this.ra.xa || Ie(this), this.ra.fb && !this.ra.ib && ie("Object already scheduled for deletion"), ce.push(this), 1 === ce.length && de && de(he), this.ra.fb = !0, this
                        }, Ge.prototype.$c = function (t) {
                            return this.sc && (t = this.sc(t)), t
                        }, Ge.prototype.bc = function (t) {
                            this.Wa && this.Wa(t)
                        }, Ge.prototype.argPackAdvance = 8, Ge.prototype.readValueFromPointer = Ae, Ge.prototype.deleteObject = function (t) {
                            null !== t && t.delete()
                        }, Ge.prototype.fromWireType = function (t) {
                            function e() {
                                return this.vb ? Te(this.ta.Oa, {
                                    za: this.ud,
                                    xa: n,
                                    La: this,
                                    Ga: t
                                }) : Te(this.ta.Oa, {
                                    za: this,
                                    xa: t
                                })
                            }
                            var n = this.$c(t);
                            if (!n) return this.bc(t), null;
                            var i = function (t, e) {
                                return e = pe(t, e), fe[e]
                            }(this.ta, n);
                            if (void 0 !== i) return 0 === i.ra.count.value ? (i.ra.xa = n, i.ra.Ga = t, i.clone()) : (i = i.clone(), this.bc(t), i);
                            if (i = this.ta.Zc(n), !(i = we[i])) return e.call(this);
                            i = this.ub ? i.Nc : i.pointerType;
                            var r = xe(n, this.ta, i.ta);
                            return null === r ? e.call(this) : this.vb ? Te(i.ta.Oa, {
                                za: i,
                                xa: r,
                                La: this,
                                Ga: t
                            }) : Te(i.ta.Oa, {
                                za: i,
                                xa: r
                            })
                        }, Xe = r.UnboundTypeError = oe("UnboundTypeError");
                        var Tn = {
                            A: function (t, e, n) {
                                Kt = n;
                                try {
                                    var i = Ft(t);
                                    switch (e) {
                                        case 0:
                                            var r = Jt();
                                            return 0 > r ? -28 : Nt(i, r).Ya;
                                        case 1:
                                        case 2:
                                        case 6:
                                        case 7:
                                            return 0;
                                        case 3:
                                            return i.flags;
                                        case 4:
                                            return r = Jt(), i.flags |= r, 0;
                                        case 5:
                                            return r = Jt(), T[r + 0 >> 1] = 2, 0;
                                        case 16:
                                        case 8:
                                        default:
                                            return -28;
                                        case 9:
                                            return D[Rn() >> 2] = 28, -1
                                    }
                                } catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return -t.Xa
                                }
                            },
                            K: function (t, e) {
                                try {
                                    t: {
                                        var n = Ft(t).path;
                                        try {
                                            var i = Ct(n, {
                                                Mb: !0
                                            }).node;
                                            if (!i) throw new Et(44);
                                            if (!i.ua.Na) throw new Et(63);
                                            var r = i.ua.Na(i)
                                        } catch (t) {
                                            if (t && t.node && Z(n) !== Z(At(t.node))) {
                                                var s = -54;
                                                break t
                                            }
                                            throw t
                                        }
                                        D[e >> 2] = r.Sc,
                                            D[e + 4 >> 2] = r.mode,
                                            C[e + 8 >> 2] = r.td,
                                            D[e + 12 >> 2] = r.uid,
                                            D[e + 16 >> 2] = r.dd,
                                            D[e + 20 >> 2] = r.mb,
                                            q = [r.size >>> 0, (X = r.size, 1 <= +Math.abs(X) ? 0 < X ? +Math.floor(X / 4294967296) >>> 0 : ~~+Math.ceil((X - +(~~X >>> 0)) / 4294967296) >>> 0 : 0)],
                                            D[e + 24 >> 2] = q[0],
                                            D[e + 28 >> 2] = q[1],
                                            D[e + 32 >> 2] = 4096,
                                            D[e + 36 >> 2] = r.Mc;
                                        var o = r.Kc.getTime(),
                                            a = r.qd.getTime(),
                                            l = r.Pc.getTime(); q = [Math.floor(o / 1e3) >>> 0, (X = Math.floor(o / 1e3), 1 <= +Math.abs(X) ? 0 < X ? +Math.floor(X / 4294967296) >>> 0 : ~~+Math.ceil((X - +(~~X >>> 0)) / 4294967296) >>> 0 : 0)],
                                                D[e + 40 >> 2] = q[0],
                                                D[e + 44 >> 2] = q[1],
                                                C[e + 48 >> 2] = o % 1e3 * 1e3,
                                                q = [Math.floor(a / 1e3) >>> 0, (X = Math.floor(a / 1e3), 1 <= +Math.abs(X) ? 0 < X ? +Math.floor(X / 4294967296) >>> 0 : ~~+Math.ceil((X - +(~~X >>> 0)) / 4294967296) >>> 0 : 0)],
                                                D[e + 56 >> 2] = q[0],
                                                D[e + 60 >> 2] = q[1],
                                                C[e + 64 >> 2] = a % 1e3 * 1e3,
                                                q = [Math.floor(l / 1e3) >>> 0, (X = Math.floor(l / 1e3), 1 <= +Math.abs(X) ? 0 < X ? +Math.floor(X / 4294967296) >>> 0 : ~~+Math.ceil((X - +(~~X >>> 0)) / 4294967296) >>> 0 : 0)],
                                                D[e + 72 >> 2] = q[0],
                                                D[e + 76 >> 2] = q[1],
                                                C[e + 80 >> 2] = l % 1e3 * 1e3,
                                                q = [r.kc >>> 0, (X = r.kc, 1 <= +Math.abs(X) ? 0 < X ? +Math.floor(X / 4294967296) >>> 0 : ~~+Math.ceil((X - +(~~X >>> 0)) / 4294967296) >>> 0 : 0)],
                                                D[e + 88 >> 2] = q[0],
                                                D[e + 92 >> 2] = q[1],
                                                s = 0
                                    }
                                    return s
                                }
                                catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return -t.Xa
                                }
                            },
                            N: function (t, e, n) {
                                Kt = n;
                                try {
                                    var i = Ft(t);
                                    switch (e) {
                                        case 21509:
                                        case 21510:
                                        case 21511:
                                        case 21512:
                                        case 21524:
                                        case 21515:
                                            return i.ya ? 0 : -59;
                                        case 21505:
                                            if (!i.ya) return -59;
                                            if (i.ya.Va.gd) {
                                                e = [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                                                var r = Jt();
                                                D[r >> 2] = 25856, D[r + 4 >> 2] = 5, D[r + 8 >> 2] = 191, D[r + 12 >> 2] = 35387;
                                                for (var s = 0; 32 > s; s++) M[r + s + 17 | 0] = e[s] || 0
                                            }
                                            return 0;
                                        case 21506:
                                        case 21507:
                                        case 21508:
                                            if (!i.ya) return -59;
                                            if (i.ya.Va.hd)
                                                for (r = Jt(), e = [], s = 0; 32 > s; s++) e.push(M[r + s + 17 | 0]);
                                            return 0;
                                        case 21519:
                                            return i.ya ? (r = Jt(), D[r >> 2] = 0) : -59;
                                        case 21520:
                                            return i.ya ? -28 : -59;
                                        case 21531:
                                            if (r = Jt(), !i.wa.fd) throw new Et(59);
                                            return i.wa.fd(i, e, r);
                                        case 21523:
                                            return i.ya ? (i.ya.Va.jd && (s = [24, 80], r = Jt(), T[r >> 1] = s[0], T[r + 2 >> 1] = s[1]), 0) : -59;
                                        default:
                                            return -28
                                    }
                                } catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return -t.Xa
                                }
                            },
                            O: function (t, e, n, i) {
                                Kt = i;
                                try {
                                    var r = e = e ? rt(S, e) : "";
                                    if ("/" === r.charAt(0)) e = r;
                                    else {
                                        var s = -100 === t ? "/" : Ft(t).path;
                                        if (0 == r.length) throw new Et(44);
                                        e = Z(s + "/" + r)
                                    }
                                    var o = i ? Jt() : 0;
                                    return Wt(e, n, o).Ya
                                } catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return -t.Xa
                                }
                            },
                            T: function (t, e, n) {
                                t = ue(t), e = ve(e, "wrapper"), n = re(n);
                                var i = [].slice,
                                    r = e.ta,
                                    s = r.Oa,
                                    o = r.Ba.Oa,
                                    a = r.Ba.constructor;
                                for (var l in t = Qt(t, (function () {
                                    r.Ba.rc.forEach(function (t) {
                                        if (this[t] === o[t]) throw new ae(`Pure virtual function ${t} must be implemented in JavaScript`)
                                    }.bind(this)), Object.defineProperty(this, "__parent", {
                                        value: s
                                    }), this.__construct.apply(this, i.call(arguments))
                                })), s.__construct = function () {
                                    this === s && ie("Pass correct 'this' to __construct");
                                    var t = a.implement.apply(void 0, [this].concat(i.call(arguments)));
                                    ye(t);
                                    var e = t.ra;
                                    t.notifyOnDestruction(), e.ib = !0, Object.defineProperties(this, {
                                        ra: {
                                            value: e
                                        }
                                    }), Ee(this), t = e.xa, t = pe(r, t), fe.hasOwnProperty(t) ? ie(`Tried to register registered instance: ${t}`) : fe[t] = this
                                }, s.__destruct = function () {
                                    this === s && ie("Pass correct 'this' to __destruct"), ye(this);
                                    var t = this.ra.xa;
                                    t = pe(r, t), fe.hasOwnProperty(t) ? delete fe[t] : ie(`Tried to unregister unregistered instance: ${t}`)
                                }, t.prototype = Object.create(s), n) t.prototype[l] = n[l];
                                return se(t)
                            },
                            U: function (t) {
                                var e = De[t];
                                delete De[t];
                                var n = e.Qb,
                                    i = e.Wa,
                                    r = e.ec;
                                Re([t], r.map((t => t.cd)).concat(r.map((t => t.zd))), (t => {
                                    var s = {};
                                    return r.forEach(((e, n) => {
                                        var i = t[n],
                                            o = e.ad,
                                            a = e.bd,
                                            l = t[n + r.length],
                                            u = e.yd,
                                            c = e.Ad;
                                        s[e.Xc] = {
                                            read: t => i.fromWireType(o(a, t)),
                                            write: (t, e) => {
                                                var n = [];
                                                u(c, t, l.toWireType(n, e)), Ce(n)
                                            }
                                        }
                                    })), [{
                                        name: e.name,
                                        fromWireType: function (t) {
                                            var e, n = {};
                                            for (e in s) n[e] = s[e].read(t);
                                            return i(t), n
                                        },
                                        toWireType: function (t, e) {
                                            for (var r in s)
                                                if (!(r in e)) throw new TypeError(`Missing field: "${r}"`);
                                            var o = n();
                                            for (r in s) s[r].write(o, e[r]);
                                            return null !== t && t.push(i, o), o
                                        },
                                        argPackAdvance: 8,
                                        readValueFromPointer: Ae,
                                        Ka: i
                                    }]
                                }))
                            },
                            F: function () { },
                            Q: function (t, e, n, i, r) {
                                var s = ke(n);
                                Oe(t, {
                                    name: e = ue(e),
                                    fromWireType: function (t) {
                                        return !!t
                                    },
                                    toWireType: function (t, e) {
                                        return e ? i : r
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: function (t) {
                                        if (1 === n) var i = M;
                                        else if (2 === n) i = T;
                                        else {
                                            if (4 !== n) throw new TypeError("Unknown boolean type size: " + e);
                                            i = D
                                        }
                                        return this.fromWireType(i[t >> s])
                                    },
                                    Ka: null
                                })
                            },
                            f: function (t, e, n, i, r, s, o, a, l, u, c, h, d) {
                                c = ue(c), s = $e(r, s), a && (a = $e(o, a)), u && (u = $e(l, u)), d = $e(h, d);
                                var f = Zt(c);
                                ze(f, (function () {
                                    qe(`Cannot construct ${c} due to unbound types`, [i])
                                })), Re([t, e, n], i ? [i] : [], (function (e) {
                                    if (e = e[0], i) var n = e.ta,
                                        r = n.Oa;
                                    else r = Fe.prototype;
                                    e = Qt(f, (function () {
                                        if (Object.getPrototypeOf(this) !== o) throw new ne("Use 'new' to construct " + c);
                                        if (void 0 === l.$a) throw new ne(c + " has no accessible constructor");
                                        var t = l.$a[arguments.length];
                                        if (void 0 === t) throw new ne(`Tried to invoke ctor of ${c} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(l.$a).toString()}) parameters instead!`);
                                        return t.apply(this, arguments)
                                    }));
                                    var o = Object.create(r, {
                                        constructor: {
                                            value: e
                                        }
                                    });
                                    e.prototype = o;
                                    var l = new Ue(c, e, o, d, n, s, a, u);
                                    l.Ba && (void 0 === l.Ba.pb && (l.Ba.pb = []), l.Ba.pb.push(l)), n = new Ge(c, l, !0, !1), r = new Ge(c + "*", l, !1, !1);
                                    var h = new Ge(c + " const*", l, !1, !0);
                                    return we[t] = {
                                        pointerType: r,
                                        Nc: h
                                    }, We(f, e), [n, r, h]
                                }))
                            },
                            k: function (t, e, n, i, r, s, o) {
                                var a = Ke(n, i);
                                e = ue(e), s = $e(r, s), Re([], [t], (function (t) {
                                    function i() {
                                        qe(`Cannot call ${r} due to unbound types`, a)
                                    }
                                    var r = `${(t = t[0]).name}.${e}`;
                                    e.startsWith("@@") && (e = Symbol[e.substring(2)]);
                                    var l = t.ta.constructor;
                                    return void 0 === l[e] ? (i.eb = n - 1, l[e] = i) : (Ne(l, e, r), l[e].Ca[n - 1] = i), Re([], a, (function (i) {
                                        if (i = Ye(r, [i[0], null].concat(i.slice(1)), null, s, o), void 0 === l[e].Ca ? (i.eb = n - 1, l[e] = i) : l[e].Ca[n - 1] = i, t.ta.pb)
                                            for (const n of t.ta.pb) n.constructor.hasOwnProperty(e) || (n.constructor[e] = i);
                                        return []
                                    })), []
                                }))
                            },
                            y: function (t, e, n, i, r, s, o, a) {
                                e = ue(e), s = $e(r, s), Re([], [t], (function (t) {
                                    var r = `${(t = t[0]).name}.${e}`,
                                        l = {
                                            get() {
                                                qe(`Cannot access ${r} due to unbound types`, [n])
                                            },
                                            enumerable: !0,
                                            configurable: !0
                                        };
                                    return l.set = a ? () => {
                                        qe(`Cannot access ${r} due to unbound types`, [n])
                                    } : () => {
                                        ie(`${r} is a read-only property`)
                                    }, Object.defineProperty(t.ta.constructor, e, l), Re([], [n], (function (n) {
                                        n = n[0];
                                        var r = {
                                            get: () => n.fromWireType(s(i)),
                                            enumerable: !0
                                        };
                                        return a && (a = $e(o, a), r.set = t => {
                                            var e = [];
                                            a(i, n.toWireType(e, t)), Ce(e)
                                        }), Object.defineProperty(t.ta.constructor, e, r), []
                                    })), []
                                }))
                            },
                            t: function (t, e, n, i, r, s) {
                                var o = Ke(e, n);
                                r = $e(i, r), Re([], [t], (function (t) {
                                    var n = `constructor ${(t = t[0]).name}`;
                                    if (void 0 === t.ta.$a && (t.ta.$a = []), void 0 !== t.ta.$a[e - 1]) throw new ne(`Cannot register multiple constructors with identical number of parameters (${e - 1}) for class '${t.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
                                    return t.ta.$a[e - 1] = () => {
                                        qe(`Cannot construct ${t.name} due to unbound types`, o)
                                    }, Re([], o, (function (i) {
                                        return i.splice(1, 0, null), t.ta.$a[e - 1] = Ye(n, i, null, r, s), []
                                    })), []
                                }))
                            },
                            a: function (t, e, n, i, r, s, o, a) {
                                var l = Ke(n, i);
                                e = ue(e), s = $e(r, s), Re([], [t], (function (t) {
                                    function i() {
                                        qe(`Cannot call ${r} due to unbound types`, l)
                                    }
                                    var r = `${(t = t[0]).name}.${e}`;
                                    e.startsWith("@@") && (e = Symbol[e.substring(2)]), a && t.ta.rc.push(e);
                                    var u = t.ta.Oa,
                                        c = u[e];
                                    return void 0 === c || void 0 === c.Ca && c.className !== t.name && c.eb === n - 2 ? (i.eb = n - 2, i.className = t.name, u[e] = i) : (Ne(u, e, r), u[e].Ca[n - 2] = i), Re([], l, (function (i) {
                                        return i = Ye(r, i, t, s, o), void 0 === u[e].Ca ? (i.eb = n - 2, u[e] = i) : u[e].Ca[n - 2] = i, []
                                    })), []
                                }))
                            },
                            e: function (t, e, n, i, r, s, o, a, l, u) {
                                e = ue(e), r = $e(i, r), Re([], [t], (function (t) {
                                    var i = `${(t = t[0]).name}.${e}`,
                                        c = {
                                            get() {
                                                qe(`Cannot access ${i} due to unbound types`, [n, o])
                                            },
                                            enumerable: !0,
                                            configurable: !0
                                        };
                                    return c.set = l ? () => {
                                        qe(`Cannot access ${i} due to unbound types`, [n, o])
                                    } : () => {
                                        ie(i + " is a read-only property")
                                    }, Object.defineProperty(t.ta.Oa, e, c), Re([], l ? [n, o] : [n], (function (n) {
                                        var o = n[0],
                                            c = {
                                                get() {
                                                    var e = Je(this, t, i + " getter");
                                                    return o.fromWireType(r(s, e))
                                                },
                                                enumerable: !0
                                            };
                                        if (l) {
                                            l = $e(a, l);
                                            var h = n[1];
                                            c.set = function (e) {
                                                var n = Je(this, t, i + " setter"),
                                                    r = [];
                                                l(u, n, h.toWireType(r, e)), Ce(r)
                                            }
                                        }
                                        return Object.defineProperty(t.ta.Oa, e, c), []
                                    })), []
                                }))
                            },
                            P: function (t, e) {
                                Oe(t, {
                                    name: e = ue(e),
                                    fromWireType: function (t) {
                                        var e = re(t);
                                        return Ze(t), e
                                    },
                                    toWireType: function (t, e) {
                                        return se(e)
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: Ae,
                                    Ka: null
                                })
                            },
                            q: function (t, e, n, i) {
                                function r() { }
                                n = ke(n), e = ue(e), r.values = {}, Oe(t, {
                                    name: e,
                                    constructor: r,
                                    fromWireType: function (t) {
                                        return this.constructor.values[t]
                                    },
                                    toWireType: function (t, e) {
                                        return e.value
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: Qe(e, n, i),
                                    Ka: null
                                }), ze(e, r)
                            },
                            d: function (t, e, n) {
                                var i = ve(t, "enum");
                                e = ue(e), t = i.constructor, i = Object.create(i.constructor.prototype, {
                                    value: {
                                        value: n
                                    },
                                    constructor: {
                                        value: Qt(`${i.name}_${e}`, (function () { }))
                                    }
                                }), t.values[n] = i, t[e] = i
                            },
                            B: function (t, e, n) {
                                n = ke(n), Oe(t, {
                                    name: e = ue(e),
                                    fromWireType: function (t) {
                                        return t
                                    },
                                    toWireType: function (t, e) {
                                        return e
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: en(e, n),
                                    Ka: null
                                })
                            },
                            n: function (t, e, n, i, r, s) {
                                var o = Ke(e, n);
                                t = ue(t), r = $e(i, r), ze(t, (function () {
                                    qe(`Cannot call ${t} due to unbound types`, o)
                                }), e - 1), Re([], o, (function (n) {
                                    return We(t, Ye(t, [n[0], null].concat(n.slice(1)), null, r, s), e - 1), []
                                }))
                            },
                            m: function (t, e, n, i, r) {
                                e = ue(e), -1 === r && (r = 4294967295), r = ke(n);
                                var s = t => t;
                                if (0 === i) {
                                    var o = 32 - 8 * n;
                                    s = t => t << o >>> o
                                }
                                n = e.includes("unsigned") ? function (t, e) {
                                    return e >>> 0
                                } : function (t, e) {
                                    return e
                                }, Oe(t, {
                                    name: e,
                                    fromWireType: s,
                                    toWireType: n,
                                    argPackAdvance: 8,
                                    readValueFromPointer: nn(e, r, 0 !== i),
                                    Ka: null
                                })
                            },
                            g: function (t, e, n) {
                                function i(t) {
                                    t >>= 2;
                                    var e = C;
                                    return new r(e.buffer, e[t + 1], e[t])
                                }
                                var r = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][e];
                                Oe(t, {
                                    name: n = ue(n),
                                    fromWireType: i,
                                    argPackAdvance: 8,
                                    readValueFromPointer: i
                                }, {
                                    ed: !0
                                })
                            },
                            C: function (t, e) {
                                var n = "std::string" === (e = ue(e));
                                Oe(t, {
                                    name: e,
                                    fromWireType: function (t) {
                                        var e = C[t >> 2],
                                            i = t + 4;
                                        if (n)
                                            for (var r = i, s = 0; s <= e; ++s) {
                                                var o = i + s;
                                                if (s == e || 0 == S[o]) {
                                                    if (r = r ? rt(S, r, o - r) : "", void 0 === a) var a = r;
                                                    else a += String.fromCharCode(0), a += r;
                                                    r = o + 1
                                                }
                                            } else {
                                            for (a = Array(e), s = 0; s < e; ++s) a[s] = String.fromCharCode(S[i + s]);
                                            a = a.join("")
                                        }
                                        return En(t), a
                                    },
                                    toWireType: function (t, e) {
                                        e instanceof ArrayBuffer && (e = new Uint8Array(e));
                                        var i = "string" == typeof e;
                                        i || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || ie("Cannot pass non-string to std::string");
                                        var r = n && i ? ot(e) : e.length,
                                            s = Dn(4 + r + 1),
                                            o = s + 4;
                                        if (C[s >> 2] = r, n && i) at(e, S, o, r + 1);
                                        else if (i)
                                            for (i = 0; i < r; ++i) {
                                                var a = e.charCodeAt(i);
                                                255 < a && (En(o), ie("String has UTF-16 code units that do not fit in 8 bits")), S[o + i] = a
                                            } else
                                            for (i = 0; i < r; ++i) S[o + i] = e[i];
                                        return null !== t && t.push(En, s), s
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: Ae,
                                    Ka: function (t) {
                                        En(t)
                                    }
                                })
                            },
                            v: function (t, e, n) {
                                if (n = ue(n), 2 === e) var i = sn,
                                    r = on,
                                    s = an,
                                    o = () => E,
                                    a = 1;
                                else 4 === e && (i = ln, r = un, s = cn, o = () => C, a = 2);
                                Oe(t, {
                                    name: n,
                                    fromWireType: function (t) {
                                        for (var n, r = C[t >> 2], s = o(), l = t + 4, u = 0; u <= r; ++u) {
                                            var c = t + 4 + u * e;
                                            u != r && 0 != s[c >> a] || (l = i(l, c - l), void 0 === n ? n = l : (n += String.fromCharCode(0), n += l), l = c + e)
                                        }
                                        return En(t), n
                                    },
                                    toWireType: function (t, i) {
                                        "string" != typeof i && ie(`Cannot pass non-string to C++ string type ${n}`);
                                        var o = s(i),
                                            l = Dn(4 + o + e);
                                        return C[l >> 2] = o >> a, r(i, l + 4, o + e), null !== t && t.push(En, l), l
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: Ae,
                                    Ka: function (t) {
                                        En(t)
                                    }
                                })
                            },
                            W: function (t, e, n, i, r, s) {
                                De[t] = {
                                    name: ue(e),
                                    Qb: $e(n, i),
                                    Wa: $e(r, s),
                                    ec: []
                                }
                            },
                            V: function (t, e, n, i, r, s, o, a, l, u) {
                                De[t].ec.push({
                                    Xc: ue(e),
                                    cd: n,
                                    ad: $e(i, r),
                                    bd: s,
                                    zd: o,
                                    yd: $e(a, l),
                                    Ad: u
                                })
                            },
                            R: function (t, e) {
                                Oe(t, {
                                    ld: !0,
                                    name: e = ue(e),
                                    argPackAdvance: 0,
                                    fromWireType: function () { },
                                    toWireType: function () { }
                                })
                            },
                            w: function (t, e, n) {
                                t = re(t), e = ve(e, "emval::as");
                                var i = [],
                                    r = se(i);
                                return C[n >> 2] = r, e.toWireType(i, t)
                            },
                            x: function (t, e, n, i, r) {
                                t = pn[t], e = re(e), n = dn(n);
                                var s = [];
                                return C[i >> 2] = se(s), t(e, n, s, r)
                            },
                            i: function (t, e, n, i) {
                                (t = pn[t])(e = re(e), n = dn(n), null, i)
                            },
                            c: Ze,
                            h: function (t, e) {
                                var n = function (t, e) {
                                    for (var n = Array(t), i = 0; i < t; ++i) n[i] = ve(C[e + 4 * i >> 2], "parameter " + i);
                                    return n
                                }(t, e),
                                    i = n[0];
                                e = i.name + "_$" + n.slice(1).map((function (t) {
                                    return t.name
                                })).join("_") + "$";
                                var r = mn[e];
                                if (void 0 !== r) return r;
                                var s = Array(t - 1);
                                return r = function (t) {
                                    var e = pn.length;
                                    return pn.push(t), e
                                }(((e, r, o, a) => {
                                    for (var l = 0, u = 0; u < t - 1; ++u) s[u] = n[u + 1].readValueFromPointer(a + l), l += n[u + 1].argPackAdvance;
                                    for (e = e[r].apply(e, s), u = 0; u < t - 1; ++u) n[u + 1].Rc && n[u + 1].Rc(s[u]);
                                    if (!i.ld) return i.toWireType(o, e)
                                })), mn[e] = r
                            },
                            u: function (t) {
                                return t = dn(t), se(r[t])
                            },
                            S: function (t, e) {
                                return t = re(t), e = re(e), se(t[e])
                            },
                            o: function (t) {
                                4 < t && (ee.get(t).uc += 1)
                            },
                            p: function (t) {
                                return se(dn(t))
                            },
                            D: function () {
                                return se({})
                            },
                            r: function (t) {
                                Ce(re(t)), Ze(t)
                            },
                            l: function (t, e, n) {
                                t = re(t), e = re(e), n = re(n), t[e] = n
                            },
                            s: function (t, e) {
                                return t = (t = ve(t, "_emval_take_value")).readValueFromPointer(e), se(t)
                            },
                            b: () => {
                                H("")
                            },
                            j: (t, e, n) => {
                                var i;
                                for (gn.length = 0, n >>= 2; i = S[e++];) n += 105 != i & n, gn.push(105 == i ? D[n] : P[n++ >> 1]), ++n;
                                return Y[t].apply(null, gn)
                            },
                            H: t => {
                                var e = S.length;
                                if (2147483648 < (t >>>= 0)) return !1;
                                for (var n = 1; 4 >= n; n *= 2) {
                                    var i = e * (1 + .2 / n);
                                    i = Math.min(i, t + 100663296);
                                    var r = Math;
                                    i = Math.max(t, i);
                                    t: {
                                        r = r.min.call(r, 2147483648, i + (65536 - i % 65536) % 65536) - x.buffer.byteLength + 65535 >>> 16;
                                        try {
                                            x.grow(r), R();
                                            var s = 1;
                                            break t
                                        } catch (t) { }
                                        s = void 0
                                    }
                                    if (s) return !0
                                }
                                return !1
                            },
                            I: (t, e) => {
                                var n = 0;
                                return yn().forEach((function (i, r) {
                                    var s = e + n;
                                    for (r = C[t + 4 * r >> 2] = s, s = 0; s < i.length; ++s) M[0 | r++] = i.charCodeAt(s);
                                    M[0 | r] = 0, n += i.length + 1
                                })), 0
                            },
                            J: (t, e) => {
                                var n = yn();
                                C[t >> 2] = n.length;
                                var i = 0;
                                return n.forEach((function (t) {
                                    i += t.length + 1
                                })), C[e >> 2] = i, 0
                            },
                            z: function (t) {
                                try {
                                    var e = Ft(t);
                                    if (null === e.Ya) throw new Et(8);
                                    e.Nb && (e.Nb = null);
                                    try {
                                        e.wa.close && e.wa.close(e)
                                    } catch (t) {
                                        throw t
                                    } finally {
                                        wt[e.Ya] = null
                                    }
                                    return e.Ya = null, 0
                                } catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return t.Xa
                                }
                            },
                            M: function (t, e, n, i) {
                                try {
                                    t: {
                                        var r = Ft(t); t = e;
                                        for (var s, o = e = 0; o < n; o++) {
                                            var a = C[t >> 2],
                                                l = C[t + 4 >> 2];
                                            t += 8;
                                            var u = r,
                                                c = a,
                                                h = l,
                                                d = s,
                                                f = M;
                                            if (0 > h || 0 > d) throw new Et(28);
                                            if (null === u.Ya) throw new Et(8);
                                            if (1 == (2097155 & u.flags)) throw new Et(8);
                                            if (16384 == (61440 & u.node.mode)) throw new Et(31);
                                            if (!u.wa.read) throw new Et(28);
                                            var p = void 0 !== d;
                                            if (p) {
                                                if (!u.seekable) throw new Et(70)
                                            } else d = u.position;
                                            var m = u.wa.read(u, f, c, h, d);
                                            p || (u.position += m);
                                            var g = m;
                                            if (0 > g) {
                                                var v = -1;
                                                break t
                                            }
                                            if (e += g, g < l) break;
                                            void 0 !== s && (s += g)
                                        }
                                        v = e
                                    }
                                    return C[i >> 2] = v,
                                        0
                                }
                                catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return t.Xa
                                }
                            },
                            E: function (t, e, n, i, r) {
                                e = n + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * n : NaN;
                                try {
                                    if (isNaN(e)) return 61;
                                    var s = Ft(t);
                                    return $t(s, e, i), q = [s.position >>> 0, (X = s.position, 1 <= +Math.abs(X) ? 0 < X ? +Math.floor(X / 4294967296) >>> 0 : ~~+Math.ceil((X - +(~~X >>> 0)) / 4294967296) >>> 0 : 0)], D[r >> 2] = q[0], D[r + 4 >> 2] = q[1], s.Nb && 0 === e && 0 === i && (s.Nb = null), 0
                                } catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return t.Xa
                                }
                            },
                            L: function (t, e, n, i) {
                                try {
                                    t: {
                                        var r = Ft(t); t = e;
                                        for (var s, o = e = 0; o < n; o++) {
                                            var a = C[t >> 2],
                                                l = C[t + 4 >> 2];
                                            t += 8;
                                            var u = r,
                                                c = a,
                                                h = l,
                                                d = s,
                                                f = M;
                                            if (0 > h || 0 > d) throw new Et(28);
                                            if (null === u.Ya) throw new Et(8);
                                            if (!(2097155 & u.flags)) throw new Et(8);
                                            if (16384 == (61440 & u.node.mode)) throw new Et(31);
                                            if (!u.wa.write) throw new Et(28);
                                            u.seekable && 1024 & u.flags && $t(u, 0, 2);
                                            var p = void 0 !== d;
                                            if (p) {
                                                if (!u.seekable) throw new Et(70)
                                            } else d = u.position;
                                            var m = u.wa.write(u, f, c, h, d, void 0);
                                            p || (u.position += m);
                                            var g = m;
                                            if (0 > g) {
                                                var v = -1;
                                                break t
                                            }
                                            e += g, void 0 !== s && (s += g)
                                        }
                                        v = e
                                    }
                                    return C[i >> 2] = v,
                                        0
                                }
                                catch (t) {
                                    if (void 0 === Yt || "ErrnoError" !== t.name) throw t;
                                    return t.Xa
                                }
                            },
                            G: (t, e, n, i) => ((t, e, n, i) => {
                                function r(t, e, n) {
                                    for (t = "number" == typeof t ? t.toString() : t || ""; t.length < e;) t = n[0] + t;
                                    return t
                                }

                                function s(t, e) {
                                    return r(t, e, "0")
                                }

                                function o(t, e) {
                                    function n(t) {
                                        return 0 > t ? -1 : 0 < t ? 1 : 0
                                    }
                                    var i;
                                    return 0 === (i = n(t.getFullYear() - e.getFullYear())) && 0 === (i = n(t.getMonth() - e.getMonth())) && (i = n(t.getDate() - e.getDate())), i
                                }

                                function a(t) {
                                    switch (t.getDay()) {
                                        case 0:
                                            return new Date(t.getFullYear() - 1, 11, 29);
                                        case 1:
                                            return t;
                                        case 2:
                                            return new Date(t.getFullYear(), 0, 3);
                                        case 3:
                                            return new Date(t.getFullYear(), 0, 2);
                                        case 4:
                                            return new Date(t.getFullYear(), 0, 1);
                                        case 5:
                                            return new Date(t.getFullYear() - 1, 11, 31);
                                        case 6:
                                            return new Date(t.getFullYear() - 1, 11, 30)
                                    }
                                }

                                function l(t) {
                                    var e = t.bb;
                                    for (t = new Date(new Date(t.cb + 1900, 0, 1).getTime()); 0 < e;) {
                                        var n = t.getMonth(),
                                            i = (bn(t.getFullYear()) ? _n : xn)[n];
                                        if (!(e > i - t.getDate())) {
                                            t.setDate(t.getDate() + e);
                                            break
                                        }
                                        e -= i - t.getDate() + 1, t.setDate(1), 11 > n ? t.setMonth(n + 1) : (t.setMonth(0), t.setFullYear(t.getFullYear() + 1))
                                    }
                                    return n = new Date(t.getFullYear() + 1, 0, 4), e = a(new Date(t.getFullYear(), 0, 4)), n = a(n), 0 >= o(e, t) ? 0 >= o(n, t) ? t.getFullYear() + 1 : t.getFullYear() : t.getFullYear() - 1
                                }
                                var u = D[i + 40 >> 2];
                                for (var c in i = {
                                    Ed: D[i >> 2],
                                    Dd: D[i + 4 >> 2],
                                    Fb: D[i + 8 >> 2],
                                    Tb: D[i + 12 >> 2],
                                    Gb: D[i + 16 >> 2],
                                    cb: D[i + 20 >> 2],
                                    Ra: D[i + 24 >> 2],
                                    bb: D[i + 28 >> 2],
                                    Rd: D[i + 32 >> 2],
                                    Cd: D[i + 36 >> 2],
                                    Fd: u && u ? rt(S, u) : ""
                                }, n = n ? rt(S, n) : "", u = {
                                    "%c": "%a %b %d %H:%M:%S %Y",
                                    "%D": "%m/%d/%y",
                                    "%F": "%Y-%m-%d",
                                    "%h": "%b",
                                    "%r": "%I:%M:%S %p",
                                    "%R": "%H:%M",
                                    "%T": "%H:%M:%S",
                                    "%x": "%m/%d/%y",
                                    "%X": "%H:%M:%S",
                                    "%Ec": "%c",
                                    "%EC": "%C",
                                    "%Ex": "%m/%d/%y",
                                    "%EX": "%H:%M:%S",
                                    "%Ey": "%y",
                                    "%EY": "%Y",
                                    "%Od": "%d",
                                    "%Oe": "%e",
                                    "%OH": "%H",
                                    "%OI": "%I",
                                    "%Om": "%m",
                                    "%OM": "%M",
                                    "%OS": "%S",
                                    "%Ou": "%u",
                                    "%OU": "%U",
                                    "%OV": "%V",
                                    "%Ow": "%w",
                                    "%OW": "%W",
                                    "%Oy": "%y"
                                }) n = n.replace(new RegExp(c, "g"), u[c]);
                                var h = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                                    d = "January February March April May June July August September October November December".split(" ");
                                for (c in u = {
                                    "%a": t => h[t.Ra].substring(0, 3),
                                    "%A": t => h[t.Ra],
                                    "%b": t => d[t.Gb].substring(0, 3),
                                    "%B": t => d[t.Gb],
                                    "%C": t => s((t.cb + 1900) / 100 | 0, 2),
                                    "%d": t => s(t.Tb, 2),
                                    "%e": t => r(t.Tb, 2, " "),
                                    "%g": t => l(t).toString().substring(2),
                                    "%G": t => l(t),
                                    "%H": t => s(t.Fb, 2),
                                    "%I": t => (0 == (t = t.Fb) ? t = 12 : 12 < t && (t -= 12), s(t, 2)),
                                    "%j": t => {
                                        for (var e = 0, n = 0; n <= t.Gb - 1; e += (bn(t.cb + 1900) ? _n : xn)[n++]);
                                        return s(t.Tb + e, 3)
                                    },
                                    "%m": t => s(t.Gb + 1, 2),
                                    "%M": t => s(t.Dd, 2),
                                    "%n": () => "\n",
                                    "%p": t => 0 <= t.Fb && 12 > t.Fb ? "AM" : "PM",
                                    "%S": t => s(t.Ed, 2),
                                    "%t": () => "\t",
                                    "%u": t => t.Ra || 7,
                                    "%U": t => s(Math.floor((t.bb + 7 - t.Ra) / 7), 2),
                                    "%V": t => {
                                        var e = Math.floor((t.bb + 7 - (t.Ra + 6) % 7) / 7);
                                        if (2 >= (t.Ra + 371 - t.bb - 2) % 7 && e++, e) 53 == e && (4 == (n = (t.Ra + 371 - t.bb) % 7) || 3 == n && bn(t.cb) || (e = 1));
                                        else {
                                            e = 52;
                                            var n = (t.Ra + 7 - t.bb - 1) % 7;
                                            (4 == n || 5 == n && bn(t.cb % 400 - 1)) && e++
                                        }
                                        return s(e, 2)
                                    },
                                    "%w": t => t.Ra,
                                    "%W": t => s(Math.floor((t.bb + 7 - (t.Ra + 6) % 7) / 7), 2),
                                    "%y": t => (t.cb + 1900).toString().substring(2),
                                    "%Y": t => t.cb + 1900,
                                    "%z": t => {
                                        var e = 0 <= (t = t.Cd);
                                        return t = Math.abs(t) / 60, (e ? "+" : "-") + String("0000" + (t / 60 * 100 + t % 60)).slice(-4)
                                    },
                                    "%Z": t => t.Fd,
                                    "%%": () => "%"
                                }, n = n.replace(/%%/g, "\0\0"), u) n.includes(c) && (n = n.replace(new RegExp(c, "g"), u[c](i)));
                                return (c = lt(n = n.replace(/\0\0/g, "%"), !1)).length > e ? 0 : (M.set(c, t), c.length - 1)
                            })(t, e, n, i)
                        };
                        ! function () {
                            function t(t) {
                                if (w = t = t.exports, x = w.X, R(), k = w.ha, I.unshift(w.Y), U--, r.monitorRunDependencies && r.monitorRunDependencies(U), 0 == U && (null !== B && (clearInterval(B), B = null), j)) {
                                    var e = j;
                                    j = null, e()
                                }
                                return t
                            }
                            var e = {
                                a: Tn
                            };
                            if (U++, r.monitorRunDependencies && r.monitorRunDependencies(U), r.instantiateWasm) try {
                                return r.instantiateWasm(e, t)
                            } catch (t) {
                                _("Module.instantiateWasm callback failed with error: " + t), n(t)
                            } (function (t, e) {
                                var n = z;
                                return y || "function" != typeof WebAssembly.instantiateStreaming || V(n) || n.startsWith("file://") || "function" != typeof fetch ? $(n, t, e) : fetch(n, {
                                    credentials: "same-origin"
                                }).then((i => WebAssembly.instantiateStreaming(i, t).then(e, (function (i) {
                                    return _("wasm streaming compile failed: " + i), _("falling back to ArrayBuffer instantiation"), $(n, t, e)
                                }))))
                            })(e, (function (e) {
                                t(e.instance)
                            })).catch(n)
                        }();
                        var En = t => (En = w.Z)(t),
                            Dn = t => (Dn = w._)(t),
                            Cn = r._ma_device__on_notification_unlocked = t => (Cn = r._ma_device__on_notification_unlocked = w.$)(t);
                        r._ma_malloc_emscripten = (t, e) => (r._ma_malloc_emscripten = w.aa)(t, e), r._ma_free_emscripten = (t, e) => (r._ma_free_emscripten = w.ba)(t, e);
                        var An, Pn = r._ma_device_process_pcm_frames_capture__webaudio = (t, e, n) => (Pn = r._ma_device_process_pcm_frames_capture__webaudio = w.ca)(t, e, n),
                            Ln = r._ma_device_process_pcm_frames_playback__webaudio = (t, e, n) => (Ln = r._ma_device_process_pcm_frames_playback__webaudio = w.da)(t, e, n),
                            Rn = () => (Rn = w.ea)(),
                            kn = t => (kn = w.fa)(t);

                        function On() {
                            function t() {
                                if (!An && (An = !0, r.calledRun = !0, !L)) {
                                    if (r.noFSInit || mt || (mt = !0, Xt(), r.stdin = r.stdin, r.stdout = r.stdout, r.stderr = r.stderr, r.stdin ? qt("stdin", r.stdin) : Vt("/dev/tty", "/dev/stdin"), r.stdout ? qt("stdout", null, r.stdout) : Vt("/dev/tty", "/dev/stdout"), r.stderr ? qt("stderr", null, r.stderr) : Vt("/dev/tty1", "/dev/stderr"), Wt("/dev/stdin", 0), Wt("/dev/stdout", 1), Wt("/dev/stderr", 1)), Tt = !1, K(I), e(r), r.onRuntimeInitialized && r.onRuntimeInitialized(), r.postRun)
                                        for ("function" == typeof r.postRun && (r.postRun = [r.postRun]); r.postRun.length;) {
                                            var t = r.postRun.shift();
                                            F.unshift(t)
                                        }
                                    K(F)
                                }
                            }
                            if (!(0 < U)) {
                                if (r.preRun)
                                    for ("function" == typeof r.preRun && (r.preRun = [r.preRun]); r.preRun.length;) N();
                                K(O), 0 < U || (r.setStatus ? (r.setStatus("Running..."), setTimeout((function () {
                                    setTimeout((function () {
                                        r.setStatus("")
                                    }), 1), t()
                                }), 1)) : t())
                            }
                        }
                        if (r.__embind_initialize_bindings = () => (r.__embind_initialize_bindings = w.ga)(), r.dynCall_iiji = (t, e, n, i, s) => (r.dynCall_iiji = w.ia)(t, e, n, i, s), r.dynCall_iiiji = (t, e, n, i, s, o) => (r.dynCall_iiiji = w.ja)(t, e, n, i, s, o), r.dynCall_jiji = (t, e, n, i, s) => (r.dynCall_jiji = w.ka)(t, e, n, i, s), r.dynCall_iij = (t, e, n, i) => (r.dynCall_iij = w.la)(t, e, n, i), r.dynCall_jii = (t, e, n) => (r.dynCall_jii = w.ma)(t, e, n), r.dynCall_viijii = (t, e, n, i, s, o, a) => (r.dynCall_viijii = w.na)(t, e, n, i, s, o, a), r.dynCall_iiiiij = (t, e, n, i, s, o, a) => (r.dynCall_iiiiij = w.oa)(t, e, n, i, s, o, a), r.dynCall_iiiiijj = (t, e, n, i, s, o, a, l, u) => (r.dynCall_iiiiijj = w.pa)(t, e, n, i, s, o, a, l, u), r.dynCall_iiiiiijj = (t, e, n, i, s, o, a, l, u, c) => (r.dynCall_iiiiiijj = w.qa)(t, e, n, i, s, o, a, l, u, c), j = function t() {
                            An || On(), An || (j = t)
                        }, r.preInit)
                            for ("function" == typeof r.preInit && (r.preInit = [r.preInit]); 0 < r.preInit.length;) r.preInit.pop()();
                        return On(), t.ready
                    });
                    const s = r
                }, t => {
                    t.exports = JSON.parse('{"name":"@rive-app/canvas","version":"2.10.4","description":"Rive\'s canvas based web api.","main":"rive.js","homepage":"https://rive.app","repository":{"type":"git","url":"https://github.com/rive-app/rive-wasm/tree/master/js"},"keywords":["rive","animation"],"author":"Rive","contributors":["Luigi Rosso <luigi@rive.app> (https://rive.app)","Maxwell Talbot <max@rive.app> (https://rive.app)","Arthur Vivian <arthur@rive.app> (https://rive.app)","Umberto Sonnino <umberto@rive.app> (https://rive.app)","Matthew Sullivan <matt.j.sullivan@gmail.com> (mailto:matt.j.sullivan@gmail.com)"],"license":"MIT","files":["rive.js","rive.js.map","rive.wasm","rive.d.ts","rive_advanced.mjs.d.ts"],"typings":"rive.d.ts","dependencies":{},"browser":{"fs":false,"path":false}}')
                }, (t, e, n) => {
                    n.r(e), n.d(e, {
                        BLANK_URL: () => r.BLANK_URL,
                        registerTouchInteractions: () => i.registerTouchInteractions,
                        sanitizeUrl: () => r.sanitizeUrl
                    });
                    var i = n(4),
                        r = n(5)
                }, (t, e, n) => {
                    n.r(e), n.d(e, {
                        registerTouchInteractions: () => i
                    });
                    var i = function (t) {
                        var e = t.canvas,
                            n = t.artboard,
                            i = t.stateMachines,
                            r = void 0 === i ? [] : i,
                            s = t.renderer,
                            o = t.rive,
                            a = t.fit,
                            l = t.alignment;
                        if (!(e && r.length && s && o && n && "undefined" != typeof window)) return null;
                        var u = function (t) {
                            var e = t.currentTarget.getBoundingClientRect(),
                                i = function (t) {
                                    var e, n;
                                    return ["touchstart", "touchmove"].indexOf(t.type) > -1 && (null === (e = t.touches) || void 0 === e ? void 0 : e.length) ? (t.preventDefault(), {
                                        clientX: t.touches[0].clientX,
                                        clientY: t.touches[0].clientY
                                    }) : "touchend" === t.type && (null === (n = t.changedTouches) || void 0 === n ? void 0 : n.length) ? {
                                        clientX: t.changedTouches[0].clientX,
                                        clientY: t.changedTouches[0].clientY
                                    } : {
                                        clientX: t.clientX,
                                        clientY: t.clientY
                                    }
                                }(t),
                                s = i.clientX,
                                u = i.clientY;
                            if (s || u) {
                                var c = s - e.left,
                                    h = u - e.top,
                                    d = o.computeAlignment(a, l, {
                                        minX: 0,
                                        minY: 0,
                                        maxX: e.width,
                                        maxY: e.height
                                    }, n.bounds),
                                    f = new o.Mat2D;
                                d.invert(f);
                                var p = new o.Vec2D(c, h),
                                    m = o.mapXY(f, p),
                                    g = m.x(),
                                    v = m.y();
                                switch (m.delete(), f.delete(), p.delete(), d.delete(), t.type) {
                                    case "mouseout":
                                        for (var y = 0, b = r; y < b.length; y++) b[y].pointerMove(g < 0 ? g - 1e4 : g + 1e4, v < 0 ? v - 1e4 : v + 1e4);
                                        break;
                                    case "touchmove":
                                    case "mouseover":
                                    case "mousemove":
                                        for (var _ = 0, x = r; _ < x.length; _++) x[_].pointerMove(g, v);
                                        break;
                                    case "touchstart":
                                    case "mousedown":
                                        for (var w = 0, M = r; w < M.length; w++) M[w].pointerDown(g, v);
                                        break;
                                    case "touchend":
                                    case "mouseup":
                                        for (var S = 0, T = r; S < T.length; S++) T[S].pointerUp(g, v)
                                }
                            }
                        }.bind(void 0);
                        return e.addEventListener("mouseover", u), e.addEventListener("mouseout", u), e.addEventListener("mousemove", u), e.addEventListener("mousedown", u), e.addEventListener("mouseup", u), e.addEventListener("touchmove", u), e.addEventListener("touchstart", u), e.addEventListener("touchend", u),
                            function () {
                                e.removeEventListener("mouseover", u), e.removeEventListener("mouseout", u), e.removeEventListener("mousemove", u), e.removeEventListener("mousedown", u), e.removeEventListener("mouseup", u), e.removeEventListener("touchmove", u), e.removeEventListener("touchstart", u), e.removeEventListener("touchend", u)
                            }
                    }
                }, (t, e, n) => {
                    n.r(e), n.d(e, {
                        BLANK_URL: () => u,
                        sanitizeUrl: () => c
                    });
                    var i = /^([^\w]*)(javascript|data|vbscript)/im,
                        r = /&#(\w+)(^\w|;)?/g,
                        s = /&(newline|tab);/gi,
                        o = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim,
                        a = /^.+(:|&colon;)/gim,
                        l = [".", "/"],
                        u = "about:blank";

                    function c(t) {
                        if (!t) return u;
                        var e, n = (e = t, e.replace(o, "").replace(r, (function (t, e) {
                            return String.fromCharCode(e)
                        }))).replace(s, "").replace(o, "").trim();
                        if (!n) return u;
                        if (function (t) {
                            return l.indexOf(t[0]) > -1
                        }(n)) return n;
                        var c = n.match(a);
                        if (!c) return n;
                        var h = c[0];
                        return i.test(h) ? u : n
                    }
                }],
                    e = {};

                function n(i) {
                    var r = e[i];
                    if (void 0 !== r) return r.exports;
                    var s = e[i] = {
                        exports: {}
                    };
                    return t[i](s, s.exports, n), s.exports
                }
                n.d = (t, e) => {
                    for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
                        enumerable: !0,
                        get: e[i]
                    })
                }, n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.r = t => {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    })
                };
                var i = {};
                return (() => {
                    n.r(i), n.d(i, {
                        Alignment: () => e,
                        EventType: () => m,
                        Fit: () => t,
                        Layout: () => c,
                        LoopType: () => g,
                        Rive: () => x,
                        RiveEventType: () => f,
                        RuntimeLoader: () => h,
                        StateMachineInput: () => p,
                        StateMachineInputType: () => u,
                        Testing: () => S,
                        decodeFont: () => E,
                        decodeImage: () => T
                    });
                    var t, e, r = n(1),
                        s = n(2),
                        o = n(3),
                        a = function (t, e, n, i) {
                            return new (n || (n = Promise))((function (r, s) {
                                function o(t) {
                                    try {
                                        l(i.next(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }

                                function a(t) {
                                    try {
                                        l(i.throw(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }

                                function l(t) {
                                    var e;
                                    t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) {
                                        t(e)
                                    }))).then(o, a)
                                }
                                l((i = i.apply(t, e || [])).next())
                            }))
                        },
                        l = function (t, e) {
                            var n, i, r, s, o = {
                                label: 0,
                                sent: function () {
                                    if (1 & r[0]) throw r[1];
                                    return r[1]
                                },
                                trys: [],
                                ops: []
                            };
                            return s = {
                                next: a(0),
                                throw: a(1),
                                return: a(2)
                            }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
                                return this
                            }), s;

                            function a(a) {
                                return function (l) {
                                    return function (a) {
                                        if (n) throw new TypeError("Generator is already executing.");
                                        for (; s && (s = 0, a[0] && (o = 0)), o;) try {
                                            if (n = 1, i && (r = 2 & a[0] ? i.return : a[0] ? i.throw || ((r = i.return) && r.call(i), 0) : i.next) && !(r = r.call(i, a[1])).done) return r;
                                            switch (i = 0, r && (a = [2 & a[0], r.value]), a[0]) {
                                                case 0:
                                                case 1:
                                                    r = a;
                                                    break;
                                                case 4:
                                                    return o.label++, {
                                                        value: a[1],
                                                        done: !1
                                                    };
                                                case 5:
                                                    o.label++, i = a[1], a = [0];
                                                    continue;
                                                case 7:
                                                    a = o.ops.pop(), o.trys.pop();
                                                    continue;
                                                default:
                                                    if (!((r = (r = o.trys).length > 0 && r[r.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                                                        o = 0;
                                                        continue
                                                    }
                                                    if (3 === a[0] && (!r || a[1] > r[0] && a[1] < r[3])) {
                                                        o.label = a[1];
                                                        break
                                                    }
                                                    if (6 === a[0] && o.label < r[1]) {
                                                        o.label = r[1], r = a;
                                                        break
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        o.label = r[2], o.ops.push(a);
                                                        break
                                                    }
                                                    r[2] && o.ops.pop(), o.trys.pop();
                                                    continue
                                            }
                                            a = e.call(t, o)
                                        } catch (t) {
                                            a = [6, t], i = 0
                                        } finally {
                                                n = r = 0
                                            }
                                        if (5 & a[0]) throw a[1];
                                        return {
                                            value: a[0] ? a[1] : void 0,
                                            done: !0
                                        }
                                    }([a, l])
                                }
                            }
                        };
                    ! function (t) {
                        t.Cover = "cover", t.Contain = "contain", t.Fill = "fill", t.FitWidth = "fitWidth", t.FitHeight = "fitHeight", t.None = "none", t.ScaleDown = "scaleDown"
                    }(t || (t = {})),
                        function (t) {
                            t.Center = "center", t.TopLeft = "topLeft", t.TopCenter = "topCenter", t.TopRight = "topRight", t.CenterLeft = "centerLeft", t.CenterRight = "centerRight", t.BottomLeft = "bottomLeft", t.BottomCenter = "bottomCenter", t.BottomRight = "bottomRight"
                        }(e || (e = {}));
                    var u, c = function () {
                        function n(n) {
                            var i, r, s, o, a, l;
                            this.fit = null !== (i = null == n ? void 0 : n.fit) && void 0 !== i ? i : t.Contain, this.alignment = null !== (r = null == n ? void 0 : n.alignment) && void 0 !== r ? r : e.Center, this.minX = null !== (s = null == n ? void 0 : n.minX) && void 0 !== s ? s : 0, this.minY = null !== (o = null == n ? void 0 : n.minY) && void 0 !== o ? o : 0, this.maxX = null !== (a = null == n ? void 0 : n.maxX) && void 0 !== a ? a : 0, this.maxY = null !== (l = null == n ? void 0 : n.maxY) && void 0 !== l ? l : 0
                        }
                        return n.new = function (t) {
                            var e = t.fit,
                                i = t.alignment,
                                r = t.minX,
                                s = t.minY,
                                o = t.maxX,
                                a = t.maxY;
                            return console.warn("This function is deprecated: please use `new Layout({})` instead"), new n({
                                fit: e,
                                alignment: i,
                                minX: r,
                                minY: s,
                                maxX: o,
                                maxY: a
                            })
                        }, n.prototype.copyWith = function (t) {
                            var e = t.fit,
                                i = t.alignment,
                                r = t.minX,
                                s = t.minY,
                                o = t.maxX,
                                a = t.maxY;
                            return new n({
                                fit: null != e ? e : this.fit,
                                alignment: null != i ? i : this.alignment,
                                minX: null != r ? r : this.minX,
                                minY: null != s ? s : this.minY,
                                maxX: null != o ? o : this.maxX,
                                maxY: null != a ? a : this.maxY
                            })
                        }, n.prototype.runtimeFit = function (e) {
                            return this.cachedRuntimeFit ? this.cachedRuntimeFit : (n = this.fit === t.Cover ? e.Fit.cover : this.fit === t.Contain ? e.Fit.contain : this.fit === t.Fill ? e.Fit.fill : this.fit === t.FitWidth ? e.Fit.fitWidth : this.fit === t.FitHeight ? e.Fit.fitHeight : this.fit === t.ScaleDown ? e.Fit.scaleDown : e.Fit.none, this.cachedRuntimeFit = n, n);
                            var n
                        }, n.prototype.runtimeAlignment = function (t) {
                            return this.cachedRuntimeAlignment ? this.cachedRuntimeAlignment : (n = this.alignment === e.TopLeft ? t.Alignment.topLeft : this.alignment === e.TopCenter ? t.Alignment.topCenter : this.alignment === e.TopRight ? t.Alignment.topRight : this.alignment === e.CenterLeft ? t.Alignment.centerLeft : this.alignment === e.CenterRight ? t.Alignment.centerRight : this.alignment === e.BottomLeft ? t.Alignment.bottomLeft : this.alignment === e.BottomCenter ? t.Alignment.bottomCenter : this.alignment === e.BottomRight ? t.Alignment.bottomRight : t.Alignment.center, this.cachedRuntimeAlignment = n, n);
                            var n
                        }, n
                    }(),
                        h = function () {
                            function t() { }
                            return t.loadRuntime = function () {
                                r.default({
                                    locateFile: function () {
                                        return t.wasmURL
                                    }
                                }).then((function (e) {
                                    var n;
                                    for (t.runtime = e; t.callBackQueue.length > 0;) null === (n = t.callBackQueue.shift()) || void 0 === n || n(t.runtime)
                                })).catch((function () {
                                    var e = "https://cdn.jsdelivr.net/npm/".concat(s.name, "@").concat(s.version, "/rive.wasm");
                                    t.wasmURL.toLowerCase() !== e ? (console.warn("Failed to load WASM from ".concat(t.wasmURL, ", trying jsdelivr as a backup")), t.setWasmUrl(e), t.loadRuntime()) : console.error("Could not load Rive WASM file from unpkg or jsdelivr, network connection may be down, or         you may need to call set a new WASM source via RuntimeLoader.setWasmUrl() and call         RuntimeLoader.loadRuntime() again")
                                }))
                            }, t.getInstance = function (e) {
                                t.isLoading || (t.isLoading = !0, t.loadRuntime()), t.runtime ? e(t.runtime) : t.callBackQueue.push(e)
                            }, t.awaitInstance = function () {
                                return new Promise((function (e) {
                                    return t.getInstance((function (t) {
                                        return e(t)
                                    }))
                                }))
                            }, t.setWasmUrl = function (e) {
                                t.wasmURL = e
                            }, t.isLoading = !1, t.callBackQueue = [], t.wasmURL = "https://unpkg.com/".concat(s.name, "@").concat(s.version, "/rive.wasm"), t
                        }(),
                        d = function () {
                            function t(t, e, n, i) {
                                this.animation = t, this.artboard = e, this.playing = i, this.loopCount = 0, this.scrubTo = null, this.instance = new n.LinearAnimationInstance(t, e)
                            }
                            return Object.defineProperty(t.prototype, "name", {
                                get: function () {
                                    return this.animation.name
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "time", {
                                get: function () {
                                    return this.instance.time
                                },
                                set: function (t) {
                                    this.instance.time = t
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "loopValue", {
                                get: function () {
                                    return this.animation.loopValue
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.advance = function (t) {
                                null === this.scrubTo ? this.instance.advance(t) : (this.instance.time = 0, this.instance.advance(this.scrubTo), this.scrubTo = null)
                            }, t.prototype.apply = function (t) {
                                this.instance.apply(t)
                            }, Object.defineProperty(t.prototype, "needsScrub", {
                                get: function () {
                                    return null !== this.scrubTo
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.cleanup = function () {
                                this.instance.delete()
                            }, t
                        }();
                    ! function (t) {
                        t[t.Number = 56] = "Number", t[t.Trigger = 58] = "Trigger", t[t.Boolean = 59] = "Boolean"
                    }(u || (u = {}));
                    var f, p = function () {
                        function t(t, e) {
                            this.type = t, this.runtimeInput = e
                        }
                        return Object.defineProperty(t.prototype, "name", {
                            get: function () {
                                return this.runtimeInput.name
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(t.prototype, "value", {
                            get: function () {
                                return this.runtimeInput.value
                            },
                            set: function (t) {
                                this.runtimeInput.value = t
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.prototype.fire = function () {
                            this.type === u.Trigger && this.runtimeInput.fire()
                        }, t
                    }();
                    ! function (t) {
                        t[t.General = 128] = "General", t[t.OpenUrl = 131] = "OpenUrl"
                    }(f || (f = {}));
                    var m, g, v = function () {
                        function t(t, e, n, i) {
                            this.stateMachine = t, this.playing = n, this.artboard = i, this.inputs = [], this.instance = new e.StateMachineInstance(t, i), this.initInputs(e)
                        }
                        return Object.defineProperty(t.prototype, "name", {
                            get: function () {
                                return this.stateMachine.name
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(t.prototype, "statesChanged", {
                            get: function () {
                                for (var t = [], e = 0; e < this.instance.stateChangedCount(); e++) t.push(this.instance.stateChangedNameByIndex(e));
                                return t
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.prototype.advance = function (t) {
                            this.instance.advance(t)
                        }, t.prototype.reportedEventCount = function () {
                            return this.instance.reportedEventCount()
                        }, t.prototype.reportedEventAt = function (t) {
                            return this.instance.reportedEventAt(t)
                        }, t.prototype.initInputs = function (t) {
                            for (var e = 0; e < this.instance.inputCount(); e++) {
                                var n = this.instance.input(e);
                                this.inputs.push(this.mapRuntimeInput(n, t))
                            }
                        }, t.prototype.mapRuntimeInput = function (t, e) {
                            return t.type === e.SMIInput.bool ? new p(u.Boolean, t.asBool()) : t.type === e.SMIInput.number ? new p(u.Number, t.asNumber()) : t.type === e.SMIInput.trigger ? new p(u.Trigger, t.asTrigger()) : void 0
                        }, t.prototype.cleanup = function () {
                            this.instance.delete()
                        }, t
                    }(),
                        y = function () {
                            function t(t, e, n, i, r) {
                                void 0 === i && (i = []), void 0 === r && (r = []), this.runtime = t, this.artboard = e, this.eventManager = n, this.animations = i, this.stateMachines = r
                            }
                            return t.prototype.add = function (t, e, n) {
                                if (void 0 === n && (n = !0), 0 === (t = M(t)).length) this.animations.forEach((function (t) {
                                    return t.playing = e
                                })), this.stateMachines.forEach((function (t) {
                                    return t.playing = e
                                }));
                                else
                                    for (var i = this.animations.map((function (t) {
                                        return t.name
                                    })), r = this.stateMachines.map((function (t) {
                                        return t.name
                                    })), s = 0; s < t.length; s++) {
                                        var o = i.indexOf(t[s]),
                                            a = r.indexOf(t[s]);
                                        if (o >= 0 || a >= 0) o >= 0 ? this.animations[o].playing = e : this.stateMachines[a].playing = e;
                                        else {
                                            var l = this.artboard.animationByName(t[s]);
                                            if (l) {
                                                var u = new d(l, this.artboard, this.runtime, e);
                                                u.advance(0), u.apply(1), this.animations.push(u)
                                            } else {
                                                var c = this.artboard.stateMachineByName(t[s]);
                                                if (c) {
                                                    var h = new v(c, this.runtime, e, this.artboard);
                                                    this.stateMachines.push(h)
                                                }
                                            }
                                        }
                                    }
                                return n && (e ? this.eventManager.fire({
                                    type: m.Play,
                                    data: this.playing
                                }) : this.eventManager.fire({
                                    type: m.Pause,
                                    data: this.paused
                                })), e ? this.playing : this.paused
                            }, t.prototype.initLinearAnimations = function (t, e) {
                                for (var n = this.animations.map((function (t) {
                                    return t.name
                                })), i = 0; i < t.length; i++) {
                                    var r = n.indexOf(t[i]);
                                    if (r >= 0) this.animations[r].playing = e;
                                    else {
                                        var s = this.artboard.animationByName(t[i]);
                                        if (s) {
                                            var o = new d(s, this.artboard, this.runtime, e);
                                            o.advance(0), o.apply(1), this.animations.push(o)
                                        }
                                    }
                                }
                            }, t.prototype.initStateMachines = function (t, e) {
                                for (var n = this.stateMachines.map((function (t) {
                                    return t.name
                                })), i = 0; i < t.length; i++) {
                                    var r = n.indexOf(t[i]);
                                    if (r >= 0) this.stateMachines[r].playing = e;
                                    else {
                                        var s = this.artboard.stateMachineByName(t[i]);
                                        if (s) {
                                            var o = new v(s, this.runtime, e, this.artboard);
                                            this.stateMachines.push(o)
                                        } else this.initLinearAnimations([t[i]], e)
                                    }
                                }
                            }, t.prototype.play = function (t) {
                                return this.add(t, !0)
                            }, t.prototype.pause = function (t) {
                                return this.add(t, !1)
                            }, t.prototype.scrub = function (t, e) {
                                var n = this.animations.filter((function (e) {
                                    return t.includes(e.name)
                                }));
                                return n.forEach((function (t) {
                                    return t.scrubTo = e
                                })), n.map((function (t) {
                                    return t.name
                                }))
                            }, Object.defineProperty(t.prototype, "playing", {
                                get: function () {
                                    return this.animations.filter((function (t) {
                                        return t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })).concat(this.stateMachines.filter((function (t) {
                                        return t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })))
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "paused", {
                                get: function () {
                                    return this.animations.filter((function (t) {
                                        return !t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })).concat(this.stateMachines.filter((function (t) {
                                        return !t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })))
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.stop = function (t) {
                                var e = this,
                                    n = [];
                                if (0 === (t = M(t)).length) n = this.animations.map((function (t) {
                                    return t.name
                                })).concat(this.stateMachines.map((function (t) {
                                    return t.name
                                }))), this.animations.forEach((function (t) {
                                    return t.cleanup()
                                })), this.stateMachines.forEach((function (t) {
                                    return t.cleanup()
                                })), this.animations.splice(0, this.animations.length), this.stateMachines.splice(0, this.stateMachines.length);
                                else {
                                    var i = this.animations.filter((function (e) {
                                        return t.includes(e.name)
                                    }));
                                    i.forEach((function (t) {
                                        t.cleanup(), e.animations.splice(e.animations.indexOf(t), 1)
                                    }));
                                    var r = this.stateMachines.filter((function (e) {
                                        return t.includes(e.name)
                                    }));
                                    r.forEach((function (t) {
                                        t.cleanup(), e.stateMachines.splice(e.stateMachines.indexOf(t), 1)
                                    })), n = i.map((function (t) {
                                        return t.name
                                    })).concat(r.map((function (t) {
                                        return t.name
                                    })))
                                }
                                return this.eventManager.fire({
                                    type: m.Stop,
                                    data: n
                                }), n
                            }, Object.defineProperty(t.prototype, "isPlaying", {
                                get: function () {
                                    return this.animations.reduce((function (t, e) {
                                        return t || e.playing
                                    }), !1) || this.stateMachines.reduce((function (t, e) {
                                        return t || e.playing
                                    }), !1)
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "isPaused", {
                                get: function () {
                                    return !this.isPlaying && (this.animations.length > 0 || this.stateMachines.length > 0)
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "isStopped", {
                                get: function () {
                                    return 0 === this.animations.length && 0 === this.stateMachines.length
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.atLeastOne = function (t, e) {
                                var n;
                                return void 0 === e && (e = !0), 0 === this.animations.length && 0 === this.stateMachines.length && (this.artboard.animationCount() > 0 ? this.add([n = this.artboard.animationByIndex(0).name], t, e) : this.artboard.stateMachineCount() > 0 && this.add([n = this.artboard.stateMachineByIndex(0).name], t, e)), n
                            }, t.prototype.handleLooping = function () {
                                for (var t = 0, e = this.animations.filter((function (t) {
                                    return t.playing
                                })); t < e.length; t++) {
                                    var n = e[t];
                                    0 === n.loopValue && n.loopCount ? (n.loopCount = 0, this.stop(n.name)) : 1 === n.loopValue && n.loopCount ? (this.eventManager.fire({
                                        type: m.Loop,
                                        data: {
                                            animation: n.name,
                                            type: g.Loop
                                        }
                                    }), n.loopCount = 0) : 2 === n.loopValue && n.loopCount > 1 && (this.eventManager.fire({
                                        type: m.Loop,
                                        data: {
                                            animation: n.name,
                                            type: g.PingPong
                                        }
                                    }), n.loopCount = 0)
                                }
                            }, t.prototype.handleStateChanges = function () {
                                for (var t = [], e = 0, n = this.stateMachines.filter((function (t) {
                                    return t.playing
                                })); e < n.length; e++) {
                                    var i = n[e];
                                    t.push.apply(t, i.statesChanged)
                                }
                                t.length > 0 && this.eventManager.fire({
                                    type: m.StateChange,
                                    data: t
                                })
                            }, t.prototype.handleAdvancing = function (t) {
                                this.eventManager.fire({
                                    type: m.Advance,
                                    data: t
                                })
                            }, t
                        }();
                    ! function (t) {
                        t.Load = "load", t.LoadError = "loaderror", t.Play = "play", t.Pause = "pause", t.Stop = "stop", t.Loop = "loop", t.Draw = "draw", t.Advance = "advance", t.StateChange = "statechange", t.RiveEvent = "riveevent"
                    }(m || (m = {})),
                        function (t) {
                            t.OneShot = "oneshot", t.Loop = "loop", t.PingPong = "pingpong"
                        }(g || (g = {}));
                    var b = function () {
                        function t(t) {
                            void 0 === t && (t = []), this.listeners = t
                        }
                        return t.prototype.getListeners = function (t) {
                            return this.listeners.filter((function (e) {
                                return e.type === t
                            }))
                        }, t.prototype.add = function (t) {
                            this.listeners.includes(t) || this.listeners.push(t)
                        }, t.prototype.remove = function (t) {
                            for (var e = 0; e < this.listeners.length; e++) {
                                var n = this.listeners[e];
                                if (n.type === t.type && n.callback === t.callback) {
                                    this.listeners.splice(e, 1);
                                    break
                                }
                            }
                        }, t.prototype.removeAll = function (t) {
                            var e = this;
                            t ? this.listeners.filter((function (e) {
                                return e.type === t
                            })).forEach((function (t) {
                                return e.remove(t)
                            })) : this.listeners.splice(0, this.listeners.length)
                        }, t.prototype.fire = function (t) {
                            this.getListeners(t.type).forEach((function (e) {
                                return e.callback(t)
                            }))
                        }, t
                    }(),
                        _ = function () {
                            function t(t) {
                                this.eventManager = t, this.queue = []
                            }
                            return t.prototype.add = function (t) {
                                this.queue.push(t)
                            }, t.prototype.process = function () {
                                for (; this.queue.length > 0;) {
                                    var t = this.queue.shift();
                                    (null == t ? void 0 : t.action) && t.action(), (null == t ? void 0 : t.event) && this.eventManager.fire(t.event)
                                }
                            }, t
                        }(),
                        x = function () {
                            function t(t) {
                                var e;
                                this.loaded = !1, this.readyForPlaying = !1, this.artboard = null, this.eventCleanup = null, this.shouldDisableRiveListeners = !1, this.automaticallyHandleEvents = !1, this.enableRiveAssetCDN = !0, this.durations = [], this.frameTimes = [], this.frameCount = 0, this.renderSecondTimer = 0, this.canvas = t.canvas, this.src = t.src, this.buffer = t.buffer, this.layout = null !== (e = t.layout) && void 0 !== e ? e : new c, this.shouldDisableRiveListeners = !!t.shouldDisableRiveListeners, this.automaticallyHandleEvents = !!t.automaticallyHandleEvents, this.enableRiveAssetCDN = void 0 === t.enableRiveAssetCDN || t.enableRiveAssetCDN, this.eventManager = new b, t.onLoad && this.on(m.Load, t.onLoad), t.onLoadError && this.on(m.LoadError, t.onLoadError), t.onPlay && this.on(m.Play, t.onPlay), t.onPause && this.on(m.Pause, t.onPause), t.onStop && this.on(m.Stop, t.onStop), t.onLoop && this.on(m.Loop, t.onLoop), t.onStateChange && this.on(m.StateChange, t.onStateChange), t.onAdvance && this.on(m.Advance, t.onAdvance), t.onload && !t.onLoad && this.on(m.Load, t.onload), t.onloaderror && !t.onLoadError && this.on(m.LoadError, t.onloaderror), t.onplay && !t.onPlay && this.on(m.Play, t.onplay), t.onpause && !t.onPause && this.on(m.Pause, t.onpause), t.onstop && !t.onStop && this.on(m.Stop, t.onstop), t.onloop && !t.onLoop && this.on(m.Loop, t.onloop), t.onstatechange && !t.onStateChange && this.on(m.StateChange, t.onstatechange), t.assetLoader && (this.assetLoader = t.assetLoader), this.taskQueue = new _(this.eventManager), this.init({
                                    src: this.src,
                                    buffer: this.buffer,
                                    autoplay: t.autoplay,
                                    animations: t.animations,
                                    stateMachines: t.stateMachines,
                                    artboard: t.artboard,
                                    useOffscreenRenderer: t.useOffscreenRenderer
                                })
                            }
                            return t.new = function (e) {
                                return console.warn("This function is deprecated: please use `new Rive({})` instead"), new t(e)
                            }, t.prototype.init = function (e) {
                                var n = this,
                                    i = e.src,
                                    r = e.buffer,
                                    s = e.animations,
                                    o = e.stateMachines,
                                    a = e.artboard,
                                    l = e.autoplay,
                                    u = void 0 !== l && l,
                                    c = e.useOffscreenRenderer,
                                    d = void 0 !== c && c;
                                if (this.src = i, this.buffer = r, !this.src && !this.buffer) throw new Error(t.missingErrorMessage);
                                var f = M(s),
                                    p = M(o);
                                this.loaded = !1, this.readyForPlaying = !1, h.awaitInstance().then((function (t) {
                                    n.runtime = t, n.renderer = n.runtime.makeRenderer(n.canvas, d), n.canvas.width || n.canvas.height || n.resizeDrawingSurfaceToCanvas(), n.initData(a, f, p, u).then((function () {
                                        return n.setupRiveListeners()
                                    })).catch((function (t) {
                                        console.error(t)
                                    }))
                                })).catch((function (t) {
                                    console.error(t)
                                }))
                            }, t.prototype.setupRiveListeners = function () {
                                var t = this;
                                if (!this.shouldDisableRiveListeners) {
                                    var e = (this.animator.stateMachines || []).filter((function (e) {
                                        return e.playing && t.runtime.hasListeners(e.instance)
                                    })).map((function (t) {
                                        return t.instance
                                    }));
                                    this.eventCleanup = (0, o.registerTouchInteractions)({
                                        canvas: this.canvas,
                                        artboard: this.artboard,
                                        stateMachines: e,
                                        renderer: this.renderer,
                                        rive: this.runtime,
                                        fit: this._layout.runtimeFit(this.runtime),
                                        alignment: this._layout.runtimeAlignment(this.runtime)
                                    })
                                }
                            }, t.prototype.initData = function (t, e, n, i) {
                                var r;
                                return a(this, void 0, void 0, (function () {
                                    var s, o, a, u;
                                    return l(this, (function (l) {
                                        switch (l.label) {
                                            case 0:
                                                return this.src ? (s = this, [4, w(this.src)]) : [3, 2];
                                            case 1:
                                                s.buffer = l.sent(), l.label = 2;
                                            case 2:
                                                return this.assetLoader && (o = new this.runtime.CustomFileAssetLoader({
                                                    loadContents: this.assetLoader
                                                })), a = this, [4, this.runtime.load(new Uint8Array(this.buffer), o, this.enableRiveAssetCDN)];
                                            case 3:
                                                return a.file = l.sent(), this.file ? (this.initArtboard(t, e, n, i), this.loaded = !0, this.eventManager.fire({
                                                    type: m.Load,
                                                    data: null !== (r = this.src) && void 0 !== r ? r : "buffer"
                                                }), this.readyForPlaying = !0, this.taskQueue.process(), this.drawFrame(), [2, Promise.resolve()]) : (u = "Problem loading file; may be corrupt!", console.warn(u), this.eventManager.fire({
                                                    type: m.LoadError,
                                                    data: u
                                                }), [2, Promise.reject(u)])
                                        }
                                    }))
                                }))
                            }, t.prototype.initArtboard = function (t, e, n, i) {
                                var r, s = t ? this.file.artboardByName(t) : this.file.defaultArtboard();
                                if (!s) {
                                    var o = "Invalid artboard name or no default artboard";
                                    return console.warn(o), void this.eventManager.fire({
                                        type: m.LoadError,
                                        data: o
                                    })
                                }
                                if (this.artboard = s, this.artboard.animationCount() < 1) throw o = "Artboard has no animations", this.eventManager.fire({
                                    type: m.LoadError,
                                    data: o
                                }), o;
                                this.animator = new y(this.runtime, this.artboard, this.eventManager), e.length > 0 || n.length > 0 ? (r = e.concat(n), this.animator.initLinearAnimations(e, i), this.animator.initStateMachines(n, i)) : r = [this.animator.atLeastOne(i, !1)], this.taskQueue.add({
                                    event: {
                                        type: i ? m.Play : m.Pause,
                                        data: r
                                    }
                                })
                            }, t.prototype.drawFrame = function () {
                                this.startRendering()
                            }, t.prototype.draw = function (t, e) {
                                var n = performance.now();
                                this.frameRequestId = null, this.lastRenderTime || (this.lastRenderTime = t), this.renderSecondTimer += t - this.lastRenderTime, this.renderSecondTimer > 5e3 && (this.renderSecondTimer = 0, null == e || e());
                                var i = (t - this.lastRenderTime) / 1e3;
                                this.lastRenderTime = t;
                                for (var r = 0, s = this.animator.animations.filter((function (t) {
                                    return t.playing || t.needsScrub
                                })).sort((function (t) {
                                    return t.needsScrub ? -1 : 1
                                })); r < s.length; r++) {
                                    var a = s[r];
                                    a.advance(i), a.instance.didLoop && (a.loopCount += 1), a.apply(1)
                                }
                                for (var l = 0, u = this.animator.stateMachines.filter((function (t) {
                                    return t.playing
                                })); l < u.length; l++) {
                                    var c = u[l],
                                        h = c.reportedEventCount();
                                    if (h)
                                        for (var d = 0; d < h; d++) {
                                            var p = c.reportedEventAt(d);
                                            if (p)
                                                if (p.type === f.OpenUrl) {
                                                    if (this.eventManager.fire({
                                                        type: m.RiveEvent,
                                                        data: p
                                                    }), this.automaticallyHandleEvents) {
                                                        var g = document.createElement("a"),
                                                            v = p,
                                                            y = v.url,
                                                            b = v.target,
                                                            _ = (0, o.sanitizeUrl)(y);
                                                        y && g.setAttribute("href", _), b && g.setAttribute("target", b), _ && _ !== o.BLANK_URL && g.click()
                                                    }
                                                } else this.eventManager.fire({
                                                    type: m.RiveEvent,
                                                    data: p
                                                })
                                        }
                                    c.advance(i)
                                }
                                this.artboard.advance(i);
                                var x = this.renderer;
                                x.clear(), x.save(), this.alignRenderer(), this.artboard.draw(x), x.restore(), x.flush(), this.animator.handleLooping(), this.animator.handleStateChanges(), this.animator.handleAdvancing(i), this.frameCount++;
                                var w = performance.now();
                                for (this.frameTimes.push(w), this.durations.push(w - n); this.frameTimes[0] <= w - 1e3;) this.frameTimes.shift(), this.durations.shift();
                                this.animator.isPlaying ? this.startRendering() : (this.animator.isPaused || this.animator.isStopped) && (this.lastRenderTime = 0)
                            }, t.prototype.alignRenderer = function () {
                                var t = this,
                                    e = t.renderer,
                                    n = t.runtime,
                                    i = t._layout,
                                    r = t.artboard;
                                e.align(i.runtimeFit(n), i.runtimeAlignment(n), {
                                    minX: i.minX,
                                    minY: i.minY,
                                    maxX: i.maxX,
                                    maxY: i.maxY
                                }, r.bounds)
                            }, Object.defineProperty(t.prototype, "fps", {
                                get: function () {
                                    return this.durations.length
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "frameTime", {
                                get: function () {
                                    return 0 === this.durations.length ? 0 : (this.durations.reduce((function (t, e) {
                                        return t + e
                                    }), 0) / this.durations.length).toFixed(4)
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.cleanup = function () {
                                var t, e, n;
                                this.stopRendering(), this.cleanupInstances(), (null === (t = this.runtime) || void 0 === t ? void 0 : t.CanvasRenderer) && (null === (e = this.renderer) || void 0 === e || e.delete()), this.renderer = null, null === (n = this.file) || void 0 === n || n.delete(), this.file = null
                            }, t.prototype.cleanupInstances = function () {
                                null !== this.eventCleanup && this.eventCleanup(), this.stop(), this.artboard && (this.artboard.delete(), this.artboard = null)
                            }, t.prototype.retrieveTextRun = function (t) {
                                var e;
                                if (t)
                                    if (this.artboard) {
                                        var n = this.artboard.textRun(t);
                                        if (n) return n;
                                        console.warn("Could not access a text run with name '".concat(t, "' in the '").concat(null === (e = this.artboard) || void 0 === e ? void 0 : e.name, "' Artboard. Note that you must rename a text run node in the Rive editor to make it queryable at runtime."))
                                    } else console.warn("Tried to access text run, but the Artboard is null");
                                else console.warn("No text run name provided")
                            }, t.prototype.getTextRunValue = function (t) {
                                var e = this.retrieveTextRun(t);
                                return e ? e.text : void 0
                            }, t.prototype.setTextRunValue = function (t, e) {
                                var n = this.retrieveTextRun(t);
                                n && (n.text = e)
                            }, t.prototype.play = function (t, e) {
                                var n = this;
                                t = M(t), this.readyForPlaying ? (this.animator.play(t), this.eventCleanup && this.eventCleanup(), this.setupRiveListeners(), this.startRendering()) : this.taskQueue.add({
                                    action: function () {
                                        return n.play(t, e)
                                    }
                                })
                            }, t.prototype.pause = function (t) {
                                var e = this;
                                t = M(t), this.readyForPlaying ? (this.eventCleanup && this.eventCleanup(), this.animator.pause(t)) : this.taskQueue.add({
                                    action: function () {
                                        return e.pause(t)
                                    }
                                })
                            }, t.prototype.scrub = function (t, e) {
                                var n = this;
                                t = M(t), this.readyForPlaying ? (this.animator.scrub(t, e || 0), this.drawFrame()) : this.taskQueue.add({
                                    action: function () {
                                        return n.scrub(t, e)
                                    }
                                })
                            }, t.prototype.stop = function (t) {
                                var e = this;
                                t = M(t), this.readyForPlaying ? (this.animator.stop(t), this.eventCleanup && this.eventCleanup()) : this.taskQueue.add({
                                    action: function () {
                                        return e.stop(t)
                                    }
                                })
                            }, t.prototype.reset = function (t) {
                                var e, n = null == t ? void 0 : t.artboard,
                                    i = M(null == t ? void 0 : t.animations),
                                    r = M(null == t ? void 0 : t.stateMachines),
                                    s = null !== (e = null == t ? void 0 : t.autoplay) && void 0 !== e && e;
                                this.cleanupInstances(), this.initArtboard(n, i, r, s), this.taskQueue.process()
                            }, t.prototype.load = function (t) {
                                this.stop(), this.init(t)
                            }, Object.defineProperty(t.prototype, "layout", {
                                get: function () {
                                    return this._layout
                                },
                                set: function (t) {
                                    this._layout = t, t.maxX && t.maxY || this.resizeToCanvas(), this.loaded && !this.animator.isPlaying && this.drawFrame()
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.resizeToCanvas = function () {
                                this._layout = this.layout.copyWith({
                                    minX: 0,
                                    minY: 0,
                                    maxX: this.canvas.width,
                                    maxY: this.canvas.height
                                })
                            }, t.prototype.resizeDrawingSurfaceToCanvas = function (t) {
                                if (this.canvas instanceof HTMLCanvasElement && window) {
                                    var e = this.canvas.getBoundingClientRect(),
                                        n = e.width,
                                        i = e.height,
                                        r = t || window.devicePixelRatio || 1;
                                    this.canvas.width = r * n, this.canvas.height = r * i, this.startRendering(), this.resizeToCanvas()
                                }
                            }, Object.defineProperty(t.prototype, "source", {
                                get: function () {
                                    return this.src
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "activeArtboard", {
                                get: function () {
                                    return this.artboard ? this.artboard.name : ""
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "animationNames", {
                                get: function () {
                                    if (!this.loaded) return [];
                                    for (var t = [], e = 0; e < this.artboard.animationCount(); e++) t.push(this.artboard.animationByIndex(e).name);
                                    return t
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "stateMachineNames", {
                                get: function () {
                                    if (!this.loaded) return [];
                                    for (var t = [], e = 0; e < this.artboard.stateMachineCount(); e++) t.push(this.artboard.stateMachineByIndex(e).name);
                                    return t
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.stateMachineInputs = function (t) {
                                if (this.loaded) {
                                    var e = this.animator.stateMachines.find((function (e) {
                                        return e.name === t
                                    }));
                                    return null == e ? void 0 : e.inputs
                                }
                            }, Object.defineProperty(t.prototype, "playingStateMachineNames", {
                                get: function () {
                                    return this.loaded ? this.animator.stateMachines.filter((function (t) {
                                        return t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })) : []
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "playingAnimationNames", {
                                get: function () {
                                    return this.loaded ? this.animator.animations.filter((function (t) {
                                        return t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })) : []
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "pausedAnimationNames", {
                                get: function () {
                                    return this.loaded ? this.animator.animations.filter((function (t) {
                                        return !t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })) : []
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "pausedStateMachineNames", {
                                get: function () {
                                    return this.loaded ? this.animator.stateMachines.filter((function (t) {
                                        return !t.playing
                                    })).map((function (t) {
                                        return t.name
                                    })) : []
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "isPlaying", {
                                get: function () {
                                    return this.animator.isPlaying
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "isPaused", {
                                get: function () {
                                    return this.animator.isPaused
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "isStopped", {
                                get: function () {
                                    return this.animator.isStopped
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "bounds", {
                                get: function () {
                                    return this.artboard ? this.artboard.bounds : void 0
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.prototype.on = function (t, e) {
                                this.eventManager.add({
                                    type: t,
                                    callback: e
                                })
                            }, t.prototype.off = function (t, e) {
                                this.eventManager.remove({
                                    type: t,
                                    callback: e
                                })
                            }, t.prototype.unsubscribe = function (t, e) {
                                console.warn("This function is deprecated: please use `off()` instead."), this.off(t, e)
                            }, t.prototype.removeAllRiveEventListeners = function (t) {
                                this.eventManager.removeAll(t)
                            }, t.prototype.unsubscribeAll = function (t) {
                                console.warn("This function is deprecated: please use `removeAllRiveEventListeners()` instead."), this.removeAllRiveEventListeners(t)
                            }, t.prototype.stopRendering = function () {
                                this.loaded && this.frameRequestId && (this.runtime.cancelAnimationFrame ? this.runtime.cancelAnimationFrame(this.frameRequestId) : cancelAnimationFrame(this.frameRequestId), this.frameRequestId = null)
                            }, t.prototype.startRendering = function () {
                                this.loaded && this.artboard && !this.frameRequestId && (this.runtime.requestAnimationFrame ? this.frameRequestId = this.runtime.requestAnimationFrame(this.draw.bind(this)) : this.frameRequestId = requestAnimationFrame(this.draw.bind(this)))
                            }, t.prototype.enableFPSCounter = function (t) {
                                this.runtime.enableFPSCounter(t)
                            }, t.prototype.disableFPSCounter = function () {
                                this.runtime.disableFPSCounter()
                            }, Object.defineProperty(t.prototype, "contents", {
                                get: function () {
                                    if (this.loaded) {
                                        for (var t = {
                                            artboards: []
                                        }, e = 0; e < this.file.artboardCount(); e++) {
                                            for (var n = this.file.artboardByIndex(e), i = {
                                                name: n.name,
                                                animations: [],
                                                stateMachines: []
                                            }, r = 0; r < n.animationCount(); r++) {
                                                var s = n.animationByIndex(r);
                                                i.animations.push(s.name)
                                            }
                                            for (var o = 0; o < n.stateMachineCount(); o++) {
                                                for (var a = n.stateMachineByIndex(o), l = a.name, u = new this.runtime.StateMachineInstance(a, n), c = [], h = 0; h < u.inputCount(); h++) {
                                                    var d = u.input(h);
                                                    c.push({
                                                        name: d.name,
                                                        type: d.type
                                                    })
                                                }
                                                i.stateMachines.push({
                                                    name: l,
                                                    inputs: c
                                                })
                                            }
                                            t.artboards.push(i)
                                        }
                                        return t
                                    }
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t.missingErrorMessage = "Rive source file or data buffer required", t
                        }(),
                        w = function (t) {
                            return a(void 0, void 0, void 0, (function () {
                                var e;
                                return l(this, (function (n) {
                                    switch (n.label) {
                                        case 0:
                                            return e = new Request(t), [4, fetch(e)];
                                        case 1:
                                            return [4, n.sent().arrayBuffer()];
                                        case 2:
                                            return [2, n.sent()]
                                    }
                                }))
                            }))
                        },
                        M = function (t) {
                            return "string" == typeof t ? [t] : t instanceof Array ? t : []
                        },
                        S = {
                            EventManager: b,
                            TaskQueueManager: _
                        },
                        T = function (t) {
                            return new Promise((function (e) {
                                return h.getInstance((function (n) {
                                    n.decodeImage(t, e)
                                }))
                            }))
                        },
                        E = function (t) {
                            return new Promise((function (e) {
                                return h.getInstance((function (n) {
                                    n.decodeFont(t, e)
                                }))
                            }))
                        }
                })(), i
            })(), t.exports = e()
        },
        919: function (t, e) {
            var n, i, r, s;

            function o(t) {
                return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                    return typeof t
                } : function (t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                }, o(t)
            }
            s = function (t) {
                "use strict";
                var e = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

                function n(t) {
                    var e = t.nodeType,
                        i = "";
                    if (1 === e || 9 === e || 11 === e) {
                        if ("string" == typeof t.textContent) return t.textContent;
                        for (t = t.firstChild; t; t = t.nextSibling) i += n(t)
                    } else if (3 === e || 4 === e) return t.nodeValue;
                    return i
                }
                var i, r, s, a = /(?:\r|\n|\t\t)/g,
                    l = /(?:\s\s+)/g,
                    u = function (t) {
                        return r.getComputedStyle(t)
                    },
                    c = Array.isArray,
                    h = [].slice,
                    d = function (t, e) {
                        var n;
                        return c(t) ? t : "string" === (n = o(t)) && !e && t ? h.call(i.querySelectorAll(t), 0) : t && "object" === n && "length" in t ? h.call(t, 0) : t ? [t] : []
                    },
                    f = function (t) {
                        return "absolute" === t.position || !0 === t.absolute
                    },
                    p = function (t, e) {
                        for (var n, i = e.length; --i > -1;)
                            if (n = e[i], t.substr(0, n.length) === n) return n.length
                    },
                    m = function (t, e) {
                        void 0 === t && (t = "");
                        var n = ~t.indexOf("++"),
                            i = 1;
                        return n && (t = t.split("++").join("")),
                            function () {
                                return "<" + e + " style='position:relative;display:inline-block;'" + (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
                            }
                    },
                    g = function t(e, n, i) {
                        var r = e.nodeType;
                        if (1 === r || 9 === r || 11 === r)
                            for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i);
                        else 3 !== r && 4 !== r || (e.nodeValue = e.nodeValue.split(n).join(i))
                    },
                    v = function (t, e) {
                        for (var n = e.length; --n > -1;) t.push(e[n])
                    },
                    y = function (t, e, n) {
                        for (var i; t && t !== e;) {
                            if (i = t._next || t.nextSibling) return i.textContent.charAt(0) === n;
                            t = t.parentNode || t._parent
                        }
                    },
                    b = function t(e) {
                        var n, i, r = d(e.childNodes),
                            s = r.length;
                        for (n = 0; n < s; n++)(i = r[n])._isSplit ? t(i) : (n && 3 === i.previousSibling.nodeType ? i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue : 3 !== i.nodeType && e.insertBefore(i.firstChild, i), e.removeChild(i))
                    },
                    _ = function (t, e) {
                        return parseFloat(e[t]) || 0
                    },
                    x = function (t, e, n, r, s, o, a) {
                        var l, c, h, d, p, m, x, w, M, S, T, E, D = u(t),
                            C = _("paddingLeft", D),
                            A = -999,
                            P = _("borderBottomWidth", D) + _("borderTopWidth", D),
                            L = _("borderLeftWidth", D) + _("borderRightWidth", D),
                            R = _("paddingTop", D) + _("paddingBottom", D),
                            k = _("paddingLeft", D) + _("paddingRight", D),
                            O = .2 * _("fontSize", D),
                            I = D.textAlign,
                            F = [],
                            N = [],
                            z = [],
                            U = e.wordDelimiter || " ",
                            B = e.tag ? e.tag : e.span ? "span" : "div",
                            j = e.type || e.split || "chars,words,lines",
                            H = s && ~j.indexOf("lines") ? [] : null,
                            V = ~j.indexOf("words"),
                            G = ~j.indexOf("chars"),
                            W = f(e),
                            $ = e.linesClass,
                            X = ~($ || "").indexOf("++"),
                            q = [];
                        for (X && ($ = $.split("++").join("")), h = (c = t.getElementsByTagName("*")).length, p = [], l = 0; l < h; l++) p[l] = c[l];
                        if (H || W)
                            for (l = 0; l < h; l++)((m = (d = p[l]).parentNode === t) || W || G && !V) && (E = d.offsetTop, H && m && Math.abs(E - A) > O && ("BR" !== d.nodeName || 0 === l) && (x = [], H.push(x), A = E), W && (d._x = d.offsetLeft, d._y = E, d._w = d.offsetWidth, d._h = d.offsetHeight), H && ((d._isSplit && m || !G && m || V && m || !V && d.parentNode.parentNode === t && !d.parentNode._isSplit) && (x.push(d), d._x -= C, y(d, t, U) && (d._wordEnd = !0)), "BR" === d.nodeName && (d.nextSibling && "BR" === d.nextSibling.nodeName || 0 === l) && H.push([])));
                        for (l = 0; l < h; l++) m = (d = p[l]).parentNode === t, "BR" !== d.nodeName ? (W && (M = d.style, V || m || (d._x += d.parentNode._x, d._y += d.parentNode._y), M.left = d._x + "px", M.top = d._y + "px", M.position = "absolute", M.display = "block", M.width = d._w + 1 + "px", M.height = d._h + "px"), !V && G ? d._isSplit ? (d._next = d.nextSibling, d.parentNode.appendChild(d)) : d.parentNode._isSplit ? (d._parent = d.parentNode, !d.previousSibling && d.firstChild && (d.firstChild._isFirst = !0), d.nextSibling && " " === d.nextSibling.textContent && !d.nextSibling.nextSibling && q.push(d.nextSibling), d._next = d.nextSibling && d.nextSibling._isFirst ? null : d.nextSibling, d.parentNode.removeChild(d), p.splice(l--, 1), h--) : m || (E = !d.nextSibling && y(d.parentNode, t, U), d.parentNode._parent && d.parentNode._parent.appendChild(d), E && d.parentNode.appendChild(i.createTextNode(" ")), "span" === B && (d.style.display = "inline"), F.push(d)) : d.parentNode._isSplit && !d._isSplit && "" !== d.innerHTML ? N.push(d) : G && !d._isSplit && ("span" === B && (d.style.display = "inline"), F.push(d))) : H || W ? (d.parentNode && d.parentNode.removeChild(d), p.splice(l--, 1), h--) : V || t.appendChild(d);
                        for (l = q.length; --l > -1;) q[l].parentNode.removeChild(q[l]);
                        if (H) {
                            for (W && (S = i.createElement(B), t.appendChild(S), T = S.offsetWidth + "px", E = S.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(S)), M = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                            for (w = " " === U && (!W || !V && !G), l = 0; l < H.length; l++) {
                                for (x = H[l], (S = i.createElement(B)).style.cssText = "display:block;text-align:" + I + ";position:" + (W ? "absolute;" : "relative;"), $ && (S.className = $ + (X ? l + 1 : "")), z.push(S), h = x.length, c = 0; c < h; c++) "BR" !== x[c].nodeName && (d = x[c], S.appendChild(d), w && d._wordEnd && S.appendChild(i.createTextNode(" ")), W && (0 === c && (S.style.top = d._y + "px", S.style.left = C + E + "px"), d.style.top = "0px", E && (d.style.left = d._x - E + "px")));
                                0 === h ? S.innerHTML = "&nbsp;" : V || G || (b(S), g(S, String.fromCharCode(160), " ")), W && (S.style.width = T, S.style.height = d._h + "px"), t.appendChild(S)
                            }
                            t.style.cssText = M
                        }
                        W && (a > t.clientHeight && (t.style.height = a - R + "px", t.clientHeight < a && (t.style.height = a + P + "px")), o > t.clientWidth && (t.style.width = o - k + "px", t.clientWidth < o && (t.style.width = o + L + "px"))), v(n, F), V && v(r, N), v(s, z)
                    },
                    w = function (t, r, s, o) {
                        var u, c, h, d, m, v, y, b, _ = r.tag ? r.tag : r.span ? "span" : "div",
                            x = ~(r.type || r.split || "chars,words,lines").indexOf("chars"),
                            w = f(r),
                            M = r.wordDelimiter || " ",
                            S = " " !== M ? "" : w ? "&#173; " : " ",
                            T = "</" + _ + ">",
                            E = 1,
                            D = r.specialChars ? "function" == typeof r.specialChars ? r.specialChars : p : null,
                            C = i.createElement("div"),
                            A = t.parentNode;
                        for (A.insertBefore(C, t), C.textContent = t.nodeValue, A.removeChild(t), y = -1 !== (u = n(t = C)).indexOf("<"), !1 !== r.reduceWhiteSpace && (u = u.replace(l, " ").replace(a, "")), y && (u = u.split("<").join("{{LT}}")), m = u.length, c = (" " === u.charAt(0) ? S : "") + s(), h = 0; h < m; h++)
                            if (v = u.charAt(h), D && (b = D(u.substr(h), r.specialChars))) v = u.substr(h, b || 1), c += x && " " !== v ? o() + v + "</" + _ + ">" : v, h += b - 1;
                            else if (v === M && u.charAt(h - 1) !== M && h) {
                                for (c += E ? T : "", E = 0; u.charAt(h + 1) === M;) c += S, h++;
                                h === m - 1 ? c += S : ")" !== u.charAt(h + 1) && (c += S + s(), E = 1)
                            } else "{" === v && "{{LT}}" === u.substr(h, 6) ? (c += x ? o() + "{{LT}}</" + _ + ">" : "{{LT}}", h += 5) : v.charCodeAt(0) >= 55296 && v.charCodeAt(0) <= 56319 || u.charCodeAt(h + 1) >= 65024 && u.charCodeAt(h + 1) <= 65039 ? (d = ((u.substr(h, 12).split(e) || [])[1] || "").length || 2, c += x && " " !== v ? o() + u.substr(h, d) + "</" + _ + ">" : u.substr(h, d), h += d - 1) : c += x && " " !== v ? o() + v + "</" + _ + ">" : v;
                        t.outerHTML = c + (E ? T : ""), y && g(A, "{{LT}}", "<")
                    },
                    M = function t(e, n, i, r) {
                        var s, o, a = d(e.childNodes),
                            l = a.length,
                            c = f(n);
                        if (3 !== e.nodeType || l > 1) {
                            for (n.absolute = !1, s = 0; s < l; s++)(3 !== (o = a[s]).nodeType || /\S+/.test(o.nodeValue)) && (c && 3 !== o.nodeType && "inline" === u(o).display && (o.style.display = "inline-block", o.style.position = "relative"), o._isSplit = !0, t(o, n, i, r));
                            return n.absolute = c, void (e._isSplit = !0)
                        }
                        w(e, n, i, r)
                    },
                    S = function () {
                        function t(t, e) {
                            s || (i = document, r = window, s = 1), this.elements = d(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e)
                        }
                        var e = t.prototype;
                        return e.split = function (t) {
                            this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                            for (var e, n, i, r = this.elements.length, s = t.tag ? t.tag : t.span ? "span" : "div", o = m(t.wordsClass, s), a = m(t.charsClass, s); --r > -1;) i = this.elements[r], this._originals[r] = i.innerHTML, e = i.clientHeight, n = i.clientWidth, M(i, t, o, a), x(i, t, this.chars, this.words, this.lines, n, e);
                            return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                        }, e.revert = function () {
                            var t = this._originals;
                            if (!t) throw "revert() call wasn't scoped properly.";
                            return this.elements.forEach((function (e, n) {
                                return e.innerHTML = t[n]
                            })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                        }, t.create = function (e, n) {
                            return new t(e, n)
                        }, t
                    }();
                S.version = "3.0.0", t.SplitText = S, t.default = S, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }, "object" === o(e) ? s(e) : (i = [e], void 0 === (r = "function" == typeof (n = s) ? n.apply(e, i) : n) || (t.exports = r))
        },
        440: t => {
            t.exports = function (t, e, n) {
                return t * (1 - n) + e * n
            }
        },
        199: t => {
            t.exports = function (t, e) {
                e = e || 2;
                for (var n = 2 * (t = t || 1) + 1, i = Math.pow(n, e) - 1, r = new Array(i), s = 0; s < i; s++)
                    for (var o = r[s] = new Array(e), a = s < i / 2 ? s : s + 1, l = 1; l <= e; l++) {
                        var u = a % Math.pow(n, l);
                        o[l - 1] = u / Math.pow(n, l - 1) - t, a -= u
                    }
                return r
            }
        },
        630: (t, e, n) => {
            "use strict";
            var i = n(461).integer,
                r = n(650),
                s = n(264);

            function o(t, e) {
                for (var n = 0, i = 0; i < t.length; i++) n += Math.pow(t[i] - e[i], 2);
                return n
            }

            function a(t, e) {
                if ("function" == typeof t.distanceFunction) throw new Error("PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction");
                this.shape = t.shape, this.minDistance = t.minDistance, this.maxDistance = t.maxDistance || 2 * t.minDistance, this.maxTries = Math.ceil(Math.max(1, t.tries || 30)), this.rng = e || Math.random;
                for (var n = 0, r = 0; r < this.shape.length; r++) n = Math.max(n, this.shape[r]);
                var o = 1e-14 * Math.max(1, n / 128 | 0);
                for (this.dimension = this.shape.length, this.squaredMinDistance = this.minDistance * this.minDistance, this.minDistancePlusEpsilon = this.minDistance + o, this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon), this.cellSize = this.minDistance / Math.sqrt(this.dimension), this.neighbourhood = s(this.dimension), this.currentPoint = null, this.processList = [], this.samplePoints = [], this.gridShape = [], r = 0; r < this.dimension; r++) this.gridShape.push(Math.ceil(this.shape[r] / this.cellSize));
                this.grid = i(this.gridShape)
            }
            a.prototype.shape = null, a.prototype.dimension = null, a.prototype.minDistance = null, a.prototype.maxDistance = null, a.prototype.minDistancePlusEpsilon = null, a.prototype.squaredMinDistance = null, a.prototype.deltaDistance = null, a.prototype.cellSize = null, a.prototype.maxTries = null, a.prototype.rng = null, a.prototype.neighbourhood = null, a.prototype.currentPoint = null, a.prototype.processList = null, a.prototype.samplePoints = null, a.prototype.gridShape = null, a.prototype.grid = null, a.prototype.addRandomPoint = function () {
                for (var t = new Array(this.dimension), e = 0; e < this.dimension; e++) t[e] = this.rng() * this.shape[e];
                return this.directAddPoint(t)
            }, a.prototype.addPoint = function (t) {
                var e, n = !0;
                if (t.length === this.dimension)
                    for (e = 0; e < this.dimension && n; e++) n = t[e] >= 0 && t[e] < this.shape[e];
                else n = !1;
                return n ? this.directAddPoint(t) : null
            }, a.prototype.directAddPoint = function (t) {
                var e, n = 0,
                    i = this.grid.stride;
                for (this.processList.push(t), this.samplePoints.push(t), e = 0; e < this.dimension; e++) n += (t[e] / this.cellSize | 0) * i[e];
                return this.grid.data[n] = this.samplePoints.length, t
            }, a.prototype.inNeighbourhood = function (t) {
                var e, n, i, r, s = this.dimension,
                    a = this.grid.stride;
                for (e = 0; e < this.neighbourhood.length; e++) {
                    for (n = 0, i = 0; i < s; i++) {
                        if ((r = (t[i] / this.cellSize | 0) + this.neighbourhood[e][i]) < 0 || r >= this.gridShape[i]) {
                            n = -1;
                            break
                        }
                        n += r * a[i]
                    }
                    if (-1 !== n && 0 !== this.grid.data[n] && o(t, this.samplePoints[this.grid.data[n] - 1]) < this.squaredMinDistance) return !0
                }
                return !1
            }, a.prototype.next = function () {
                for (var t, e, n, i, s, o, a; this.processList.length > 0;) {
                    for (null === this.currentPoint && (this.currentPoint = this.processList.shift()), i = this.currentPoint, t = 0; t < this.maxTries; t++) {
                        for (o = !0, n = this.minDistancePlusEpsilon + this.deltaDistance * this.rng(), 2 === this.dimension ? (e = this.rng() * Math.PI * 2, s = [Math.cos(e), Math.sin(e)]) : s = r(this.dimension, this.rng), a = 0; o && a < this.dimension; a++) s[a] = i[a] + s[a] * n, o = s[a] >= 0 && s[a] < this.shape[a];
                        if (o && !this.inNeighbourhood(s)) return this.directAddPoint(s)
                    }
                    t === this.maxTries && (this.currentPoint = null)
                }
                return null
            }, a.prototype.fill = function () {
                for (0 === this.samplePoints.length && this.addRandomPoint(); this.next(););
                return this.samplePoints
            }, a.prototype.getAllPoints = function () {
                return this.samplePoints
            }, a.prototype.getAllPointsWithDistance = function () {
                throw new Error("PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation")
            }, a.prototype.reset = function () {
                var t = this.grid.data,
                    e = 0;
                for (e = 0; e < t.length; e++) t[e] = 0;
                this.samplePoints = [], this.currentPoint = null, this.processList.length = 0
            }, t.exports = a
        },
        124: (t, e, n) => {
            "use strict";
            var i = n(461).array,
                r = n(650),
                s = n(264);

            function o(t, e) {
                for (var n = 0, i = 0; i < t.length; i++) n += Math.pow(t[i] - e[i], 2);
                return Math.sqrt(n)
            }

            function a(t, e) {
                if ("function" != typeof t.distanceFunction) throw new Error("PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction");
                this.shape = t.shape, this.minDistance = t.minDistance, this.maxDistance = t.maxDistance || 2 * t.minDistance, this.maxTries = Math.ceil(Math.max(1, t.tries || 30)), this.distanceFunction = t.distanceFunction, this.bias = Math.max(0, Math.min(1, t.bias || 0)), this.rng = e || Math.random;
                for (var n = 0, r = 0; r < this.shape.length; r++) n = Math.max(n, this.shape[r]);
                var o = 1e-14 * Math.max(1, n / 128 | 0);
                for (this.dimension = this.shape.length, this.minDistancePlusEpsilon = this.minDistance + o, this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon), this.cellSize = this.maxDistance / Math.sqrt(this.dimension), this.neighbourhood = s(this.dimension), this.currentPoint = null, this.currentDistance = 0, this.processList = [], this.samplePoints = [], this.sampleDistance = [], this.gridShape = [], r = 0; r < this.dimension; r++) this.gridShape.push(Math.ceil(this.shape[r] / this.cellSize));
                this.grid = i(this.gridShape)
            }
            a.prototype.shape = null, a.prototype.dimension = null, a.prototype.minDistance = null, a.prototype.maxDistance = null, a.prototype.minDistancePlusEpsilon = null, a.prototype.deltaDistance = null, a.prototype.cellSize = null, a.prototype.maxTries = null, a.prototype.distanceFunction = null, a.prototype.bias = null, a.prototype.rng = null, a.prototype.neighbourhood = null, a.prototype.currentPoint = null, a.prototype.currentDistance = null, a.prototype.processList = null, a.prototype.samplePoints = null, a.prototype.sampleDistance = null, a.prototype.gridShape = null, a.prototype.grid = null, a.prototype.addRandomPoint = function () {
                for (var t = new Array(this.dimension), e = 0; e < this.dimension; e++) t[e] = this.rng() * this.shape[e];
                return this.directAddPoint(t)
            }, a.prototype.addPoint = function (t) {
                var e, n = !0;
                if (t.length === this.dimension)
                    for (e = 0; e < this.dimension && n; e++) n = t[e] >= 0 && t[e] < this.shape[e];
                else n = !1;
                return n ? this.directAddPoint(t) : null
            }, a.prototype.directAddPoint = function (t) {
                var e, n = 0,
                    i = this.grid.stride,
                    r = this.samplePoints.length;
                for (this.processList.push(r), this.samplePoints.push(t), this.sampleDistance.push(this.distanceFunction(t)), e = 0; e < this.dimension; e++) n += (t[e] / this.cellSize | 0) * i[e];
                return this.grid.data[n].push(r), t
            }, a.prototype.inNeighbourhood = function (t) {
                var e, n, i, r, s, a, l = this.dimension,
                    u = this.grid.stride,
                    c = this.distanceFunction(t);
                for (e = 0; e < this.neighbourhood.length; e++) {
                    for (n = 0, i = 0; i < l; i++) {
                        if ((r = (t[i] / this.cellSize | 0) + this.neighbourhood[e][i]) < 0 || r >= this.gridShape[i]) {
                            n = -1;
                            break
                        }
                        n += r * u[i]
                    }
                    if (-1 !== n && this.grid.data[n].length > 0)
                        for (var h = 0; h < this.grid.data[n].length; h++) {
                            s = this.samplePoints[this.grid.data[n][h]], a = this.sampleDistance[this.grid.data[n][h]];
                            var d = Math.min(a, c),
                                f = d + (Math.max(a, c) - d) * this.bias;
                            if (o(t, s) < this.minDistance + this.deltaDistance * f) return !0
                        }
                }
                return !1
            }, a.prototype.next = function () {
                for (var t, e, n, i, s, o, a, l; this.processList.length > 0;) {
                    if (null === this.currentPoint) {
                        var u = this.processList.shift();
                        this.currentPoint = this.samplePoints[u], this.currentDistance = this.sampleDistance[u]
                    }
                    for (i = this.currentPoint, s = this.currentDistance, t = 0; t < this.maxTries; t++) {
                        for (a = !0, n = this.minDistancePlusEpsilon + this.deltaDistance * (s + (1 - s) * this.bias), 2 === this.dimension ? (e = this.rng() * Math.PI * 2, o = [Math.cos(e), Math.sin(e)]) : o = r(this.dimension, this.rng), l = 0; a && l < this.dimension; l++) o[l] = i[l] + o[l] * n, a = o[l] >= 0 && o[l] < this.shape[l];
                        if (a && !this.inNeighbourhood(o)) return this.directAddPoint(o)
                    }
                    t === this.maxTries && (this.currentPoint = null)
                }
                return null
            }, a.prototype.fill = function () {
                for (0 === this.samplePoints.length && this.addRandomPoint(); this.next(););
                return this.samplePoints
            }, a.prototype.getAllPoints = function () {
                return this.samplePoints
            }, a.prototype.getAllPointsWithDistance = function () {
                var t, e = new Array(this.samplePoints.length),
                    n = 0,
                    i = 0;
                for (n = 0; n < this.samplePoints.length; n++) {
                    for (t = new Array(this.dimension + 1), i = 0; i < this.dimension; i++) t[i] = this.samplePoints[n][i];
                    t[this.dimension] = this.sampleDistance[n], e[n] = t
                }
                return e
            }, a.prototype.reset = function () {
                var t = this.grid.data,
                    e = 0;
                for (e = 0; e < t.length; e++) t[e] = [];
                this.samplePoints = [], this.currentPoint = null, this.processList.length = 0
            }, t.exports = a
        },
        264: (t, e, n) => {
            "use strict";
            var i = n(199),
                r = {};
            t.exports = function (t) {
                return r[t] || (r[t] = function (t) {
                    var e, n = i(2, t),
                        r = [];
                    for (n = n.filter((function (e) {
                        for (var n = 0, i = 0; i < t; i++) n += Math.pow(Math.max(0, Math.abs(e[i]) - 1), 2);
                        return n < t
                    })), e = 0; e < t; e++) r.push(0);
                    return n.push(r), n.sort((function (e, n) {
                        var i, r = 0,
                            s = 0;
                        for (i = 0; i < t; i++) r += Math.pow(e[i], 2), s += Math.pow(n[i], 2);
                        return r < s ? -1 : r > s ? 1 : 0
                    })), n
                }(t)), r[t]
            }
        },
        966: (t, e, n) => {
            "use strict";
            var i = n(630),
                r = n(124);

            function s(t, e) {
                this.shape = t.shape, "function" == typeof t.distanceFunction ? this.implementation = new r(t, e) : this.implementation = new i(t, e)
            }
            s.prototype.implementation = null, s.prototype.addRandomPoint = function () {
                return this.implementation.addRandomPoint()
            }, s.prototype.addPoint = function (t) {
                return this.implementation.addPoint(t)
            }, s.prototype.next = function () {
                return this.implementation.next()
            }, s.prototype.fill = function () {
                return this.implementation.fill()
            }, s.prototype.getAllPoints = function () {
                return this.implementation.getAllPoints()
            }, s.prototype.getAllPointsWithDistance = function () {
                return this.implementation.getAllPointsWithDistance()
            }, s.prototype.reset = function () {
                this.implementation.reset()
            }, t.exports = s
        },
        650: t => {
            "use strict";
            t.exports = function (t, e) {
                var n, i, r, s, o, a = new Array(t),
                    l = Math.floor(t / 2) << 1,
                    u = 0;
                for (o = 0; o < l; o += 2) n = -2 * Math.log(e()), i = Math.sqrt(n), r = 2 * Math.PI * e(), u += n, a[o] = i * Math.cos(r), a[o + 1] = i * Math.sin(r);
                if (t % 2) {
                    var c = Math.sqrt(-2 * Math.log(e())) * Math.cos(2 * Math.PI * e());
                    a[t - 1] = c, u += Math.pow(c, 2)
                }
                for (s = 1 / Math.sqrt(u), o = 0; o < t; ++o) a[o] *= s;
                return a
            }
        },
        461: t => {
            "use strict";
            t.exports = {
                integer: function (t) {
                    var e, n = t.length,
                        i = 1,
                        r = new Array(n);
                    for (e = n; e > 0; e--) r[e - 1] = i, i *= t[e - 1];
                    return {
                        stride: r,
                        data: new Uint32Array(i)
                    }
                },
                array: function (t) {
                    var e, n, i = t.length,
                        r = 1,
                        s = new Array(i),
                        o = [];
                    for (e = i; e > 0; e--) s[e - 1] = r, r *= t[e - 1];
                    for (n = 0; n < r; n++) o.push([]);
                    return {
                        stride: s,
                        data: o
                    }
                }
            }
        }
    },
        e = {};

    function n(i) {
        var r = e[i];
        if (void 0 !== r) return r.exports;
        var s = e[i] = {
            exports: {}
        };
        return t[i].call(s.exports, s, s.exports, n), s.exports
    }
    n.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, {
            a: e
        }), e
    }, n.d = (t, e) => {
        for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
            enumerable: !0,
            get: e[i]
        })
    }, n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.r = t => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    };
    var i = {};
    (() => {
        "use strict";
        // n.d(i, {
        //     H: () => BC
        // });
        var t = {};

        function e() { }
        // n.r(t), n.d(t, {
        //     Book: () => WT,
        //     CaseShuffle: () => om,
        //     ClickReviews: () => Od,
        //     ClientFilteredList: () => Td,
        //     Compare: () => sD,
        //     CtaMask: () => Qp,
        //     CustomBlogEmbed: () => Ch,
        //     DraggableBase: () => Mh,
        //     DraggableInfinite: () => Zf,
        //     ExploreGrid: () => iE,
        //     FilterCase: () => fm,
        //     FilteredList: () => fd,
        //     FilteredWorks: () => od,
        //     Footer: () => _p,
        //     GravityForm: () => zh,
        //     GravityFormTabs: () => Vh,
        //     Head: () => tf,
        //     HeroAudio: () => Gp,
        //     HomeHero: () => pp,
        //     HoverCategory: () => ZE,
        //     HoverState: () => dD,
        //     InfiniteMenu: () => cf,
        //     Intro: () => Np,
        //     Lazy: () => gE,
        //     LazyVids: () => xE,
        //     MenuDD: () => Of,
        //     MobileMenu: () => Ap,
        //     NextScroll: () => Wd,
        //     OrbMethods: () => op,
        //     OrbMobile: () => NE,
        //     Pin: () => RE,
        //     PopUpEarlyAccess: () => _f,
        //     PortfolioFlip: () => xD,
        //     ScrollAnchor: () => Ef,
        //     SlidingTabs: () => Vf,
        //     StickySection: () => $E,
        //     Tabs: () => td,
        //     TrainingButtonsSections: () => yd,
        //     Transcript: () => EE,
        //     WorksList: () => dE,
        //     dropdown: () => sh,
        //     marquee: () => ch,
        //     mediaPlayer: () => Wh,
        //     mouseFollow: () => fh,
        //     triggered: () => ih
        // }), 
        e.prototype = {
            on: function (t, e, n) {
                var i = this.e || (this.e = {});
                return (i[t] || (i[t] = [])).push({
                    fn: e,
                    ctx: n
                }), this
            },
            once: function (t, e, n) {
                var i = this;

                function r() {
                    i.off(t, r), e.apply(n, arguments)
                }
                return r._ = e, this.on(t, r, n)
            },
            emit: function (t) {
                for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
                return this
            },
            off: function (t, e) {
                var n = this.e || (this.e = {}),
                    i = n[t],
                    r = [];
                if (i && e)
                    for (var s = 0, o = i.length; s < o; s++) i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]);
                return r.length ? n[t] = r : delete n[t], this
            }
        };
        var r = e;
        r.TinyEmitter = e;
        var s = function (t) {
            this.wrap = document.querySelector("[data-router-wrapper]"), this.properties = t, this.Transition = t.transition ? new t.transition.class(this.wrap, t.transition.name) : null
        };
        // s.prototype.setup = function () {
        //     this.onEnter && this.onEnter(), this.onEnterCompleted && this.onEnterCompleted()
        // }, s.prototype.add = function () {
        //     this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML)
        // }, s.prototype.update = function () {
        //     document.title = this.properties.page.title
        // }, s.prototype.show = function (t) {
        //     var e = this;
        //     return new Promise((function (n) {
        //         try {
        //             function i(t) {
        //                 e.onEnterCompleted && e.onEnterCompleted(), n()
        //             }
        //             return e.update(), e.onEnter && e.onEnter(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.show(t)).then(i) : i())
        //         } catch (r) {
        //             return Promise.reject(r)
        //         }
        //     }))
        // }, s.prototype.hide = function (t) {
            var e = this;
            return new Promise((function (n) {
                try {
                    function i(t) {
                        e.onLeaveCompleted && e.onLeaveCompleted(), n()
                    }
                    return e.onLeave && e.onLeave(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.hide(t)).then(i) : i())
                } catch (r) {
                    return Promise.reject(r)
                }
            }))
        };
        var o = new window.DOMParser,
            a = function (t, e) {
                this.renderers = t, this.transitions = e
            };
        a.prototype.getOrigin = function (t) {
            var e = t.match(/(https?:\/\/[\w\-.]+)/);
            return e ? e[1].replace(/https?:\/\//, "") : null
        }, a.prototype.getPathname = function (t) {
            var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
            return e ? e[1] : "/"
        }, a.prototype.getAnchor = function (t) {
            var e = t.match(/(#.*)$/);
            return e ? e[1] : null
        }, a.prototype.getParams = function (t) {
            var e = t.match(/\?([\w_\-.=&]+)/);
            if (!e) return null;
            for (var n = e[1].split("&"), i = {}, r = 0; r < n.length; r++) {
                var s = n[r].split("=");
                i[s[0]] = s[1]
            }
            return i
        }, a.prototype.getDOM = function (t) {
            return "string" == typeof t ? o.parseFromString(t, "text/html") : t
        }, a.prototype.getView = function (t) {
            return t.querySelector("[data-router-view]")
        }, a.prototype.getSlug = function (t) {
            return t.getAttribute("data-router-view")
        }, a.prototype.getRenderer = function (t) {
            if (!this.renderers) return Promise.resolve(s);
            if (t in this.renderers) {
                var e = this.renderers[t];
                return "function" != typeof e || s.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then((function (t) {
                    return t.default
                })) : Promise.resolve(e) : Promise.resolve(e()).then((function (t) {
                    return t.default
                }))
            }
            return Promise.resolve(s)
        }, a.prototype.getTransition = function (t) {
            return this.transitions ? t in this.transitions ? {
                class: this.transitions[t],
                name: t
            } : "default" in this.transitions ? {
                class: this.transitions.default,
                name: "default"
            } : null : null
        }, a.prototype.getProperties = function (t) {
            var e = this.getDOM(t),
                n = this.getView(e),
                i = this.getSlug(n);
            return {
                page: e,
                view: n,
                slug: i,
                renderer: this.getRenderer(i, this.renderers),
                transition: this.getTransition(i, this.transitions)
            }
        }, a.prototype.getLocation = function (t) {
            return {
                href: t,
                anchor: this.getAnchor(t),
                origin: this.getOrigin(t),
                params: this.getParams(t),
                pathname: this.getPathname(t)
            }
        };
        var l = function (t) {
            function e(e) {
                var n = this;
                void 0 === e && (e = {});
                var i = e.renderers,
                    r = e.transitions;
                t.call(this), this.Helpers = new a(i, r), this.Transitions = r, this.Contextual = !1, this.location = this.Helpers.getLocation(window.location.href), this.properties = this.Helpers.getProperties(document.cloneNode(!0)), this.popping = !1, this.running = !1, this.trigger = null, this.cache = new Map, this.cache.set(this.location.href, this.properties), this.properties.renderer.then((function (t) {
                    n.From = new t(n.properties), n.From.setup()
                })), this._navigate = this.navigate.bind(this), window.addEventListener("popstate", this.popState.bind(this)), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links)
            }
            return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.attach = function (t) {
                for (var e = 0, n = t; e < n.length; e += 1) n[e].addEventListener("click", this._navigate)
            }, e.prototype.detach = function (t) {
                for (var e = 0, n = t; e < n.length; e += 1) n[e].removeEventListener("click", this._navigate)
            }, e.prototype.navigate = function (t) {
                if (!t.metaKey && !t.ctrlKey) {
                    t.preventDefault();
                    var e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition;
                    this.redirect(t.currentTarget.href, e, t.currentTarget)
                }
            }, e.prototype.redirect = function (t, e, n) {
                if (void 0 === e && (e = !1), void 0 === n && (n = "script"), this.trigger = n, !this.running && t !== this.location.href) {
                    var i = this.Helpers.getLocation(t);
                    this.Contextual = !1, e && (this.Contextual = this.Transitions.contextual[e].prototype, this.Contextual.name = e), i.origin !== this.location.origin || i.anchor && i.pathname === this.location.pathname ? window.location.href = t : (this.location = i, this.beforeFetch())
                }
                // }, e.prototype.popState = function () {
                //     this.trigger = "popstate", this.Contextual = !1;
                //     var t = this.Helpers.getLocation(window.location.href);
                //     this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0, this.location = t, this.beforeFetch()) : this.location = t
                // }, e.prototype.pushState = function () {
                //     this.popping || window.history.pushState(this.location, "", this.location.href)
                // }, e.prototype.fetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(fetch(t.location.href, {
                        mode: "same-origin",
                        method: "GET",
                        headers: {
                            "X-Requested-With": "Highway"
                        },
                        credentials: "same-origin"
                    })).then((function (e) {
                        if (e.status >= 200 && e.status < 300) return e.text();
                        window.location.href = t.location.href
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.beforeFetch = function () {
                try {
                    var t = this;

                    function i() {
                        t.afterFetch()
                    }
                    // t.pushState(), t.running = !0, t.emit("NAVIGATE_OUT", {
                    //     from: {
                    //         page: t.From.properties.page,
                    //         view: t.From.properties.view
                    //     },
                    //     trigger: t.trigger,
                    //     location: t.location
                    // });
                    var e = {
                        trigger: t.trigger,
                        contextual: t.Contextual
                    },
                        n = t.cache.has(t.location.href) ? Promise.resolve(t.From.hide(e)).then((function () {
                            t.properties = t.cache.get(t.location.href)
                        })) : Promise.resolve(Promise.all([t.fetch(), t.From.hide(e)])).then((function (e) {
                            t.properties = t.Helpers.getProperties(e[0]), t.cache.set(t.location.href, t.properties)
                        }));
                    return Promise.resolve(n && n.then ? n.then(i) : i())
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.afterFetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(t.properties.renderer).then((function (e) {
                        return t.To = new e(t.properties), t.To.add(), t.emit("NAVIGATE_IN", {
                            to: {
                                page: t.To.properties.page,
                                view: t.To.wrap.lastElementChild
                            },
                            trigger: t.trigger,
                            location: t.location
                        }), Promise.resolve(t.To.show({
                            trigger: t.trigger,
                            contextual: t.Contextual
                        })).then((function () {
                            t.popping = !1, t.running = !1, t.detach(t.links), t.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), t.attach(t.links), t.emit("NAVIGATE_END", {
                                to: {
                                    page: t.To.properties.page,
                                    view: t.To.wrap.lastElementChild
                                },
                                from: {
                                    page: t.From.properties.page,
                                    view: t.From.properties.view
                                },
                                trigger: t.trigger,
                                location: t.location
                            }), t.From = t.To, t.trigger = null
                        }))
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e
        }(r),
            u = function (t, e) {
                this.wrap = t, this.name = e
            };
        u.prototype.show = function (t) {
            var e = this,
                n = t.trigger,
                i = t.contextual,
                r = this.wrap.lastElementChild,
                s = this.wrap.firstElementChild;
            return new Promise((function (t) {
                i ? (r.setAttribute("data-transition-in", i.name), r.removeAttribute("data-transition-out", i.name), i.in && i.in({
                    to: r,
                    from: s,
                    trigger: n,
                    done: t
                })) : (r.setAttribute("data-transition-in", e.name), r.removeAttribute("data-transition-out", e.name), e.in && e.in({
                    to: r,
                    from: s,
                    trigger: n,
                    done: t
                }))
            }))
        }, u.prototype.hide = function (t) {
            var e = this,
                n = t.trigger,
                i = t.contextual,
                r = this.wrap.firstElementChild;
            return new Promise((function (t) {
                i ? (r.setAttribute("data-transition-out", i.name), r.removeAttribute("data-transition-in", i.name), i.out && i.out({
                    from: r,
                    trigger: n,
                    done: t
                })) : (r.setAttribute("data-transition-out", e.name), r.removeAttribute("data-transition-in", e.name), e.out && e.out({
                    from: r,
                    trigger: n,
                    done: t
                }))
            }))
        }, console.log("Highway v2.2.0");
        const c = {
            Core: l,
            Helpers: a,
            Renderer: s,
            Transition: u
        };

        function h(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function d(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        var f, p, m, g, v, y, b, _, x, w, M, S = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
            T = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            E = 1e8,
            D = 1e-8,
            C = 2 * Math.PI,
            A = C / 4,
            P = 0,
            L = Math.sqrt,
            R = Math.cos,
            k = Math.sin,
            O = function (t) {
                return "string" == typeof t
            },
            I = function (t) {
                return "function" == typeof t
            },
            F = function (t) {
                return "number" == typeof t
            },
            N = function (t) {
                return void 0 === t
            },
            z = function (t) {
                return "object" == typeof t
            },
            U = function (t) {
                return !1 !== t
            },
            B = function () {
                return "undefined" != typeof window
            },
            j = function (t) {
                return I(t) || O(t)
            },
            H = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { },
            V = Array.isArray,
            G = /(?:-?\.?\d|\.)+/gi,
            W = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            $ = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            X = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
            q = /[+-]=-?[.\d]+/,
            Y = /[^,'"\[\]\s]+/gi,
            K = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
            J = {},
            Z = {},
            Q = function (t) {
                return (Z = Ct(t, J)) && An
            },
            tt = function (t, e) {
                return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
            },
            et = function (t, e) {
                return !e && console.warn(t)
            },
            nt = function (t, e) {
                return t && (J[t] = e) && Z && (Z[t] = e) || J
            },
            it = function () {
                return 0
            },
            rt = {
                suppressEvents: !0,
                isStart: !0,
                kill: !1
            },
            st = {
                suppressEvents: !0,
                kill: !1
            },
            ot = {
                suppressEvents: !0
            },
            at = {},
            lt = [],
            ut = {},
            ct = {},
            ht = {},
            dt = 30,
            ft = [],
            pt = "",
            mt = function (t) {
                var e, n, i = t[0];
                if (z(i) || I(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                    for (n = ft.length; n-- && !ft[n].targetTest(i););
                    e = ft[n]
                }
                for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new He(t[n], e))) || t.splice(n, 1);
                return t
            },
            gt = function (t) {
                return t._gsap || mt(se(t))[0]._gsap
            },
            vt = function (t, e, n) {
                return (n = t[e]) && I(n) ? t[e]() : N(n) && t.getAttribute && t.getAttribute(e) || n
            },
            yt = function (t, e) {
                return (t = t.split(",")).forEach(e) || t
            },
            bt = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            _t = function (t) {
                return Math.round(1e7 * t) / 1e7 || 0
            },
            xt = function (t, e) {
                var n = e.charAt(0),
                    i = parseFloat(e.substr(2));
                return t = parseFloat(t), "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
            },
            wt = function (t, e) {
                for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                return i < n
            },
            Mt = function () {
                var t, e, n = lt.length,
                    i = lt.slice(0);
                for (ut = {}, lt.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            },
            St = function (t, e, n, i) {
                lt.length && !p && Mt(), t.render(e, n, i || p && e < 0 && (t._initted || t._startAt)), lt.length && !p && Mt()
            },
            Tt = function (t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(Y).length < 2 ? e : O(t) ? t.trim() : t
            },
            Et = function (t) {
                return t
            },
            Dt = function (t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            Ct = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            At = function t(e, n) {
                for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = z(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
                return e
            },
            Pt = function (t, e) {
                var n, i = {};
                for (n in t) n in e || (i[n] = t[n]);
                return i
            },
            Lt = function (t) {
                var e, n = t.parent || g,
                    i = t.keyframes ? (e = V(t.keyframes), function (t, n) {
                        for (var i in n) i in t || "duration" === i && e || "ease" === i || (t[i] = n[i])
                    }) : Dt;
                if (U(t.inherit))
                    for (; n;) i(t, n.vars.defaults), n = n.parent || n._dp;
                return t
            },
            Rt = function (t, e, n, i, r) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var s, o = t[i];
                if (r)
                    for (s = e[r]; o && o[r] > s;) o = o._prev;
                return o ? (e._next = o._next, o._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = o, e.parent = e._dp = t, e
            },
            kt = function (t, e, n, i) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var r = e._prev,
                    s = e._next;
                r ? r._next = s : t[n] === e && (t[n] = s), s ? s._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
            },
            Ot = function (t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0
            },
            It = function (t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var n = t; n;) n._dirty = 1, n = n.parent;
                return t
            },
            Ft = function (t, e, n, i) {
                return t._startAt && (p ? t._startAt.revert(st) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, i))
            },
            Nt = function t(e) {
                return !e || e._ts && t(e.parent)
            },
            zt = function (t) {
                return t._repeat ? Ut(t._tTime, t = t.duration() + t._rDelay) * t : 0
            },
            Ut = function (t, e) {
                var n = Math.floor(t /= e);
                return t && n === t ? n - 1 : n
            },
            Bt = function (t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            },
            jt = function (t) {
                return t._end = _t(t._start + (t._tDur / Math.abs(t._ts || t._rts || D) || 0))
            },
            Ht = function (t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = _t(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), jt(t), n._dirty || It(n, t)), t
            },
            Vt = function (t, e) {
                var n;
                if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (n = Bt(t.rawTime(), e), (!e._dur || ee(0, e.totalDuration(), n) - e._tTime > D) && e.render(n, !0)), It(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            },
            Gt = function (t, e, n, i) {
                return e.parent && Ot(e), e._start = _t((F(n) ? n : n || t !== g ? Zt(t, n, e) : t._time) + e._delay), e._end = _t(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Rt(t, e, "_first", "_last", t._sort ? "_start" : 0), qt(e) || (t._recent = e), i || Vt(t, e), t._ts < 0 && Ht(t, t._tTime), t
            },
            Wt = function (t, e) {
                return (J.ScrollTrigger || tt("scrollTrigger", e)) && J.ScrollTrigger.create(e, t)
            },
            $t = function (t, e, n, i, r) {
                return Ke(t, e, r), t._initted ? !n && t._pt && !p && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && x !== Ae.frame ? (lt.push(t), t._lazy = [r, i], 1) : void 0 : 1
            },
            Xt = function t(e) {
                var n = e.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
            },
            qt = function (t) {
                var e = t.data;
                return "isFromStart" === e || "isStart" === e
            },
            Yt = function (t, e, n, i) {
                var r = t._repeat,
                    s = _t(e) || 0,
                    o = t._tTime / t._tDur;
                return o && !i && (t._time *= s / t._dur), t._dur = s, t._tDur = r ? r < 0 ? 1e10 : _t(s * (r + 1) + t._rDelay * r) : s, o > 0 && !i && Ht(t, t._tTime = t._tDur * o), t.parent && jt(t), n || It(t.parent, t), t
            },
            Kt = function (t) {
                return t instanceof Ge ? It(t) : Yt(t, t._dur)
            },
            Jt = {
                _start: 0,
                endTime: it,
                totalDuration: it
            },
            Zt = function t(e, n, i) {
                var r, s, o, a = e.labels,
                    l = e._recent || Jt,
                    u = e.duration() >= E ? l.endTime(!1) : e._dur;
                return O(n) && (isNaN(n) || n in a) ? (s = n.charAt(0), o = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = u), a[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), o && i && (s = s / 100 * (V(i) ? i[0] : i).totalDuration()), r > 1 ? t(e, n.substr(0, r - 1), i) + s : u + s)) : null == n ? u : +n
            },
            Qt = function (t, e, n) {
                var i, r, s = F(e[1]),
                    o = (s ? 2 : 1) + (t < 2 ? 0 : 1),
                    a = e[o];
                if (s && (a.duration = e[1]), a.parent = n, t) {
                    for (i = a, r = n; r && !("immediateRender" in i);) i = r.vars.defaults || {}, r = U(r.vars.inherit) && r.parent;
                    a.immediateRender = U(i.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1]
                }
                return new en(e[0], a, e[o + 1])
            },
            te = function (t, e) {
                return t || 0 === t ? e(t) : e
            },
            ee = function (t, e, n) {
                return n < t ? t : n > e ? e : n
            },
            ne = function (t, e) {
                return O(t) && (e = K.exec(t)) ? e[1] : ""
            },
            ie = [].slice,
            re = function (t, e) {
                return t && z(t) && "length" in t && (!e && !t.length || t.length - 1 in t && z(t[0])) && !t.nodeType && t !== v
            },
            se = function (t, e, n) {
                return m && !e && m.selector ? m.selector(t) : !O(t) || n || !y && Pe() ? V(t) ? function (t, e, n) {
                    return void 0 === n && (n = []), t.forEach((function (t) {
                        var i;
                        return O(t) && !e || re(t, 1) ? (i = n).push.apply(i, se(t)) : n.push(t)
                    })) || n
                }(t, n) : re(t) ? ie.call(t, 0) : t ? [t] : [] : ie.call((e || b).querySelectorAll(t), 0)
            },
            oe = function (t) {
                return t = se(t)[0] || et("Invalid scope") || {},
                    function (e) {
                        var n = t.current || t.nativeElement || t;
                        return se(e, n.querySelectorAll ? n : n === t ? et("Invalid scope") || b.createElement("div") : t)
                    }
            },
            ae = function (t) {
                return t.sort((function () {
                    return .5 - Math.random()
                }))
            },
            le = function (t) {
                if (I(t)) return t;
                var e = z(t) ? t : {
                    each: t
                },
                    n = Ne(e.ease),
                    i = e.from || 0,
                    r = parseFloat(e.base) || 0,
                    s = {},
                    o = i > 0 && i < 1,
                    a = isNaN(i) || o,
                    l = e.axis,
                    u = i,
                    c = i;
                return O(i) ? u = c = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[i] || 0 : !o && a && (u = i[0], c = i[1]),
                    function (t, o, h) {
                        var d, f, p, m, g, v, y, b, _, x = (h || e).length,
                            w = s[x];
                        if (!w) {
                            if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1, E])[1])) {
                                for (y = -E; y < (y = h[_++].getBoundingClientRect().left) && _ < x;);
                                _ < x && _--
                            }
                            for (w = s[x] = [], d = a ? Math.min(_, x) * u - .5 : i % _, f = _ === E ? 0 : a ? x * c / _ - .5 : i / _ | 0, y = 0, b = E, v = 0; v < x; v++) p = v % _ - d, m = f - (v / _ | 0), w[v] = g = l ? Math.abs("y" === l ? m : p) : L(p * p + m * m), g > y && (y = g), g < b && (b = g);
                            "random" === i && ae(w), w.max = y - b, w.min = b, w.v = x = (parseFloat(e.amount) || parseFloat(e.each) * (_ > x ? x - 1 : l ? "y" === l ? x / _ : _ : Math.max(_, x / _)) || 0) * ("edges" === i ? -1 : 1), w.b = x < 0 ? r - x : r, w.u = ne(e.amount || e.each) || 0, n = n && x < 0 ? Ie(n) : n
                        }
                        return x = (w[t] - w.min) / w.max || 0, _t(w.b + (n ? n(x) : x) * w.v) + w.u
                    }
            },
            ue = function (t) {
                var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
                return function (n) {
                    var i = _t(Math.round(parseFloat(n) / t) * t * e);
                    return (i - i % 1) / e + (F(n) ? 0 : ne(n))
                }
            },
            ce = function (t, e) {
                var n, i, r = V(t);
                return !r && z(t) && (n = r = t.radius || E, t.values ? (t = se(t.values), (i = !F(t[0])) && (n *= n)) : t = ue(t.increment)), te(e, r ? I(t) ? function (e) {
                    return i = t(e), Math.abs(i - e) <= n ? i : e
                } : function (e) {
                    for (var r, s, o = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = E, u = 0, c = t.length; c--;)(r = i ? (r = t[c].x - o) * r + (s = t[c].y - a) * s : Math.abs(t[c] - o)) < l && (l = r, u = c);
                    return u = !n || l <= n ? t[u] : e, i || u === e || F(e) ? u : u + ne(e)
                } : ue(t))
            },
            he = function (t, e, n, i) {
                return te(V(t) ? !e : !0 === n ? !!(n = 0) : !i, (function () {
                    return V(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i
                }))
            },
            de = function (t, e, n) {
                return te(n, (function (n) {
                    return t[~~e(n)]
                }))
            },
            fe = function (t) {
                for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? Y : G), o += t.substr(s, e - s) + he(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1;
                return o + t.substr(s, t.length - s)
            },
            pe = function (t, e, n, i, r) {
                var s = e - t,
                    o = i - n;
                return te(r, (function (e) {
                    return n + ((e - t) / s * o || 0)
                }))
            },
            me = function (t, e, n) {
                var i, r, s, o = t.labels,
                    a = E;
                for (i in o) (r = o[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i, a = r);
                return s
            },
            ge = function (t, e, n) {
                var i, r, s, o = t.vars,
                    a = o[e],
                    l = m,
                    u = t._ctx;
                if (a) return i = o[e + "Params"], r = o.callbackScope || t, n && lt.length && Mt(), u && (m = u), s = i ? a.apply(r, i) : a.call(r), m = l, s
            },
            ve = function (t) {
                return Ot(t), t.scrollTrigger && t.scrollTrigger.kill(!!p), t.progress() < 1 && ge(t, "onInterrupt"), t
            },
            ye = [],
            be = function (t) {
                if (t)
                    if (t = !t.name && t.default || t, B() || t.headless) {
                        var e = t.name,
                            n = I(t),
                            i = e && !n && t.init ? function () {
                                this._props = []
                            } : t,
                            r = {
                                init: it,
                                render: hn,
                                add: qe,
                                kill: fn,
                                modifier: dn,
                                rawVars: 0
                            },
                            s = {
                                targetTest: 0,
                                get: 0,
                                getSetter: an,
                                aliases: {},
                                register: 0
                            };
                        if (Pe(), t !== i) {
                            if (ct[e]) return;
                            Dt(i, Dt(Pt(t, r), s)), Ct(i.prototype, Ct(r, Pt(t, s))), ct[i.prop = e] = i, t.targetTest && (ft.push(i), at[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                        }
                        nt(e, i), t.register && t.register(An, i, gn)
                    } else ye.push(t)
            },
            _e = 255,
            xe = {
                aqua: [0, _e, _e],
                lime: [0, _e, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, _e],
                navy: [0, 0, 128],
                white: [_e, _e, _e],
                olive: [128, 128, 0],
                yellow: [_e, _e, 0],
                orange: [_e, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [_e, 0, 0],
                pink: [_e, 192, 203],
                cyan: [0, _e, _e],
                transparent: [_e, _e, _e, 0]
            },
            we = function (t, e, n) {
                return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * _e + .5 | 0
            },
            Me = function (t, e, n) {
                var i, r, s, o, a, l, u, c, h, d, f = t ? F(t) ? [t >> 16, t >> 8 & _e, t & _e] : 0 : xe.black;
                if (!f) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), xe[t]) f = xe[t];
                    else if ("#" === t.charAt(0)) {
                        if (t.length < 6 && (i = t.charAt(1), r = t.charAt(2), s = t.charAt(3), t = "#" + i + i + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(f = parseInt(t.substr(1, 6), 16)) >> 16, f >> 8 & _e, f & _e, parseInt(t.substr(7), 16) / 255];
                        f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & _e, t & _e]
                    } else if ("hsl" === t.substr(0, 3))
                        if (f = d = t.match(G), e) {
                            if (~t.indexOf("=")) return f = t.match(W), n && f.length < 4 && (f[3] = 1), f
                        } else o = +f[0] % 360 / 360, a = +f[1] / 100, i = 2 * (l = +f[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), f.length > 3 && (f[3] *= 1), f[0] = we(o + 1 / 3, i, r), f[1] = we(o, i, r), f[2] = we(o - 1 / 3, i, r);
                    else f = t.match(G) || xe.transparent;
                    f = f.map(Number)
                }
                return e && !d && (i = f[0] / _e, r = f[1] / _e, s = f[2] / _e, l = ((u = Math.max(i, r, s)) + (c = Math.min(i, r, s))) / 2, u === c ? o = a = 0 : (h = u - c, a = l > .5 ? h / (2 - u - c) : h / (u + c), o = u === i ? (r - s) / h + (r < s ? 6 : 0) : u === r ? (s - i) / h + 2 : (i - r) / h + 4, o *= 60), f[0] = ~~(o + .5), f[1] = ~~(100 * a + .5), f[2] = ~~(100 * l + .5)), n && f.length < 4 && (f[3] = 1), f
            },
            Se = function (t) {
                var e = [],
                    n = [],
                    i = -1;
                return t.split(Ee).forEach((function (t) {
                    var r = t.match($) || [];
                    e.push.apply(e, r), n.push(i += r.length + 1)
                })), e.c = n, e
            },
            Te = function (t, e, n) {
                var i, r, s, o, a = "",
                    l = (t + a).match(Ee),
                    u = e ? "hsla(" : "rgba(",
                    c = 0;
                if (!l) return t;
                if (l = l.map((function (t) {
                    return (t = Me(t, e, 1)) && u + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                })), n && (s = Se(t), (i = n.c).join(a) !== s.c.join(a)))
                    for (o = (r = t.replace(Ee, "1").split($)).length - 1; c < o; c++) a += r[c] + (~i.indexOf(c) ? l.shift() || u + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
                if (!r)
                    for (o = (r = t.split(Ee)).length - 1; c < o; c++) a += r[c] + l[c];
                return a + r[o]
            },
            Ee = function () {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (t in xe) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(),
            De = /hsl[a]?\(/,
            Ce = function (t) {
                var e, n = t.join(" ");
                if (Ee.lastIndex = 0, Ee.test(n)) return e = De.test(n), t[1] = Te(t[1], e), t[0] = Te(t[0], e, Se(t[1])), !0
            },
            Ae = function () {
                var t, e, n, i, r, s, o = Date.now,
                    a = 500,
                    l = 33,
                    u = o(),
                    c = u,
                    h = 1e3 / 240,
                    d = h,
                    f = [],
                    p = function n(p) {
                        var m, g, v, y, b = o() - c,
                            _ = !0 === p;
                        if ((b > a || b < 0) && (u += b - l), ((m = (v = (c += b) - u) - d) > 0 || _) && (y = ++i.frame, r = v - 1e3 * i.time, i.time = v /= 1e3, d += m + (m >= h ? 4 : h - m), g = 1), _ || (t = e(n)), g)
                            for (s = 0; s < f.length; s++) f[s](v, r, y, p)
                    };
                return i = {
                    time: 0,
                    frame: 0,
                    tick: function () {
                        p(!0)
                    },
                    deltaRatio: function (t) {
                        return r / (1e3 / (t || 60))
                    },
                    wake: function () {
                        _ && (!y && B() && (v = y = window, b = v.document || {}, J.gsap = An, (v.gsapVersions || (v.gsapVersions = [])).push(An.version), Q(Z || v.GreenSockGlobals || !v.gsap && v || {}), ye.forEach(be)), n = "undefined" != typeof requestAnimationFrame && requestAnimationFrame, t && i.sleep(), e = n || function (t) {
                            return setTimeout(t, d - 1e3 * i.time + 1 | 0)
                        }, M = 1, p(2))
                    },
                    sleep: function () {
                        (n ? cancelAnimationFrame : clearTimeout)(t), M = 0, e = it
                    },
                    lagSmoothing: function (t, e) {
                        a = t || 1 / 0, l = Math.min(e || 33, a)
                    },
                    fps: function (t) {
                        h = 1e3 / (t || 240), d = 1e3 * i.time + h
                    },
                    add: function (t, e, n) {
                        var r = e ? function (e, n, s, o) {
                            t(e, n, s, o), i.remove(r)
                        } : t;
                        return i.remove(t), f[n ? "unshift" : "push"](r), Pe(), r
                    },
                    remove: function (t, e) {
                        ~(e = f.indexOf(t)) && f.splice(e, 1) && s >= e && s--
                    },
                    _listeners: f
                }, i
            }(),
            Pe = function () {
                return !M && Ae.wake()
            },
            Le = {},
            Re = /^[\d.\-M][\d.\-,\s]/,
            ke = /["']/g,
            Oe = function (t) {
                for (var e, n, i, r = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++) n = s[a], e = a !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[o] = isNaN(i) ? i.replace(ke, "").trim() : +i, o = n.substr(e + 1).trim();
                return r
            },
            Ie = function (t) {
                return function (e) {
                    return 1 - t(1 - e)
                }
            },
            Fe = function t(e, n) {
                for (var i, r = e._first; r;) r instanceof Ge ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
            },
            Ne = function (t, e) {
                return t && (I(t) ? t : Le[t] || function (t) {
                    var e, n, i, r, s = (t + "").split("("),
                        o = Le[s[0]];
                    return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [Oe(s[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(Tt)) : Le._CE && Re.test(t) ? Le._CE("", t) : o
                }(t)) || e
            },
            ze = function (t, e, n, i) {
                void 0 === n && (n = function (t) {
                    return 1 - e(1 - t)
                }), void 0 === i && (i = function (t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, s = {
                    easeIn: e,
                    easeOut: n,
                    easeInOut: i
                };
                return yt(t, (function (t) {
                    for (var e in Le[t] = J[t] = s, Le[r = t.toLowerCase()] = n, s) Le[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Le[t + "." + e] = s[e]
                })), s
            },
            Ue = function (t) {
                return function (e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            },
            Be = function t(e, n, i) {
                var r = n >= 1 ? n : 1,
                    s = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                    o = s / C * (Math.asin(1 / r) || 0),
                    a = function (t) {
                        return 1 === t ? 1 : r * Math.pow(2, -10 * t) * k((t - o) * s) + 1
                    },
                    l = "out" === e ? a : "in" === e ? function (t) {
                        return 1 - a(1 - t)
                    } : Ue(a);
                return s = C / s, l.config = function (n, i) {
                    return t(e, n, i)
                }, l
            },
            je = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var i = function (t) {
                    return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                },
                    r = "out" === e ? i : "in" === e ? function (t) {
                        return 1 - i(1 - t)
                    } : Ue(i);
                return r.config = function (n) {
                    return t(e, n)
                }, r
            };
        yt("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
            var n = e < 5 ? e + 1 : e;
            ze(t + ",Power" + (n - 1), e ? function (t) {
                return Math.pow(t, n)
            } : function (t) {
                return t
            }, (function (t) {
                return 1 - Math.pow(1 - t, n)
            }), (function (t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }))
        })), Le.Linear.easeNone = Le.none = Le.Linear.easeIn, ze("Elastic", Be("in"), Be("out"), Be()),
            function (t, e) {
                var n = 1 / e,
                    i = 2 * n,
                    r = 2.5 * n,
                    s = function (s) {
                        return s < n ? t * s * s : s < i ? t * Math.pow(s - 1.5 / e, 2) + .75 : s < r ? t * (s -= 2.25 / e) * s + .9375 : t * Math.pow(s - 2.625 / e, 2) + .984375
                    };
                ze("Bounce", (function (t) {
                    return 1 - s(1 - t)
                }), s)
            }(7.5625, 2.75), ze("Expo", (function (t) {
                return t ? Math.pow(2, 10 * (t - 1)) : 0
            })), ze("Circ", (function (t) {
                return -(L(1 - t * t) - 1)
            })), ze("Sine", (function (t) {
                return 1 === t ? 1 : 1 - R(t * A)
            })), ze("Back", je("in"), je("out"), je()), Le.SteppedEase = Le.steps = J.SteppedEase = {
                config: function (t, e) {
                    void 0 === t && (t = 1);
                    var n = 1 / t,
                        i = t + (e ? 0 : 1),
                        r = e ? 1 : 0;
                    return function (t) {
                        return ((i * ee(0, .99999999, t) | 0) + r) * n
                    }
                }
            }, T.ease = Le["quad.out"], yt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
                return pt += t + "," + t + "Params,"
            }));
        var He = function (t, e) {
            this.id = P++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : vt, this.set = e ? e.getSetter : an
        },
            Ve = function () {
                function t(t) {
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Yt(this, +t.duration, 1, 1), this.data = t.data, m && (this._ctx = m, m.data.push(this)), M || Ae.wake()
                }
                var e = t.prototype;
                return e.delay = function (t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, e.duration = function (t) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, e.totalDuration = function (t) {
                    return arguments.length ? (this._dirty = 0, Yt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function (t, e) {
                    if (Pe(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (Ht(this, t), !n._dp || n.parent || Vt(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Gt(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === D || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), St(this, t, e)), this
                }, e.time = function (t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + zt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
                }, e.totalProgress = function (t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
                }, e.progress = function (t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + zt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                }, e.iteration = function (t, e) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Ut(this._tTime, n) + 1 : 1
                }, e.timeScale = function (t, e) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var n = this.parent && this._ts ? Bt(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, this.totalTime(ee(-Math.abs(this._delay), this._tDur, n), !1 !== e), jt(this),
                        function (t) {
                            for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                            return t
                        }(this)
                }, e.paused = function (t) {
                    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Pe(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== D && (this._tTime -= D)))), this) : this._ps
                }, e.startTime = function (t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return e && (e._sort || !this.parent) && Gt(e, this, t - this._delay), this
                    }
                    return this._start
                }, e.endTime = function (t) {
                    return this._start + (U(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                }, e.rawTime = function (t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Bt(e.rawTime(t), this) : this._tTime : this._tTime
                }, e.revert = function (t) {
                    void 0 === t && (t = ot);
                    var e = p;
                    return p = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), p = e, this
                }, e.globalTime = function (t) {
                    for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (Math.abs(e._ts) || 1), e = e._dp;
                    return !this.parent && this._sat ? this._sat.globalTime(t) : n
                }, e.repeat = function (t) {
                    return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Kt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                }, e.repeatDelay = function (t) {
                    if (arguments.length) {
                        var e = this._time;
                        return this._rDelay = t, Kt(this), e ? this.time(e) : this
                    }
                    return this._rDelay
                }, e.yoyo = function (t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, e.seek = function (t, e) {
                    return this.totalTime(Zt(this, t), U(e))
                }, e.restart = function (t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, U(e))
                }, e.play = function (t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, e.reverse = function (t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, e.pause = function (t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, e.resume = function () {
                    return this.paused(!1)
                }, e.reversed = function (t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                }, e.invalidate = function () {
                    return this._initted = this._act = 0, this._zTime = -1e-8, this
                }, e.isActive = function () {
                    var t, e = this.parent || this._dp,
                        n = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - D))
                }, e.eventCallback = function (t, e, n) {
                    var i = this.vars;
                    return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
                }, e.then = function (t) {
                    var e = this;
                    return new Promise((function (n) {
                        var i = I(t) ? t : Et,
                            r = function () {
                                var t = e.then;
                                e.then = null, I(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                            };
                        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                    }))
                }, e.kill = function () {
                    ve(this)
                }, t
            }();
        Dt(Ve.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Ge = function (t) {
            function e(e, n) {
                var i;
                return void 0 === e && (e = {}), (i = t.call(this, e) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = U(e.sortChildren), g && Gt(e.parent || g, h(i), n), e.reversed && i.reverse(), e.paused && i.paused(!0), e.scrollTrigger && Wt(h(i), e.scrollTrigger), i
            }
            d(e, t);
            var n = e.prototype;
            return n.to = function (t, e, n) {
                return Qt(0, arguments, this), this
            }, n.from = function (t, e, n) {
                return Qt(1, arguments, this), this
            }, n.fromTo = function (t, e, n, i) {
                return Qt(2, arguments, this), this
            }, n.set = function (t, e, n) {
                return e.duration = 0, e.parent = this, Lt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new en(t, e, Zt(this, n), 1), this
            }, n.call = function (t, e, n) {
                return Gt(this, en.delayedCall(0, t, e), n)
            }, n.staggerTo = function (t, e, n, i, r, s, o) {
                return n.duration = e, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = o, n.parent = this, new en(t, n, Zt(this, r)), this
            }, n.staggerFrom = function (t, e, n, i, r, s, o) {
                return n.runBackwards = 1, Lt(n).immediateRender = U(n.immediateRender), this.staggerTo(t, e, n, i, r, s, o)
            }, n.staggerFromTo = function (t, e, n, i, r, s, o, a) {
                return i.startAt = n, Lt(i).immediateRender = U(i.immediateRender), this.staggerTo(t, e, i, r, s, o, a)
            }, n.render = function (t, e, n) {
                var i, r, s, o, a, l, u, c, h, d, f, m, v = this._time,
                    y = this._dirty ? this.totalDuration() : this._tDur,
                    b = this._dur,
                    _ = t <= 0 ? 0 : _t(t),
                    x = this._zTime < 0 != t < 0 && (this._initted || !b);
                if (this !== g && _ > y && t >= 0 && (_ = y), _ !== this._tTime || n || x) {
                    if (v !== this._time && b && (_ += this._time - v, t += this._time - v), i = _, h = this._start, l = !(c = this._ts), x && (b || (v = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (f = this._yoyo, a = b + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * a + t, e, n);
                        if (i = _t(_ % a), _ === y ? (o = this._repeat, i = b) : ((o = ~~(_ / a)) && o === _ / a && (i = b, o--), i > b && (i = b)), d = Ut(this._tTime, a), !v && this._tTime && d !== o && this._tTime - d * a - this._dur <= 0 && (d = o), f && 1 & o && (i = b - i, m = 1), o !== d && !this._lock) {
                            var w = f && 1 & d,
                                M = w === (f && 1 & o);
                            if (o < d && (w = !w), v = w ? 0 : _ % b ? b : _, this._lock = 1, this.render(v || (m ? 0 : _t(o * a)), e, !b)._lock = 0, this._tTime = _, !e && this.parent && ge(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), v && v !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (b = this._dur, y = this._tDur, M && (this._lock = 2, v = w ? b : -1e-4, this.render(v, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                            Fe(this, m)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (u = function (t, e, n) {
                        var i;
                        if (n > e)
                            for (i = t._first; i && i._start <= n;) {
                                if ("isPause" === i.data && i._start > e) return i;
                                i = i._next
                            } else
                            for (i = t._last; i && i._start >= n;) {
                                if ("isPause" === i.data && i._start < e) return i;
                                i = i._prev
                            }
                    }(this, _t(v), _t(i)), u && (_ -= i - (i = u._start))), this._tTime = _, this._time = i, this._act = !c, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, v = 0), !v && i && !e && !o && (ge(this, "onStart"), this._tTime !== _)) return this;
                    if (i >= v && t >= 0)
                        for (r = this._first; r;) {
                            if (s = r._next, (r._act || i >= r._start) && r._ts && u !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                    u = 0, s && (_ += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = s
                        } else {
                        r = this._last;
                        for (var S = t < 0 ? t : i; r;) {
                            if (s = r._prev, (r._act || S <= r._end) && r._ts && u !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (S - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (S - r._start) * r._ts, e, n || p && (r._initted || r._startAt)), i !== this._time || !this._ts && !l) {
                                    u = 0, s && (_ += this._zTime = S ? -1e-8 : D);
                                    break
                                }
                            }
                            r = s
                        }
                    }
                    if (u && !e && (this.pause(), u.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1, this._ts)) return this._start = h, jt(this), this.render(t, e, n);
                    this._onUpdate && !e && ge(this, "onUpdate", !0), (_ === y && this._tTime >= this.totalDuration() || !_ && v) && (h !== this._start && Math.abs(c) === Math.abs(this._ts) || this._lock || ((t || !b) && (_ === y && this._ts > 0 || !_ && this._ts < 0) && Ot(this, 1), e || t < 0 && !v || !_ && !v && y || (ge(this, _ === y && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < y && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function (t, e) {
                var n = this;
                if (F(e) || (e = Zt(this, e, t)), !(t instanceof Ve)) {
                    if (V(t)) return t.forEach((function (t) {
                        return n.add(t, e)
                    })), this;
                    if (O(t)) return this.addLabel(t, e);
                    if (!I(t)) return this;
                    t = en.delayedCall(0, t)
                }
                return this !== t ? Gt(this, t, e) : this
            }, n.getChildren = function (t, e, n, i) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -E);
                for (var r = [], s = this._first; s;) s._start >= i && (s instanceof en ? e && r.push(s) : (n && r.push(s), t && r.push.apply(r, s.getChildren(!0, e, n)))), s = s._next;
                return r
            }, n.getById = function (t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                    if (e[n].vars.id === t) return e[n]
            }, n.remove = function (t) {
                return O(t) ? this.removeLabel(t) : I(t) ? this.killTweensOf(t) : (kt(this, t), t === this._recent && (this._recent = this._last), It(this))
            }, n.totalTime = function (e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = _t(Ae.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function (t, e) {
                return this.labels[t] = Zt(this, e), this
            }, n.removeLabel = function (t) {
                return delete this.labels[t], this
            }, n.addPause = function (t, e, n) {
                var i = en.delayedCall(0, e || it, n);
                return i.data = "isPause", this._hasPause = 1, Gt(this, i, Zt(this, t))
            }, n.removePause = function (t) {
                var e = this._first;
                for (t = Zt(this, t); e;) e._start === t && "isPause" === e.data && Ot(e), e = e._next
            }, n.killTweensOf = function (t, e, n) {
                for (var i = this.getTweensOf(t, n), r = i.length; r--;) We !== i[r] && i[r].kill(t, e);
                return this
            }, n.getTweensOf = function (t, e) {
                for (var n, i = [], r = se(t), s = this._first, o = F(e); s;) s instanceof en ? wt(s._targets, r) && (o ? (!We || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n), s = s._next;
                return i
            }, n.tweenTo = function (t, e) {
                e = e || {};
                var n, i = this,
                    r = Zt(i, t),
                    s = e,
                    o = s.startAt,
                    a = s.onStart,
                    l = s.onStartParams,
                    u = s.immediateRender,
                    c = en.to(i, Dt({
                        ease: e.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: r,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale()) || D,
                        onStart: function () {
                            if (i.pause(), !n) {
                                var t = e.duration || Math.abs((r - (o && "time" in o ? o.time : i._time)) / i.timeScale());
                                c._dur !== t && Yt(c, t, 0, 1).render(c._time, !0, !0), n = 1
                            }
                            a && a.apply(c, l || [])
                        }
                    }, e));
                return u ? c.render(0) : c
            }, n.tweenFromTo = function (t, e, n) {
                return this.tweenTo(e, Dt({
                    startAt: {
                        time: Zt(this, t)
                    }
                }, n))
            }, n.recent = function () {
                return this._recent
            }, n.nextLabel = function (t) {
                return void 0 === t && (t = this._time), me(this, Zt(this, t))
            }, n.previousLabel = function (t) {
                return void 0 === t && (t = this._time), me(this, Zt(this, t), 1)
            }, n.currentLabel = function (t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + D)
            }, n.shiftChildren = function (t, e, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, s = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                if (e)
                    for (i in s) s[i] >= n && (s[i] += t);
                return It(this)
            }, n.invalidate = function (e) {
                var n = this._first;
                for (this._lock = 0; n;) n.invalidate(e), n = n._next;
                return t.prototype.invalidate.call(this, e)
            }, n.clear = function (t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), It(this)
            }, n.totalDuration = function (t) {
                var e, n, i, r = 0,
                    s = this,
                    o = s._last,
                    a = E;
                if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
                if (s._dirty) {
                    for (i = s.parent; o;) e = o._prev, o._dirty && o.totalDuration(), (n = o._start) > a && s._sort && o._ts && !s._lock ? (s._lock = 1, Gt(s, o, n - o._delay, 1)._lock = 0) : a = n, n < 0 && o._ts && (r -= n, (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -Infinity), a = 0), o._end > r && o._ts && (r = o._end), o = e;
                    Yt(s, s === g && s._time > r ? s._time : r, 1, 1), s._dirty = 0
                }
                return s._tDur
            }, e.updateRoot = function (t) {
                if (g._ts && (St(g, Bt(t, g)), x = Ae.frame), Ae.frame >= dt) {
                    dt += S.autoSleep || 120;
                    var e = g._first;
                    if ((!e || !e._ts) && S.autoSleep && Ae._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || Ae.sleep()
                    }
                }
            }, e
        }(Ve);
        Dt(Ge.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var We, $e, Xe = function (t, e, n, i, r, s, o) {
            var a, l, u, c, h, d, f, p, m = new gn(this._pt, t, e, 0, 1, cn, null, r),
                g = 0,
                v = 0;
            for (m.b = n, m.e = i, n += "", (f = ~(i += "").indexOf("random(")) && (i = fe(i)), s && (s(p = [n, i], t, e), n = p[0], i = p[1]), l = n.match(X) || []; a = X.exec(i);) c = a[0], h = i.substring(g, a.index), u ? u = (u + 1) % 5 : "rgba(" === h.substr(-5) && (u = 1), c !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
                _next: m._pt,
                p: h || 1 === v ? h : ",",
                s: d,
                c: "=" === c.charAt(1) ? xt(d, c) - d : parseFloat(c) - d,
                m: u && u < 4 ? Math.round : 0
            }, g = X.lastIndex);
            return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = o, (q.test(i) || f) && (m.e = 0), this._pt = m, m
        },
            qe = function (t, e, n, i, r, s, o, a, l, u) {
                I(i) && (i = i(r || 0, t, s));
                var c, h = t[e],
                    d = "get" !== n ? n : I(h) ? l ? t[e.indexOf("set") || !I(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h,
                    f = I(h) ? l ? sn : rn : nn;
                if (O(i) && (~i.indexOf("random(") && (i = fe(i)), "=" === i.charAt(1) && ((c = xt(d, i) + (ne(d) || 0)) || 0 === c) && (i = c)), !u || d !== i || $e) return isNaN(d * i) || "" === i ? (!h && !(e in t) && tt(e, i), Xe.call(this, t, e, d, i, f, a || S.stringFilter, l)) : (c = new gn(this._pt, t, e, +d || 0, i - (d || 0), "boolean" == typeof h ? un : ln, 0, f), l && (c.fp = l), o && c.modifier(o, this, t), this._pt = c)
            },
            Ye = function (t, e, n, i, r, s) {
                var o, a, l, u;
                if (ct[t] && !1 !== (o = new ct[t]).init(r, o.rawVars ? e[t] : function (t, e, n, i, r) {
                    if (I(t) && (t = Ze(t, r, e, n, i)), !z(t) || t.style && t.nodeType || V(t) || H(t)) return O(t) ? Ze(t, r, e, n, i) : t;
                    var s, o = {};
                    for (s in t) o[s] = Ze(t[s], r, e, n, i);
                    return o
                }(e[t], i, r, s, n), n, i, s) && (n._pt = a = new gn(n._pt, r, t, 0, 1, o.render, o, 0, o.priority), n !== w))
                    for (l = n._ptLookup[n._targets.indexOf(r)], u = o._props.length; u--;) l[o._props[u]] = a;
                return o
            },
            Ke = function t(e, n, i) {
                var r, s, o, a, l, u, c, h, d, m, v, y, b, _ = e.vars,
                    x = _.ease,
                    w = _.startAt,
                    M = _.immediateRender,
                    S = _.lazy,
                    C = _.onUpdate,
                    A = _.runBackwards,
                    P = _.yoyoEase,
                    L = _.keyframes,
                    R = _.autoRevert,
                    k = e._dur,
                    O = e._startAt,
                    I = e._targets,
                    F = e.parent,
                    N = F && "nested" === F.data ? F.vars.targets : I,
                    z = "auto" === e._overwrite && !f,
                    B = e.timeline;
                if (B && (!L || !x) && (x = "none"), e._ease = Ne(x, T.ease), e._yEase = P ? Ie(Ne(!0 === P ? x : P, T.ease)) : 0, P && e._yoyo && !e._repeat && (P = e._yEase, e._yEase = e._ease, e._ease = P), e._from = !B && !!_.runBackwards, !B || L && !_.stagger) {
                    if (y = (h = I[0] ? gt(I[0]).harness : 0) && _[h.prop], r = Pt(_, at), O && (O._zTime < 0 && O.progress(1), n < 0 && A && M && !R ? O.render(-1, !0) : O.revert(A && k ? st : rt), O._lazy = 0), w) {
                        if (Ot(e._startAt = en.set(I, Dt({
                            data: "isStart",
                            overwrite: !1,
                            parent: F,
                            immediateRender: !0,
                            lazy: !O && U(S),
                            startAt: null,
                            delay: 0,
                            onUpdate: C && function () {
                                return ge(e, "onUpdate")
                            },
                            stagger: 0
                        }, w))), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (p || !M && !R) && e._startAt.revert(st), M && k && n <= 0 && i <= 0) return void (n && (e._zTime = n))
                    } else if (A && k && !O)
                        if (n && (M = !1), o = Dt({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: M && !O && U(S),
                            immediateRender: M,
                            stagger: 0,
                            parent: F
                        }, r), y && (o[h.prop] = y), Ot(e._startAt = en.set(I, o)), e._startAt._dp = 0, e._startAt._sat = e, n < 0 && (p ? e._startAt.revert(st) : e._startAt.render(-1, !0)), e._zTime = n, M) {
                            if (!n) return
                        } else t(e._startAt, D, D);
                    for (e._pt = e._ptCache = 0, S = k && U(S) || S && !k, s = 0; s < I.length; s++) {
                        if (c = (l = I[s])._gsap || mt(I)[s]._gsap, e._ptLookup[s] = m = {}, ut[c.id] && lt.length && Mt(), v = N === I ? s : N.indexOf(l), h && !1 !== (d = new h).init(l, y || r, e, v, N) && (e._pt = a = new gn(e._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function (t) {
                            m[t] = a
                        })), d.priority && (u = 1)), !h || y)
                            for (o in r) ct[o] && (d = Ye(o, r, e, v, l, N)) ? d.priority && (u = 1) : m[o] = a = qe.call(e, l, o, "get", r[o], v, N, 0, _.stringFilter);
                        e._op && e._op[s] && e.kill(l, e._op[s]), z && e._pt && (We = e, g.killTweensOf(l, m, e.globalTime(n)), b = !e.parent, We = 0), e._pt && S && (ut[c.id] = 1)
                    }
                    u && mn(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = C, e._initted = (!e._op || e._pt) && !b, L && n <= 0 && B.render(E, !0, !0)
            },
            Je = function (t, e, n, i) {
                var r, s, o = e.ease || i || "power1.inOut";
                if (V(e)) s = n[t] || (n[t] = []), e.forEach((function (t, n) {
                    return s.push({
                        t: n / (e.length - 1) * 100,
                        v: t,
                        e: o
                    })
                }));
                else
                    for (r in e) s = n[r] || (n[r] = []), "ease" === r || s.push({
                        t: parseFloat(t),
                        v: e[r],
                        e: o
                    })
            },
            Ze = function (t, e, n, i, r) {
                return I(t) ? t.call(e, n, i, r) : O(t) && ~t.indexOf("random(") ? fe(t) : t
            },
            Qe = pt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
            tn = {};
        yt(Qe + ",id,stagger,delay,duration,paused,scrollTrigger", (function (t) {
            return tn[t] = 1
        }));
        var en = function (t) {
            function e(e, n, i, r) {
                var s;
                "number" == typeof n && (i.duration = n, n = i, i = null);
                var o, a, l, u, c, d, p, m, v = (s = t.call(this, r ? n : Lt(n)) || this).vars,
                    y = v.duration,
                    b = v.delay,
                    _ = v.immediateRender,
                    x = v.stagger,
                    w = v.overwrite,
                    M = v.keyframes,
                    T = v.defaults,
                    E = v.scrollTrigger,
                    D = v.yoyoEase,
                    C = n.parent || g,
                    A = (V(e) || H(e) ? F(e[0]) : "length" in n) ? [e] : se(e);
                if (s._targets = A.length ? mt(A) : et("GSAP target " + e + " not found. https://gsap.com", !S.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = w, M || x || j(y) || j(b)) {
                    if (n = s.vars, (o = s.timeline = new Ge({
                        data: "nested",
                        defaults: T || {},
                        targets: C && "nested" === C.data ? C.vars.targets : A
                    })).kill(), o.parent = o._dp = h(s), o._start = 0, x || j(y) || j(b)) {
                        if (u = A.length, p = x && le(x), z(x))
                            for (c in x) ~Qe.indexOf(c) && (m || (m = {}), m[c] = x[c]);
                        for (a = 0; a < u; a++)(l = Pt(n, tn)).stagger = 0, D && (l.yoyoEase = D), m && Ct(l, m), d = A[a], l.duration = +Ze(y, h(s), a, d, A), l.delay = (+Ze(b, h(s), a, d, A) || 0) - s._delay, !x && 1 === u && l.delay && (s._delay = b = l.delay, s._start += b, l.delay = 0), o.to(d, l, p ? p(a, d, A) : 0), o._ease = Le.none;
                        o.duration() ? y = b = 0 : s.timeline = 0
                    } else if (M) {
                        Lt(Dt(o.vars.defaults, {
                            ease: "none"
                        })), o._ease = Ne(M.ease || n.ease || "none");
                        var P, L, R, k = 0;
                        if (V(M)) M.forEach((function (t) {
                            return o.to(A, t, ">")
                        })), o.duration();
                        else {
                            for (c in l = {}, M) "ease" === c || "easeEach" === c || Je(c, M[c], l, M.easeEach);
                            for (c in l)
                                for (P = l[c].sort((function (t, e) {
                                    return t.t - e.t
                                })), k = 0, a = 0; a < P.length; a++)(R = {
                                    ease: (L = P[a]).e,
                                    duration: (L.t - (a ? P[a - 1].t : 0)) / 100 * y
                                })[c] = L.v, o.to(A, R, k), k += R.duration;
                            o.duration() < y && o.to({}, {
                                duration: y - o.duration()
                            })
                        }
                    }
                    y || s.duration(y = o.duration())
                } else s.timeline = 0;
                return !0 !== w || f || (We = h(s), g.killTweensOf(A), We = 0), Gt(C, h(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), (_ || !y && !M && s._start === _t(C._time) && U(_) && Nt(h(s)) && "nested" !== C.data) && (s._tTime = -1e-8, s.render(Math.max(0, -b) || 0)), E && Wt(h(s), E), s
            }
            d(e, t);
            var n = e.prototype;
            return n.render = function (t, e, n) {
                var i, r, s, o, a, l, u, c, h, d = this._time,
                    f = this._tDur,
                    m = this._dur,
                    g = t < 0,
                    v = t > f - D && !g ? f : t < D ? 0 : t;
                if (m) {
                    if (v !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                        if (i = v, c = this.timeline, this._repeat) {
                            if (o = m + this._rDelay, this._repeat < -1 && g) return this.totalTime(100 * o + t, e, n);
                            if (i = _t(v % o), v === f ? (s = this._repeat, i = m) : ((s = ~~(v / o)) && s === _t(v / o) && (i = m, s--), i > m && (i = m)), (l = this._yoyo && 1 & s) && (h = this._yEase, i = m - i), a = Ut(this._tTime, o), i === d && !n && this._initted && s === a) return this._tTime = v, this;
                            s !== a && (c && this._yEase && Fe(c, l), this.vars.repeatRefresh && !l && !this._lock && this._time !== o && this._initted && (this._lock = n = 1, this.render(_t(o * s), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if ($t(this, g ? t : i, n, e, v)) return this._tTime = 0, this;
                            if (!(d === this._time || n && this.vars.repeatRefresh && s !== a)) return this;
                            if (m !== this._dur) return this.render(t, e, n)
                        }
                        if (this._tTime = v, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = u = (h || this._ease)(i / m), this._from && (this.ratio = u = 1 - u), i && !d && !e && !s && (ge(this, "onStart"), this._tTime !== v)) return this;
                        for (r = this._pt; r;) r.r(u, r.d), r = r._next;
                        c && c.render(t < 0 ? t : c._dur * c._ease(i / this._dur), e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (g && Ft(this, t, 0, n), ge(this, "onUpdate")), this._repeat && s !== a && this.vars.onRepeat && !e && this.parent && ge(this, "onRepeat"), v !== this._tDur && v || this._tTime !== v || (g && !this._onUpdate && Ft(this, t, 0, !0), (t || !m) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && Ot(this, 1), e || g && !d || !(v || d || l) || (ge(this, v === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < f && this.timeScale() > 0) && this._prom()))
                    }
                } else ! function (t, e, n, i) {
                    var r, s, o, a = t.ratio,
                        l = e < 0 || !e && (!t._start && Xt(t) && (t._initted || !qt(t)) || (t._ts < 0 || t._dp._ts < 0) && !qt(t)) ? 0 : 1,
                        u = t._rDelay,
                        c = 0;
                    if (u && t._repeat && (c = ee(0, t._tDur, e), s = Ut(c, u), t._yoyo && 1 & s && (l = 1 - l), s !== Ut(t._tTime, u) && (a = 1 - l, t.vars.repeatRefresh && t._initted && t.invalidate())), l !== a || p || i || t._zTime === D || !e && t._zTime) {
                        if (!t._initted && $t(t, e, i, n, c)) return;
                        for (o = t._zTime, t._zTime = e || (n ? D : 0), n || (n = e && !o), t.ratio = l, t._from && (l = 1 - l), t._time = 0, t._tTime = c, r = t._pt; r;) r.r(l, r.d), r = r._next;
                        e < 0 && Ft(t, e, 0, !0), t._onUpdate && !n && ge(t, "onUpdate"), c && t._repeat && !n && t.parent && ge(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === l && (l && Ot(t, 1), n || p || (ge(t, l ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    } else t._zTime || (t._zTime = e)
                }(this, t, e, n);
                return this
            }, n.targets = function () {
                return this._targets
            }, n.invalidate = function (e) {
                return (!e || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(e), t.prototype.invalidate.call(this, e)
            }, n.resetTo = function (t, e, n, i, r) {
                M || Ae.wake(), this._ts || this.play();
                var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                return this._initted || Ke(this, s),
                    function (t, e, n, i, r, s, o, a) {
                        var l, u, c, h, d = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                        if (!d)
                            for (d = t._ptCache[e] = [], c = t._ptLookup, h = t._targets.length; h--;) {
                                if ((l = c[h][e]) && l.d && l.d._pt)
                                    for (l = l.d._pt; l && l.p !== e && l.fp !== e;) l = l._next;
                                if (!l) return $e = 1, t.vars[e] = "+=0", Ke(t, o), $e = 0, a ? et(e + " not eligible for reset") : 1;
                                d.push(l)
                            }
                        for (h = d.length; h--;)(l = (u = d[h])._pt || u).s = !i && 0 !== i || r ? l.s + (i || 0) + s * l.c : i, l.c = n - l.s, u.e && (u.e = bt(n) + ne(u.e)), u.b && (u.b = l.s + ne(u.b))
                    }(this, t, e, n, i, this._ease(s / this._dur), s, r) ? this.resetTo(t, e, n, i, 1) : (Ht(this, 0), this.parent || Rt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
            }, n.kill = function (t, e) {
                if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? ve(this) : this;
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, We && !0 !== We.vars.overwrite)._first || ve(this), this.parent && n !== this.timeline.totalDuration() && Yt(this, this._dur * this.timeline._tDur / n, 0, 1), this
                }
                var i, r, s, o, a, l, u, c = this._targets,
                    h = t ? se(t) : c,
                    d = this._ptLookup,
                    f = this._pt;
                if ((!e || "all" === e) && function (t, e) {
                    for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                    return n < 0
                }(c, h)) return "all" === e && (this._pt = 0), ve(this);
                for (i = this._op = this._op || [], "all" !== e && (O(e) && (a = {}, yt(e, (function (t) {
                    return a[t] = 1
                })), e = a), e = function (t, e) {
                    var n, i, r, s, o = t[0] ? gt(t[0]).harness : 0,
                        a = o && o.aliases;
                    if (!a) return e;
                    for (i in n = Ct({}, e), a)
                        if (i in n)
                            for (r = (s = a[i].split(",")).length; r--;) n[s[r]] = n[i];
                    return n
                }(c, e)), u = c.length; u--;)
                    if (~h.indexOf(c[u]))
                        for (a in r = d[u], "all" === e ? (i[u] = e, o = r, s = {}) : (s = i[u] = i[u] || {}, o = e), o) (l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || kt(this, l, "_pt"), delete r[a]), "all" !== s && (s[a] = 1);
                return this._initted && !this._pt && f && ve(this), this
            }, e.to = function (t, n) {
                return new e(t, n, arguments[2])
            }, e.from = function (t, e) {
                return Qt(1, arguments)
            }, e.delayedCall = function (t, n, i, r) {
                return new e(n, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: r
                })
            }, e.fromTo = function (t, e, n) {
                return Qt(2, arguments)
            }, e.set = function (t, n) {
                return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
            }, e.killTweensOf = function (t, e, n) {
                return g.killTweensOf(t, e, n)
            }, e
        }(Ve);
        Dt(en.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), yt("staggerTo,staggerFrom,staggerFromTo", (function (t) {
            en[t] = function () {
                var e = new Ge,
                    n = ie.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var nn = function (t, e, n) {
            return t[e] = n
        },
            rn = function (t, e, n) {
                return t[e](n)
            },
            sn = function (t, e, n, i) {
                return t[e](i.fp, n)
            },
            on = function (t, e, n) {
                return t.setAttribute(e, n)
            },
            an = function (t, e) {
                return I(t[e]) ? rn : N(t[e]) && t.setAttribute ? on : nn
            },
            ln = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
            },
            un = function (t, e) {
                return e.set(e.t, e.p, !!(e.s + e.c * t), e)
            },
            cn = function (t, e) {
                var n = e._pt,
                    i = "";
                if (!t && e.b) i = e.b;
                else if (1 === t && e.e) i = e.e;
                else {
                    for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                    i += e.c
                }
                e.set(e.t, e.p, i, e)
            },
            hn = function (t, e) {
                for (var n = e._pt; n;) n.r(t, n.d), n = n._next
            },
            dn = function (t, e, n, i) {
                for (var r, s = this._pt; s;) r = s._next, s.p === i && s.modifier(t, e, n), s = r
            },
            fn = function (t) {
                for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? kt(this, i, "_pt") : i.dep || (e = 1), i = n;
                return !e
            },
            pn = function (t, e, n, i) {
                i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
            },
            mn = function (t) {
                for (var e, n, i, r, s = t._pt; s;) {
                    for (e = s._next, n = i; n && n.pr > s.pr;) n = n._next;
                    (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s, (s._next = n) ? n._prev = s : r = s, s = e
                }
                t._pt = i
            },
            gn = function () {
                function t(t, e, n, i, r, s, o, a, l) {
                    this.t = e, this.s = i, this.c = r, this.p = n, this.r = s || ln, this.d = o || this, this.set = a || nn, this.pr = l || 0, this._next = t, t && (t._prev = this)
                }
                return t.prototype.modifier = function (t, e, n) {
                    this.mSet = this.mSet || this.set, this.set = pn, this.m = t, this.mt = n, this.tween = e
                }, t
            }();
        yt(pt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
            return at[t] = 1
        })), J.TweenMax = J.TweenLite = en, J.TimelineLite = J.TimelineMax = Ge, g = new Ge({
            sortChildren: !1,
            defaults: T,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), S.stringFilter = Ce;
        var vn = [],
            yn = {},
            bn = [],
            _n = 0,
            xn = 0,
            wn = function (t) {
                return (yn[t] || bn).map((function (t) {
                    return t()
                }))
            },
            Mn = function () {
                var t = Date.now(),
                    e = [];
                t - _n > 2 && (wn("matchMediaInit"), vn.forEach((function (t) {
                    var n, i, r, s, o = t.queries,
                        a = t.conditions;
                    for (i in o) (n = v.matchMedia(o[i]).matches) && (r = 1), n !== a[i] && (a[i] = n, s = 1);
                    s && (t.revert(), r && e.push(t))
                })), wn("matchMediaRevert"), e.forEach((function (t) {
                    return t.onMatch(t, (function (e) {
                        return t.add(null, e)
                    }))
                })), _n = t, wn("matchMedia"))
            },
            Sn = function () {
                function t(t, e) {
                    this.selector = e && oe(e), this.data = [], this._r = [], this.isReverted = !1, this.id = xn++, t && this.add(t)
                }
                var e = t.prototype;
                return e.add = function (t, e, n) {
                    I(t) && (n = e, e = t, t = I);
                    var i = this,
                        r = function () {
                            var t, r = m,
                                s = i.selector;
                            return r && r !== i && r.data.push(i), n && (i.selector = oe(n)), m = i, t = e.apply(i, arguments), I(t) && i._r.push(t), m = r, i.selector = s, i.isReverted = !1, t
                        };
                    return i.last = r, t === I ? r(i, (function (t) {
                        return i.add(null, t)
                    })) : t ? i[t] = r : r
                }, e.ignore = function (t) {
                    var e = m;
                    m = null, t(this), m = e
                }, e.getTweens = function () {
                    var e = [];
                    return this.data.forEach((function (n) {
                        return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof en && !(n.parent && "nested" === n.parent.data) && e.push(n)
                    })), e
                }, e.clear = function () {
                    this._r.length = this.data.length = 0
                }, e.kill = function (t, e) {
                    var n = this;
                    if (t ? function () {
                        for (var e, i = n.getTweens(), r = n.data.length; r--;) "isFlip" === (e = n.data[r]).data && (e.revert(), e.getChildren(!0, !0, !1).forEach((function (t) {
                            return i.splice(i.indexOf(t), 1)
                        })));
                        for (i.map((function (t) {
                            return {
                                g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -1 / 0,
                                t
                            }
                        })).sort((function (t, e) {
                            return e.g - t.g || -1 / 0
                        })).forEach((function (e) {
                            return e.t.revert(t)
                        })), r = n.data.length; r--;)(e = n.data[r]) instanceof Ge ? "nested" !== e.data && (e.scrollTrigger && e.scrollTrigger.revert(), e.kill()) : !(e instanceof en) && e.revert && e.revert(t);
                        n._r.forEach((function (e) {
                            return e(t, n)
                        })), n.isReverted = !0
                    }() : this.data.forEach((function (t) {
                        return t.kill && t.kill()
                    })), this.clear(), e)
                        for (var i = vn.length; i--;) vn[i].id === this.id && vn.splice(i, 1)
                }, e.revert = function (t) {
                    this.kill(t || {})
                }, t
            }(),
            Tn = function () {
                function t(t) {
                    this.contexts = [], this.scope = t, m && m.data.push(this)
                }
                var e = t.prototype;
                return e.add = function (t, e, n) {
                    z(t) || (t = {
                        matches: t
                    });
                    var i, r, s, o = new Sn(0, n || this.scope),
                        a = o.conditions = {};
                    for (r in m && !o.selector && (o.selector = m.selector), this.contexts.push(o), e = o.add("onMatch", e), o.queries = t, t) "all" === r ? s = 1 : (i = v.matchMedia(t[r])) && (vn.indexOf(o) < 0 && vn.push(o), (a[r] = i.matches) && (s = 1), i.addListener ? i.addListener(Mn) : i.addEventListener("change", Mn));
                    return s && e(o, (function (t) {
                        return o.add(null, t)
                    })), this
                }, e.revert = function (t) {
                    this.kill(t || {})
                }, e.kill = function (t) {
                    this.contexts.forEach((function (e) {
                        return e.kill(t, !0)
                    }))
                }, t
            }(),
            En = {
                registerPlugin: function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    e.forEach((function (t) {
                        return be(t)
                    }))
                },
                timeline: function (t) {
                    return new Ge(t)
                },
                getTweensOf: function (t, e) {
                    return g.getTweensOf(t, e)
                },
                getProperty: function (t, e, n, i) {
                    O(t) && (t = se(t)[0]);
                    var r = gt(t || {}).get,
                        s = n ? Et : Tt;
                    return "native" === n && (n = ""), t ? e ? s((ct[e] && ct[e].get || r)(t, e, n, i)) : function (e, n, i) {
                        return s((ct[e] && ct[e].get || r)(t, e, n, i))
                    } : t
                },
                quickSetter: function (t, e, n) {
                    if ((t = se(t)).length > 1) {
                        var i = t.map((function (t) {
                            return An.quickSetter(t, e, n)
                        })),
                            r = i.length;
                        return function (t) {
                            for (var e = r; e--;) i[e](t)
                        }
                    }
                    t = t[0] || {};
                    var s = ct[e],
                        o = gt(t),
                        a = o.harness && (o.harness.aliases || {})[e] || e,
                        l = s ? function (e) {
                            var i = new s;
                            w._pt = 0, i.init(t, n ? e + n : e, w, 0, [t]), i.render(1, i), w._pt && hn(1, w)
                        } : o.set(t, a);
                    return s ? l : function (e) {
                        return l(t, a, n ? e + n : e, o, 1)
                    }
                },
                quickTo: function (t, e, n) {
                    var i, r = An.to(t, Ct(((i = {})[e] = "+=0.1", i.paused = !0, i), n || {})),
                        s = function (t, n, i) {
                            return r.resetTo(e, t, n, i)
                        };
                    return s.tween = r, s
                },
                isTweening: function (t) {
                    return g.getTweensOf(t, !0).length > 0
                },
                defaults: function (t) {
                    return t && t.ease && (t.ease = Ne(t.ease, T.ease)), At(T, t || {})
                },
                config: function (t) {
                    return At(S, t || {})
                },
                registerEffect: function (t) {
                    var e = t.name,
                        n = t.effect,
                        i = t.plugins,
                        r = t.defaults,
                        s = t.extendTimeline;
                    (i || "").split(",").forEach((function (t) {
                        return t && !ct[t] && !J[t] && et(e + " effect requires " + t + " plugin.")
                    })), ht[e] = function (t, e, i) {
                        return n(se(t), Dt(e || {}, r), i)
                    }, s && (Ge.prototype[e] = function (t, n, i) {
                        return this.add(ht[e](t, z(n) ? n : (i = n) && {}, this), i)
                    })
                },
                registerEase: function (t, e) {
                    Le[t] = Ne(e)
                },
                parseEase: function (t, e) {
                    return arguments.length ? Ne(t, e) : Le
                },
                getById: function (t) {
                    return g.getById(t)
                },
                exportRoot: function (t, e) {
                    void 0 === t && (t = {});
                    var n, i, r = new Ge(t);
                    for (r.smoothChildTiming = U(t.smoothChildTiming), g.remove(r), r._dp = 0, r._time = r._tTime = g._time, n = g._first; n;) i = n._next, !e && !n._dur && n instanceof en && n.vars.onComplete === n._targets[0] || Gt(r, n, n._start - n._delay), n = i;
                    return Gt(g, r, 0), r
                },
                context: function (t, e) {
                    return t ? new Sn(t, e) : m
                },
                matchMedia: function (t) {
                    return new Tn(t)
                },
                matchMediaRefresh: function () {
                    return vn.forEach((function (t) {
                        var e, n, i = t.conditions;
                        for (n in i) i[n] && (i[n] = !1, e = 1);
                        e && t.revert()
                    })) || Mn()
                },
                addEventListener: function (t, e) {
                    var n = yn[t] || (yn[t] = []);
                    ~n.indexOf(e) || n.push(e)
                },
                removeEventListener: function (t, e) {
                    var n = yn[t],
                        i = n && n.indexOf(e);
                    i >= 0 && n.splice(i, 1)
                },
                utils: {
                    wrap: function t(e, n, i) {
                        var r = n - e;
                        return V(e) ? de(e, t(0, e.length), n) : te(i, (function (t) {
                            return (r + (t - e) % r) % r + e
                        }))
                    },
                    wrapYoyo: function t(e, n, i) {
                        var r = n - e,
                            s = 2 * r;
                        return V(e) ? de(e, t(0, e.length - 1), n) : te(i, (function (t) {
                            return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                        }))
                    },
                    distribute: le,
                    random: he,
                    snap: ce,
                    normalize: function (t, e, n) {
                        return pe(t, e, 0, 1, n)
                    },
                    getUnit: ne,
                    clamp: function (t, e, n) {
                        return te(n, (function (n) {
                            return ee(t, e, n)
                        }))
                    },
                    splitColor: Me,
                    toArray: se,
                    selector: oe,
                    mapRange: pe,
                    pipe: function () {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        return function (t) {
                            return e.reduce((function (t, e) {
                                return e(t)
                            }), t)
                        }
                    },
                    unitize: function (t, e) {
                        return function (n) {
                            return t(parseFloat(n)) + (e || ne(n))
                        }
                    },
                    interpolate: function t(e, n, i, r) {
                        var s = isNaN(e + n) ? 0 : function (t) {
                            return (1 - t) * e + t * n
                        };
                        if (!s) {
                            var o, a, l, u, c, h = O(e),
                                d = {};
                            if (!0 === i && (r = 1) && (i = null), h) e = {
                                p: e
                            }, n = {
                                p: n
                            };
                            else if (V(e) && !V(n)) {
                                for (l = [], u = e.length, c = u - 2, a = 1; a < u; a++) l.push(t(e[a - 1], e[a]));
                                u--, s = function (t) {
                                    t *= u;
                                    var e = Math.min(c, ~~t);
                                    return l[e](t - e)
                                }, i = n
                            } else r || (e = Ct(V(e) ? [] : {}, e));
                            if (!l) {
                                for (o in n) qe.call(d, e, o, "get", n[o]);
                                s = function (t) {
                                    return hn(t, d) || (h ? e.p : e)
                                }
                            }
                        }
                        return te(i, s)
                    },
                    shuffle: ae
                },
                install: Q,
                effects: ht,
                ticker: Ae,
                updateRoot: Ge.updateRoot,
                plugins: ct,
                globalTimeline: g,
                core: {
                    PropTween: gn,
                    globals: nt,
                    Tween: en,
                    Timeline: Ge,
                    Animation: Ve,
                    getCache: gt,
                    _removeLinkedListItem: kt,
                    reverting: function () {
                        return p
                    },
                    context: function (t) {
                        return t && m && (m.data.push(t), t._ctx = m), m
                    },
                    suppressOverwrites: function (t) {
                        return f = t
                    }
                }
            };
        yt("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
            return En[t] = en[t]
        })), Ae.add(Ge.updateRoot), w = En.to({}, {
            duration: 0
        });
        var Dn = function (t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
            return n
        },
            Cn = function (t, e) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function (t, n, i) {
                        i._onInit = function (t) {
                            var i, r;
                            if (O(n) && (i = {}, yt(n, (function (t) {
                                return i[t] = 1
                            })), n = i), e) {
                                for (r in i = {}, n) i[r] = e(n[r]);
                                n = i
                            } ! function (t, e) {
                                var n, i, r, s = t._targets;
                                for (n in e)
                                    for (i = s.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = Dn(r, n)), r && r.modifier && r.modifier(e[n], t, s[i], n))
                            }(t, n)
                        }
                    }
                }
            },
            An = En.registerPlugin({
                name: "attr",
                init: function (t, e, n, i, r) {
                    var s, o, a;
                    for (s in this.tween = n, e) a = t.getAttribute(s) || "", (o = this.add(t, "setAttribute", (a || 0) + "", e[s], i, r, 0, 0, s)).op = s, o.b = a, this._props.push(s)
                },
                render: function (t, e) {
                    for (var n = e._pt; n;) p ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), n = n._next
                }
            }, {
                name: "endArray",
                init: function (t, e) {
                    for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
                }
            }, Cn("roundProps", ue), Cn("modifiers"), Cn("snap", ce)) || En;
        en.version = Ge.version = An.version = "3.12.5", _ = 1, B() && Pe(), Le.Power0, Le.Power1, Le.Power2, Le.Power3, Le.Power4, Le.Linear, Le.Quad, Le.Cubic, Le.Quart, Le.Quint, Le.Strong, Le.Elastic, Le.Back, Le.SteppedEase, Le.Bounce, Le.Sine, Le.Expo, Le.Circ;
        var Pn, Ln, Rn, kn, On, In, Fn, Nn, zn = {},
            Un = 180 / Math.PI,
            Bn = Math.PI / 180,
            jn = Math.atan2,
            Hn = /([A-Z])/g,
            Vn = /(left|right|width|margin|padding|x)/i,
            Gn = /[\s,\(]\S/,
            Wn = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            $n = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            Xn = function (t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            },
            qn = function (t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            },
            Yn = function (t, e) {
                var n = e.s + e.c * t;
                e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
            },
            Kn = function (t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            },
            Jn = function (t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            },
            Zn = function (t, e, n) {
                return t.style[e] = n
            },
            Qn = function (t, e, n) {
                return t.style.setProperty(e, n)
            },
            ti = function (t, e, n) {
                return t._gsap[e] = n
            },
            ei = function (t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            },
            ni = function (t, e, n, i, r) {
                var s = t._gsap;
                s.scaleX = s.scaleY = n, s.renderTransform(r, s)
            },
            ii = function (t, e, n, i, r) {
                var s = t._gsap;
                s[e] = n, s.renderTransform(r, s)
            },
            ri = "transform",
            si = ri + "Origin",
            oi = function t(e, n) {
                var i = this,
                    r = this.target,
                    s = r.style,
                    o = r._gsap;
                if (e in zn && s) {
                    if (this.tfm = this.tfm || {}, "transform" === e) return Wn.transform.split(",").forEach((function (e) {
                        return t.call(i, e, n)
                    }));
                    if (~(e = Wn[e] || e).indexOf(",") ? e.split(",").forEach((function (t) {
                        return i.tfm[t] = Si(r, t)
                    })) : this.tfm[e] = o.x ? o[e] : Si(r, e), e === si && (this.tfm.zOrigin = o.zOrigin), this.props.indexOf(ri) >= 0) return;
                    o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(si, n, "")), e = ri
                } (s || n) && this.props.push(e, n, s[e])
            },
            ai = function (t) {
                t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
            },
            li = function () {
                var t, e, n = this.props,
                    i = this.target,
                    r = i.style,
                    s = i._gsap;
                for (t = 0; t < n.length; t += 3) n[t + 1] ? i[n[t]] = n[t + 2] : n[t + 2] ? r[n[t]] = n[t + 2] : r.removeProperty("--" === n[t].substr(0, 2) ? n[t] : n[t].replace(Hn, "-$1").toLowerCase());
                if (this.tfm) {
                    for (e in this.tfm) s[e] = this.tfm[e];
                    s.svg && (s.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (t = Fn()) && t.isStart || r[ri] || (ai(r), s.zOrigin && r[si] && (r[si] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1)
                }
            },
            ui = function (t, e) {
                var n = {
                    target: t,
                    props: [],
                    revert: li,
                    save: oi
                };
                return t._gsap || An.core.getCache(t), e && e.split(",").forEach((function (t) {
                    return n.save(t)
                })), n
            },
            ci = function (t, e) {
                var n = Ln.createElementNS ? Ln.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Ln.createElement(t);
                return n && n.style ? n : Ln.createElement(t)
            },
            hi = function t(e, n, i) {
                var r = getComputedStyle(e);
                return r[n] || r.getPropertyValue(n.replace(Hn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, fi(n) || n, 1) || ""
            },
            di = "O,Moz,ms,Ms,Webkit".split(","),
            fi = function (t, e, n) {
                var i = (e || On).style,
                    r = 5;
                if (t in i && !n) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(di[r] + t in i););
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? di[r] : "") + t
            },
            pi = function () {
                "undefined" != typeof window && window.document && (Pn = window, Ln = Pn.document, Rn = Ln.documentElement, On = ci("div") || {
                    style: {}
                }, ci("div"), ri = fi(ri), si = ri + "Origin", On.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Nn = !!fi("perspective"), Fn = An.core.reverting, kn = 1)
            },
            mi = function t(e) {
                var n, i = ci("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode,
                    s = this.nextSibling,
                    o = this.style.cssText;
                if (Rn.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) { } else this._gsapBBox && (n = this._gsapBBox());
                return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), Rn.removeChild(i), this.style.cssText = o, n
            },
            gi = function (t, e) {
                for (var n = e.length; n--;)
                    if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            },
            vi = function (t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = mi.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === mi || (e = mi.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +gi(t, ["x", "cx", "x1"]) || 0,
                    y: +gi(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            yi = function (t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !vi(t))
            },
            bi = function (t, e) {
                if (e) {
                    var n, i = t.style;
                    e in zn && e !== si && (e = ri), i.removeProperty ? ("ms" !== (n = e.substr(0, 2)) && "webkit" !== e.substr(0, 6) || (e = "-" + e), i.removeProperty("--" === n ? e : e.replace(Hn, "-$1").toLowerCase())) : i.removeAttribute(e)
                }
            },
            _i = function (t, e, n, i, r, s) {
                var o = new gn(t._pt, e, n, 0, 1, s ? Jn : Kn);
                return t._pt = o, o.b = i, o.e = r, t._props.push(n), o
            },
            xi = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            wi = {
                grid: 1,
                flex: 1
            },
            Mi = function t(e, n, i, r) {
                var s, o, a, l, u = parseFloat(i) || 0,
                    c = (i + "").trim().substr((u + "").length) || "px",
                    h = On.style,
                    d = Vn.test(n),
                    f = "svg" === e.tagName.toLowerCase(),
                    p = (f ? "client" : "offset") + (d ? "Width" : "Height"),
                    m = 100,
                    g = "px" === r,
                    v = "%" === r;
                if (r === c || !u || xi[r] || xi[c]) return u;
                if ("px" !== c && !g && (u = t(e, n, i, "px")), l = e.getCTM && yi(e), (v || "%" === c) && (zn[n] || ~n.indexOf("adius"))) return s = l ? e.getBBox()[d ? "width" : "height"] : e[p], bt(v ? u / s * m : u / 100 * s);
                if (h[d ? "width" : "height"] = m + (g ? c : r), o = ~n.indexOf("adius") || "em" === r && e.appendChild && !f ? e : e.parentNode, l && (o = (e.ownerSVGElement || {}).parentNode), o && o !== Ln && o.appendChild || (o = Ln.body), (a = o._gsap) && v && a.width && d && a.time === Ae.time && !a.uncache) return bt(u / a.width * m);
                if (!v || "height" !== n && "width" !== n) (v || "%" === c) && !wi[hi(o, "display")] && (h.position = hi(e, "position")), o === e && (h.position = "static"), o.appendChild(On), s = On[p], o.removeChild(On), h.position = "absolute";
                else {
                    var y = e.style[n];
                    e.style[n] = m + r, s = e[p], y ? e.style[n] = y : bi(e, n)
                }
                return d && v && ((a = gt(o)).time = Ae.time, a.width = o[p]), bt(g ? s * u / m : s && u ? m / s * u : 0)
            },
            Si = function (t, e, n, i) {
                var r;
                return kn || pi(), e in Wn && "transform" !== e && ~(e = Wn[e]).indexOf(",") && (e = e.split(",")[0]), zn[e] && "transform" !== e ? (r = Ii(t, i), r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : Fi(hi(t, si)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Ci[e] && Ci[e](t, e, n) || hi(t, e) || vt(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? Mi(t, e, r, n) + n : r
            },
            Ti = function (t, e, n, i) {
                if (!n || "none" === n) {
                    var r = fi(e, t, 1),
                        s = r && hi(t, r, 1);
                    s && s !== n ? (e = r, n = s) : "borderColor" === e && (n = hi(t, "borderTopColor"))
                }
                var o, a, l, u, c, h, d, f, p, m, g, v = new gn(this._pt, t.style, e, 0, 1, cn),
                    y = 0,
                    b = 0;
                if (v.b = n, v.e = i, n += "", "auto" == (i += "") && (h = t.style[e], t.style[e] = i, i = hi(t, e) || i, h ? t.style[e] = h : bi(t, e)), Ce(o = [n, i]), i = o[1], l = (n = o[0]).match($) || [], (i.match($) || []).length) {
                    for (; a = $.exec(i);) d = a[0], p = i.substring(y, a.index), c ? c = (c + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (c = 1), d !== (h = l[b++] || "") && (u = parseFloat(h) || 0, g = h.substr((u + "").length), "=" === d.charAt(1) && (d = xt(u, d) + g), f = parseFloat(d), m = d.substr((f + "").length), y = $.lastIndex - m.length, m || (m = m || S.units[e] || g, y === i.length && (i += m, v.e += m)), g !== m && (u = Mi(t, e, h, m) || 0), v._pt = {
                        _next: v._pt,
                        p: p || 1 === b ? p : ",",
                        s: u,
                        c: f - u,
                        m: c && c < 4 || "zIndex" === e ? Math.round : 0
                    });
                    v.c = y < i.length ? i.substring(y, i.length) : ""
                } else v.r = "display" === e && "none" === i ? Jn : Kn;
                return q.test(i) && (v.e = 0), this._pt = v, v
            },
            Ei = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            Di = function (t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var n, i, r, s = e.t,
                        o = s.style,
                        a = e.u,
                        l = s._gsap;
                    if ("all" === a || !0 === a) o.cssText = "", i = 1;
                    else
                        for (r = (a = a.split(",")).length; --r > -1;) n = a[r], zn[n] && (i = 1, n = "transformOrigin" === n ? si : ri), bi(s, n);
                    i && (bi(s, ri), l && (l.svg && s.removeAttribute("transform"), Ii(s, 1), l.uncache = 1, ai(o)))
                }
            },
            Ci = {
                clearProps: function (t, e, n, i, r) {
                    if ("isFromStart" !== r.data) {
                        var s = t._pt = new gn(t._pt, e, n, 0, 0, Di);
                        return s.u = i, s.pr = -10, s.tween = r, t._props.push(n), 1
                    }
                }
            },
            Ai = [1, 0, 0, 1, 0, 0],
            Pi = {},
            Li = function (t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            },
            Ri = function (t) {
                var e = hi(t, ri);
                return Li(e) ? Ai : e.substr(7).match(W).map(bt)
            },
            ki = function (t, e) {
                var n, i, r, s, o = t._gsap || gt(t),
                    a = t.style,
                    l = Ri(t);
                return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Ai : l : (l !== Ai || t.offsetParent || t === Rn || o.svg || (r = a.display, a.display = "block", (n = t.parentNode) && t.offsetParent || (s = 1, i = t.nextElementSibling, Rn.appendChild(t)), l = Ri(t), r ? a.display = r : bi(t, "display"), s && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : Rn.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            },
            Oi = function (t, e, n, i, r, s) {
                var o, a, l, u = t._gsap,
                    c = r || ki(t, !0),
                    h = u.xOrigin || 0,
                    d = u.yOrigin || 0,
                    f = u.xOffset || 0,
                    p = u.yOffset || 0,
                    m = c[0],
                    g = c[1],
                    v = c[2],
                    y = c[3],
                    b = c[4],
                    _ = c[5],
                    x = e.split(" "),
                    w = parseFloat(x[0]) || 0,
                    M = parseFloat(x[1]) || 0;
                n ? c !== Ai && (a = m * y - g * v) && (l = w * (-g / a) + M * (m / a) - (m * _ - g * b) / a, w = w * (y / a) + M * (-v / a) + (v * _ - y * b) / a, M = l) : (w = (o = vi(t)).x + (~x[0].indexOf("%") ? w / 100 * o.width : w), M = o.y + (~(x[1] || x[0]).indexOf("%") ? M / 100 * o.height : M)), i || !1 !== i && u.smooth ? (b = w - h, _ = M - d, u.xOffset = f + (b * m + _ * v) - b, u.yOffset = p + (b * g + _ * y) - _) : u.xOffset = u.yOffset = 0, u.xOrigin = w, u.yOrigin = M, u.smooth = !!i, u.origin = e, u.originIsAbsolute = !!n, t.style[si] = "0px 0px", s && (_i(s, u, "xOrigin", h, w), _i(s, u, "yOrigin", d, M), _i(s, u, "xOffset", f, u.xOffset), _i(s, u, "yOffset", p, u.yOffset)), t.setAttribute("data-svg-origin", w + " " + M)
            },
            Ii = function (t, e) {
                var n = t._gsap || new He(t);
                if ("x" in n && !e && !n.uncache) return n;
                var i, r, s, o, a, l, u, c, h, d, f, p, m, g, v, y, b, _, x, w, M, T, E, D, C, A, P, L, R, k, O, I, F = t.style,
                    N = n.scaleX < 0,
                    z = "px",
                    U = "deg",
                    B = getComputedStyle(t),
                    j = hi(t, si) || "0";
                return i = r = s = l = u = c = h = d = f = 0, o = a = 1, n.svg = !(!t.getCTM || !yi(t)), B.translate && ("none" === B.translate && "none" === B.scale && "none" === B.rotate || (F[ri] = ("none" !== B.translate ? "translate3d(" + (B.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== B.rotate ? "rotate(" + B.rotate + ") " : "") + ("none" !== B.scale ? "scale(" + B.scale.split(" ").join(",") + ") " : "") + ("none" !== B[ri] ? B[ri] : "")), F.scale = F.rotate = F.translate = "none"), g = ki(t, n.svg), n.svg && (n.uncache ? (C = t.getBBox(), j = n.xOrigin - C.x + "px " + (n.yOrigin - C.y) + "px", D = "") : D = !e && t.getAttribute("data-svg-origin"), Oi(t, D || j, !!D || n.originIsAbsolute, !1 !== n.smooth, g)), p = n.xOrigin || 0, m = n.yOrigin || 0, g !== Ai && (_ = g[0], x = g[1], w = g[2], M = g[3], i = T = g[4], r = E = g[5], 6 === g.length ? (o = Math.sqrt(_ * _ + x * x), a = Math.sqrt(M * M + w * w), l = _ || x ? jn(x, _) * Un : 0, (h = w || M ? jn(w, M) * Un + l : 0) && (a *= Math.abs(Math.cos(h * Bn))), n.svg && (i -= p - (p * _ + m * w), r -= m - (p * x + m * M))) : (I = g[6], k = g[7], P = g[8], L = g[9], R = g[10], O = g[11], i = g[12], r = g[13], s = g[14], u = (v = jn(I, R)) * Un, v && (D = T * (y = Math.cos(-v)) + P * (b = Math.sin(-v)), C = E * y + L * b, A = I * y + R * b, P = T * -b + P * y, L = E * -b + L * y, R = I * -b + R * y, O = k * -b + O * y, T = D, E = C, I = A), c = (v = jn(-w, R)) * Un, v && (y = Math.cos(-v), O = M * (b = Math.sin(-v)) + O * y, _ = D = _ * y - P * b, x = C = x * y - L * b, w = A = w * y - R * b), l = (v = jn(x, _)) * Un, v && (D = _ * (y = Math.cos(v)) + x * (b = Math.sin(v)), C = T * y + E * b, x = x * y - _ * b, E = E * y - T * b, _ = D, T = C), u && Math.abs(u) + Math.abs(l) > 359.9 && (u = l = 0, c = 180 - c), o = bt(Math.sqrt(_ * _ + x * x + w * w)), a = bt(Math.sqrt(E * E + I * I)), v = jn(T, E), h = Math.abs(v) > 2e-4 ? v * Un : 0, f = O ? 1 / (O < 0 ? -O : O) : 0), n.svg && (D = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Li(hi(t, ri)), D && t.setAttribute("transform", D))), Math.abs(h) > 90 && Math.abs(h) < 270 && (N ? (o *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), e = e || n.uncache, n.x = i - ((n.xPercent = i && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + z, n.y = r - ((n.yPercent = r && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + z, n.z = s + z, n.scaleX = bt(o), n.scaleY = bt(a), n.rotation = bt(l) + U, n.rotationX = bt(u) + U, n.rotationY = bt(c) + U, n.skewX = h + U, n.skewY = d + U, n.transformPerspective = f + z, (n.zOrigin = parseFloat(j.split(" ")[2]) || !e && n.zOrigin || 0) && (F[si] = Fi(j)), n.xOffset = n.yOffset = 0, n.force3D = S.force3D, n.renderTransform = n.svg ? Vi : Nn ? Hi : zi, n.uncache = 0, n
            },
            Fi = function (t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            Ni = function (t, e, n) {
                var i = ne(e);
                return bt(parseFloat(e) + parseFloat(Mi(t, "x", n + "px", i))) + i
            },
            zi = function (t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Hi(t, e)
            },
            Ui = "0deg",
            Bi = "0px",
            ji = ") ",
            Hi = function (t, e) {
                var n = e || this,
                    i = n.xPercent,
                    r = n.yPercent,
                    s = n.x,
                    o = n.y,
                    a = n.z,
                    l = n.rotation,
                    u = n.rotationY,
                    c = n.rotationX,
                    h = n.skewX,
                    d = n.skewY,
                    f = n.scaleX,
                    p = n.scaleY,
                    m = n.transformPerspective,
                    g = n.force3D,
                    v = n.target,
                    y = n.zOrigin,
                    b = "",
                    _ = "auto" === g && t && 1 !== t || !0 === g;
                if (y && (c !== Ui || u !== Ui)) {
                    var x, w = parseFloat(u) * Bn,
                        M = Math.sin(w),
                        S = Math.cos(w);
                    w = parseFloat(c) * Bn, x = Math.cos(w), s = Ni(v, s, M * x * -y), o = Ni(v, o, -Math.sin(w) * -y), a = Ni(v, a, S * x * -y + y)
                }
                m !== Bi && (b += "perspective(" + m + ji), (i || r) && (b += "translate(" + i + "%, " + r + "%) "), (_ || s !== Bi || o !== Bi || a !== Bi) && (b += a !== Bi || _ ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + ji), l !== Ui && (b += "rotate(" + l + ji), u !== Ui && (b += "rotateY(" + u + ji), c !== Ui && (b += "rotateX(" + c + ji), h === Ui && d === Ui || (b += "skew(" + h + ", " + d + ji), 1 === f && 1 === p || (b += "scale(" + f + ", " + p + ji), v.style[ri] = b || "translate(0, 0)"
            },
            Vi = function (t, e) {
                var n, i, r, s, o, a = e || this,
                    l = a.xPercent,
                    u = a.yPercent,
                    c = a.x,
                    h = a.y,
                    d = a.rotation,
                    f = a.skewX,
                    p = a.skewY,
                    m = a.scaleX,
                    g = a.scaleY,
                    v = a.target,
                    y = a.xOrigin,
                    b = a.yOrigin,
                    _ = a.xOffset,
                    x = a.yOffset,
                    w = a.forceCSS,
                    M = parseFloat(c),
                    S = parseFloat(h);
                d = parseFloat(d), f = parseFloat(f), (p = parseFloat(p)) && (f += p = parseFloat(p), d += p), d || f ? (d *= Bn, f *= Bn, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - f) * -g, s = Math.cos(d - f) * g, f && (p *= Bn, o = Math.tan(f - p), r *= o = Math.sqrt(1 + o * o), s *= o, p && (o = Math.tan(p), n *= o = Math.sqrt(1 + o * o), i *= o)), n = bt(n), i = bt(i), r = bt(r), s = bt(s)) : (n = m, s = g, i = r = 0), (M && !~(c + "").indexOf("px") || S && !~(h + "").indexOf("px")) && (M = Mi(v, "x", c, "px"), S = Mi(v, "y", h, "px")), (y || b || _ || x) && (M = bt(M + y - (y * n + b * r) + _), S = bt(S + b - (y * i + b * s) + x)), (l || u) && (o = v.getBBox(), M = bt(M + l / 100 * o.width), S = bt(S + u / 100 * o.height)), o = "matrix(" + n + "," + i + "," + r + "," + s + "," + M + "," + S + ")", v.setAttribute("transform", o), w && (v.style[ri] = o)
            },
            Gi = function (t, e, n, i, r) {
                var s, o, a = 360,
                    l = O(r),
                    u = parseFloat(r) * (l && ~r.indexOf("rad") ? Un : 1) - i,
                    c = i + u + "deg";
                return l && ("short" === (s = r.split("_")[1]) && (u %= a) != u % 180 && (u += u < 0 ? a : -360), "cw" === s && u < 0 ? u = (u + 36e9) % a - ~~(u / a) * a : "ccw" === s && u > 0 && (u = (u - 36e9) % a - ~~(u / a) * a)), t._pt = o = new gn(t._pt, e, n, i, u, Xn), o.e = c, o.u = "deg", t._props.push(n), o
            },
            Wi = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            },
            $i = function (t, e, n) {
                var i, r, s, o, a, l, u, c = Wi({}, n._gsap),
                    h = n.style;
                for (r in c.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), h[ri] = e, i = Ii(n, 1), bi(n, ri), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[ri], h[ri] = e, i = Ii(n, 1), h[ri] = s), zn) (s = c[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = ne(s) !== (u = ne(o)) ? Mi(n, r, s, u) : parseFloat(s), l = parseFloat(o), t._pt = new gn(t._pt, i, r, a, l - a, $n), t._pt.u = u || 0, t._props.push(r));
                Wi(i, c)
            };
        yt("padding,margin,Width,Radius", (function (t, e) {
            var n = "Top",
                i = "Right",
                r = "Bottom",
                s = "Left",
                o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            Ci[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
                var s, a;
                if (arguments.length < 4) return s = o.map((function (e) {
                    return Si(t, e, n)
                })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
                s = (i + "").split(" "), a = {}, o.forEach((function (t, e) {
                    return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                })), t.init(e, a, r)
            }
        }));
        var Xi, qi, Yi = {
            name: "css",
            register: pi,
            targetTest: function (t) {
                return t.style && t.nodeType
            },
            init: function (t, e, n, i, r) {
                var s, o, a, l, u, c, h, d, f, p, m, g, v, y, b, _, x, w, M, T, E = this._props,
                    D = t.style,
                    C = n.vars.startAt;
                for (h in kn || pi(), this.styles = this.styles || ui(t), _ = this.styles.props, this.tween = n, e)
                    if ("autoRound" !== h && (o = e[h], !ct[h] || !Ye(h, e, n, i, t, r)))
                        if (u = typeof o, c = Ci[h], "function" === u && (u = typeof (o = o.call(n, i, t, r))), "string" === u && ~o.indexOf("random(") && (o = fe(o)), c) c(this, t, h, o, n) && (b = 1);
                        else if ("--" === h.substr(0, 2)) s = (getComputedStyle(t).getPropertyValue(h) + "").trim(), o += "", Ee.lastIndex = 0, Ee.test(s) || (d = ne(s), f = ne(o)), f ? d !== f && (s = Mi(t, h, s, f) + f) : d && (o += d), this.add(D, "setProperty", s, o, i, r, 0, 0, h), E.push(h), _.push(h, 0, D[h]);
                        else if ("undefined" !== u) {
                            if (C && h in C ? (s = "function" == typeof C[h] ? C[h].call(n, i, t, r) : C[h], O(s) && ~s.indexOf("random(") && (s = fe(s)), ne(s + "") || "auto" === s || (s += S.units[h] || ne(Si(t, h)) || ""), "=" === (s + "").charAt(1) && (s = Si(t, h))) : s = Si(t, h), l = parseFloat(s), (p = "string" === u && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), a = parseFloat(o), h in Wn && ("autoAlpha" === h && (1 === l && "hidden" === Si(t, "visibility") && a && (l = 0), _.push("visibility", 0, D.visibility), _i(this, D, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== h && "transform" !== h && ~(h = Wn[h]).indexOf(",") && (h = h.split(",")[0])), m = h in zn)
                                if (this.styles.save(h), g || ((v = t._gsap).renderTransform && !e.parseTransform || Ii(t, e.parseTransform), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new gn(this._pt, D, ri, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new gn(this._pt, v, "scaleY", v.scaleY, (p ? xt(v.scaleY, p + a) : a) - v.scaleY || 0, $n), this._pt.u = 0, E.push("scaleY", h), h += "X";
                                else {
                                    if ("transformOrigin" === h) {
                                        _.push(si, 0, D[si]), w = void 0, M = void 0, T = void 0, M = (w = (x = o).split(" "))[0], T = w[1] || "50%", "top" !== M && "bottom" !== M && "left" !== T && "right" !== T || (x = M, M = T, T = x), w[0] = Ei[M] || M, w[1] = Ei[T] || T, o = w.join(" "), v.svg ? Oi(t, o, 0, y, 0, this) : ((f = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && _i(this, v, "zOrigin", v.zOrigin, f), _i(this, D, h, Fi(s), Fi(o)));
                                        continue
                                    }
                                    if ("svgOrigin" === h) {
                                        Oi(t, o, 1, y, 0, this);
                                        continue
                                    }
                                    if (h in Pi) {
                                        Gi(this, v, h, l, p ? xt(l, p + o) : o);
                                        continue
                                    }
                                    if ("smoothOrigin" === h) {
                                        _i(this, v, "smooth", v.smooth, o);
                                        continue
                                    }
                                    if ("force3D" === h) {
                                        v[h] = o;
                                        continue
                                    }
                                    if ("transform" === h) {
                                        $i(this, o, t);
                                        continue
                                    }
                                }
                            else h in D || (h = fi(h) || h);
                            if (m || (a || 0 === a) && (l || 0 === l) && !Gn.test(o) && h in D) a || (a = 0), (d = (s + "").substr((l + "").length)) !== (f = ne(o) || (h in S.units ? S.units[h] : d)) && (l = Mi(t, h, s, f)), this._pt = new gn(this._pt, m ? v : D, h, l, (p ? xt(l, p + a) : a) - l, m || "px" !== f && "zIndex" !== h || !1 === e.autoRound ? $n : Yn), this._pt.u = f || 0, d !== f && "%" !== f && (this._pt.b = s, this._pt.r = qn);
                            else if (h in D) Ti.call(this, t, h, s, p ? p + o : o);
                            else if (h in t) this.add(t, h, s || t[h], p ? p + o : o, i, r);
                            else if ("parseTransform" !== h) {
                                tt(h, o);
                                continue
                            }
                            m || (h in D ? _.push(h, 0, D[h]) : _.push(h, 1, s || t[h])), E.push(h)
                        }
                b && mn(this)
            },
            render: function (t, e) {
                if (e.tween._time || !Fn())
                    for (var n = e._pt; n;) n.r(t, n.d), n = n._next;
                else e.styles.revert()
            },
            get: Si,
            aliases: Wn,
            getSetter: function (t, e, n) {
                var i = Wn[e];
                return i && i.indexOf(",") < 0 && (e = i), e in zn && e !== si && (t._gsap.x || Si(t, "x")) ? n && In === n ? "scale" === e ? ei : ti : (In = n || {}) && ("scale" === e ? ni : ii) : t.style && !N(t.style[e]) ? Zn : ~e.indexOf("-") ? Qn : an(t, e)
            },
            core: {
                _removeProperty: bi,
                _getMatrix: ki
            }
        };
        An.utils.checkPrefix = fi, An.core.getStyleSaver = ui, qi = yt("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (Xi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
            zn[t] = 1
        })), yt(Xi, (function (t) {
            S.units[t] = "deg", Pi[t] = 1
        })), Wn[qi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Xi, yt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
            var e = t.split(":");
            Wn[e[1]] = qi[e[0]]
        })), yt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
            S.units[t] = "px"
        })), An.registerPlugin(Yi);
        var Ki = An.registerPlugin(Yi) || An;

        function Ji(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }
        Ki.core.Tween;
        var Zi, Qi, tr, er, nr, ir, rr, sr, or, ar, lr, ur, cr, hr = function () {
            return Zi || "undefined" != typeof window && (Zi = window.gsap) && Zi.registerPlugin && Zi
        },
            dr = 1,
            fr = [],
            pr = [],
            mr = [],
            gr = Date.now,
            vr = function (t, e) {
                return e
            },
            yr = function (t, e) {
                return ~mr.indexOf(t) && mr[mr.indexOf(t) + 1][e]
            },
            br = function (t) {
                return !!~ar.indexOf(t)
            },
            _r = function (t, e, n, i, r) {
                return t.addEventListener(e, n, {
                    passive: !1 !== i,
                    capture: !!r
                })
            },
            xr = function (t, e, n, i) {
                return t.removeEventListener(e, n, !!i)
            },
            wr = "scrollLeft",
            Mr = "scrollTop",
            Sr = function () {
                return lr && lr.isPressed || pr.cache++
            },
            Tr = function (t, e) {
                var n = function n(i) {
                    if (i || 0 === i) {
                        dr && (tr.history.scrollRestoration = "manual");
                        var r = lr && lr.isPressed;
                        i = n.v = Math.round(i) || (lr && lr.iOS ? 1 : 0), t(i), n.cacheID = pr.cache, r && vr("ss", i)
                    } else (e || pr.cache !== n.cacheID || vr("ref")) && (n.cacheID = pr.cache, n.v = t());
                    return n.v + n.offset
                };
                return n.offset = 0, t && n
            },
            Er = {
                s: wr,
                p: "left",
                p2: "Left",
                os: "right",
                os2: "Right",
                d: "width",
                d2: "Width",
                a: "x",
                sc: Tr((function (t) {
                    return arguments.length ? tr.scrollTo(t, Dr.sc()) : tr.pageXOffset || er[wr] || nr[wr] || ir[wr] || 0
                }))
            },
            Dr = {
                s: Mr,
                p: "top",
                p2: "Top",
                os: "bottom",
                os2: "Bottom",
                d: "height",
                d2: "Height",
                a: "y",
                op: Er,
                sc: Tr((function (t) {
                    return arguments.length ? tr.scrollTo(Er.sc(), t) : tr.pageYOffset || er[Mr] || nr[Mr] || ir[Mr] || 0
                }))
            },
            Cr = function (t, e) {
                return (e && e._ctx && e._ctx.selector || Zi.utils.toArray)(t)[0] || ("string" == typeof t && !1 !== Zi.config().nullTargetWarn ? console.warn("Element not found:", t) : null)
            },
            Ar = function (t, e) {
                var n = e.s,
                    i = e.sc;
                br(t) && (t = er.scrollingElement || nr);
                var r = pr.indexOf(t),
                    s = i === Dr.sc ? 1 : 2;
                !~r && (r = pr.push(t) - 1), pr[r + s] || _r(t, "scroll", Sr);
                var o = pr[r + s],
                    a = o || (pr[r + s] = Tr(yr(t, n), !0) || (br(t) ? i : Tr((function (e) {
                        return arguments.length ? t[n] = e : t[n]
                    }))));
                return a.target = t, o || (a.smooth = "smooth" === Zi.getProperty(t, "scrollBehavior")), a
            },
            Pr = function (t, e, n) {
                var i = t,
                    r = t,
                    s = gr(),
                    o = s,
                    a = e || 50,
                    l = Math.max(500, 3 * a),
                    u = function (t, e) {
                        var l = gr();
                        e || l - s > a ? (r = i, i = t, o = s, s = l) : n ? i += t : i = r + (t - r) / (l - o) * (s - o)
                    };
                return {
                    update: u,
                    reset: function () {
                        r = i = n ? 0 : i, o = s = 0
                    },
                    getVelocity: function (t) {
                        var e = o,
                            a = r,
                            c = gr();
                        return (t || 0 === t) && t !== i && u(t), s === o || c - o > l ? 0 : (i + (n ? a : -a)) / ((n ? c : s) - e) * 1e3
                    }
                }
            },
            Lr = function (t, e) {
                return e && !t._gsapAllow && t.preventDefault(), t.changedTouches ? t.changedTouches[0] : t
            },
            Rr = function (t) {
                var e = Math.max.apply(Math, t),
                    n = Math.min.apply(Math, t);
                return Math.abs(e) >= Math.abs(n) ? e : n
            },
            kr = function () {
                var t, e, n, i;
                (or = Zi.core.globals().ScrollTrigger) && or.core && (t = or.core, e = t.bridge || {}, n = t._scrollers, i = t._proxies, n.push.apply(n, pr), i.push.apply(i, mr), pr = n, mr = i, vr = function (t, n) {
                    return e[t](n)
                })
            },
            Or = function (t) {
                return Zi = t || hr(), !Qi && Zi && "undefined" != typeof document && document.body && (tr = window, er = document, nr = er.documentElement, ir = er.body, ar = [tr, er, nr, ir], Zi.utils.clamp, cr = Zi.core.context || function () { }, sr = "onpointerenter" in ir ? "pointer" : "mouse", rr = Ir.isTouch = tr.matchMedia && tr.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in tr || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, ur = Ir.eventTypes = ("ontouchstart" in nr ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in nr ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function () {
                    return dr = 0
                }), 500), kr(), Qi = 1), Qi
            };
        Er.op = Dr, pr.cache = 0;
        var Ir = function () {
            function t(t) {
                this.init(t)
            }
            var e, n;
            return t.prototype.init = function (t) {
                Qi || Or(Zi) || console.warn("Please gsap.registerPlugin(Observer)"), or || kr();
                var e = t.tolerance,
                    n = t.dragMinimum,
                    i = t.type,
                    r = t.target,
                    s = t.lineHeight,
                    o = t.debounce,
                    a = t.preventDefault,
                    l = t.onStop,
                    u = t.onStopDelay,
                    c = t.ignore,
                    h = t.wheelSpeed,
                    d = t.event,
                    f = t.onDragStart,
                    p = t.onDragEnd,
                    m = t.onDrag,
                    g = t.onPress,
                    v = t.onRelease,
                    y = t.onRight,
                    b = t.onLeft,
                    _ = t.onUp,
                    x = t.onDown,
                    w = t.onChangeX,
                    M = t.onChangeY,
                    S = t.onChange,
                    T = t.onToggleX,
                    E = t.onToggleY,
                    D = t.onHover,
                    C = t.onHoverEnd,
                    A = t.onMove,
                    P = t.ignoreCheck,
                    L = t.isNormalizer,
                    R = t.onGestureStart,
                    k = t.onGestureEnd,
                    O = t.onWheel,
                    I = t.onEnable,
                    F = t.onDisable,
                    N = t.onClick,
                    z = t.scrollSpeed,
                    U = t.capture,
                    B = t.allowClicks,
                    j = t.lockAxis,
                    H = t.onLockAxis;
                this.target = r = Cr(r) || nr, this.vars = t, c && (c = Zi.utils.toArray(c)), e = e || 1e-9, n = n || 0, h = h || 1, z = z || 1, i = i || "wheel,touch,pointer", o = !1 !== o, s || (s = parseFloat(tr.getComputedStyle(ir).lineHeight) || 22);
                var V, G, W, $, X, q, Y, K = this,
                    J = 0,
                    Z = 0,
                    Q = t.passive || !a,
                    tt = Ar(r, Er),
                    et = Ar(r, Dr),
                    nt = tt(),
                    it = et(),
                    rt = ~i.indexOf("touch") && !~i.indexOf("pointer") && "pointerdown" === ur[0],
                    st = br(r),
                    ot = r.ownerDocument || er,
                    at = [0, 0, 0],
                    lt = [0, 0, 0],
                    ut = 0,
                    ct = function () {
                        return ut = gr()
                    },
                    ht = function (t, e) {
                        return (K.event = t) && c && ~c.indexOf(t.target) || e && rt && "touch" !== t.pointerType || P && P(t, e)
                    },
                    dt = function () {
                        var t = K.deltaX = Rr(at),
                            n = K.deltaY = Rr(lt),
                            i = Math.abs(t) >= e,
                            r = Math.abs(n) >= e;
                        S && (i || r) && S(K, t, n, at, lt), i && (y && K.deltaX > 0 && y(K), b && K.deltaX < 0 && b(K), w && w(K), T && K.deltaX < 0 != J < 0 && T(K), J = K.deltaX, at[0] = at[1] = at[2] = 0), r && (x && K.deltaY > 0 && x(K), _ && K.deltaY < 0 && _(K), M && M(K), E && K.deltaY < 0 != Z < 0 && E(K), Z = K.deltaY, lt[0] = lt[1] = lt[2] = 0), ($ || W) && (A && A(K), W && (m(K), W = !1), $ = !1), q && !(q = !1) && H && H(K), X && (O(K), X = !1), V = 0
                    },
                    ft = function (t, e, n) {
                        at[n] += t, lt[n] += e, K._vx.update(t), K._vy.update(e), o ? V || (V = requestAnimationFrame(dt)) : dt()
                    },
                    pt = function (t, e) {
                        j && !Y && (K.axis = Y = Math.abs(t) > Math.abs(e) ? "x" : "y", q = !0), "y" !== Y && (at[2] += t, K._vx.update(t, !0)), "x" !== Y && (lt[2] += e, K._vy.update(e, !0)), o ? V || (V = requestAnimationFrame(dt)) : dt()
                    },
                    mt = function (t) {
                        if (!ht(t, 1)) {
                            var e = (t = Lr(t, a)).clientX,
                                i = t.clientY,
                                r = e - K.x,
                                s = i - K.y,
                                o = K.isDragging;
                            K.x = e, K.y = i, (o || Math.abs(K.startX - e) >= n || Math.abs(K.startY - i) >= n) && (m && (W = !0), o || (K.isDragging = !0), pt(r, s), o || f && f(K))
                        }
                    },
                    gt = K.onPress = function (t) {
                        ht(t, 1) || t && t.button || (K.axis = Y = null, G.pause(), K.isPressed = !0, t = Lr(t), J = Z = 0, K.startX = K.x = t.clientX, K.startY = K.y = t.clientY, K._vx.reset(), K._vy.reset(), _r(L ? r : ot, ur[1], mt, Q, !0), K.deltaX = K.deltaY = 0, g && g(K))
                    },
                    vt = K.onRelease = function (t) {
                        if (!ht(t, 1)) {
                            xr(L ? r : ot, ur[1], mt, !0);
                            var e = !isNaN(K.y - K.startY),
                                n = K.isDragging,
                                i = n && (Math.abs(K.x - K.startX) > 3 || Math.abs(K.y - K.startY) > 3),
                                s = Lr(t);
                            !i && e && (K._vx.reset(), K._vy.reset(), a && B && Zi.delayedCall(.08, (function () {
                                if (gr() - ut > 300 && !t.defaultPrevented)
                                    if (t.target.click) t.target.click();
                                    else if (ot.createEvent) {
                                        var e = ot.createEvent("MouseEvents");
                                        e.initMouseEvent("click", !0, !0, tr, 1, s.screenX, s.screenY, s.clientX, s.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e)
                                    }
                            }))), K.isDragging = K.isGesturing = K.isPressed = !1, l && n && !L && G.restart(!0), p && n && p(K), v && v(K, i)
                        }
                    },
                    yt = function (t) {
                        return t.touches && t.touches.length > 1 && (K.isGesturing = !0) && R(t, K.isDragging)
                    },
                    bt = function () {
                        return (K.isGesturing = !1) || k(K)
                    },
                    _t = function (t) {
                        if (!ht(t)) {
                            var e = tt(),
                                n = et();
                            ft((e - nt) * z, (n - it) * z, 1), nt = e, it = n, l && G.restart(!0)
                        }
                    },
                    xt = function (t) {
                        if (!ht(t)) {
                            t = Lr(t, a), O && (X = !0);
                            var e = (1 === t.deltaMode ? s : 2 === t.deltaMode ? tr.innerHeight : 1) * h;
                            ft(t.deltaX * e, t.deltaY * e, 0), l && !L && G.restart(!0)
                        }
                    },
                    wt = function (t) {
                        if (!ht(t)) {
                            var e = t.clientX,
                                n = t.clientY,
                                i = e - K.x,
                                r = n - K.y;
                            K.x = e, K.y = n, $ = !0, l && G.restart(!0), (i || r) && pt(i, r)
                        }
                    },
                    Mt = function (t) {
                        K.event = t, D(K)
                    },
                    St = function (t) {
                        K.event = t, C(K)
                    },
                    Tt = function (t) {
                        return ht(t) || Lr(t, a) && N(K)
                    };
                G = K._dc = Zi.delayedCall(u || .25, (function () {
                    K._vx.reset(), K._vy.reset(), G.pause(), l && l(K)
                })).pause(), K.deltaX = K.deltaY = 0, K._vx = Pr(0, 50, !0), K._vy = Pr(0, 50, !0), K.scrollX = tt, K.scrollY = et, K.isDragging = K.isGesturing = K.isPressed = !1, cr(this), K.enable = function (t) {
                    return K.isEnabled || (_r(st ? ot : r, "scroll", Sr), i.indexOf("scroll") >= 0 && _r(st ? ot : r, "scroll", _t, Q, U), i.indexOf("wheel") >= 0 && _r(r, "wheel", xt, Q, U), (i.indexOf("touch") >= 0 && rr || i.indexOf("pointer") >= 0) && (_r(r, ur[0], gt, Q, U), _r(ot, ur[2], vt), _r(ot, ur[3], vt), B && _r(r, "click", ct, !0, !0), N && _r(r, "click", Tt), R && _r(ot, "gesturestart", yt), k && _r(ot, "gestureend", bt), D && _r(r, sr + "enter", Mt), C && _r(r, sr + "leave", St), A && _r(r, sr + "move", wt)), K.isEnabled = !0, t && t.type && gt(t), I && I(K)), K
                }, K.disable = function () {
                    K.isEnabled && (fr.filter((function (t) {
                        return t !== K && br(t.target)
                    })).length || xr(st ? ot : r, "scroll", Sr), K.isPressed && (K._vx.reset(), K._vy.reset(), xr(L ? r : ot, ur[1], mt, !0)), xr(st ? ot : r, "scroll", _t, U), xr(r, "wheel", xt, U), xr(r, ur[0], gt, U), xr(ot, ur[2], vt), xr(ot, ur[3], vt), xr(r, "click", ct, !0), xr(r, "click", Tt), xr(ot, "gesturestart", yt), xr(ot, "gestureend", bt), xr(r, sr + "enter", Mt), xr(r, sr + "leave", St), xr(r, sr + "move", wt), K.isEnabled = K.isPressed = K.isDragging = !1, F && F(K))
                }, K.kill = K.revert = function () {
                    K.disable();
                    var t = fr.indexOf(K);
                    t >= 0 && fr.splice(t, 1), lr === K && (lr = 0)
                }, fr.push(K), L && br(r) && (lr = K), K.enable(d)
            }, e = t, (n = [{
                key: "velocityX",
                get: function () {
                    return this._vx.getVelocity()
                }
            }, {
                key: "velocityY",
                get: function () {
                    return this._vy.getVelocity()
                }
            }]) && Ji(e.prototype, n), t
        }();
        Ir.version = "3.12.5", Ir.create = function (t) {
            return new Ir(t)
        }, Ir.register = Or, Ir.getAll = function () {
            return fr.slice()
        }, Ir.getById = function (t) {
            return fr.filter((function (e) {
                return e.vars.id === t
            }))[0]
        }, hr() && Zi.registerPlugin(Ir);
        var Fr, Nr, zr, Ur, Br, jr, Hr, Vr, Gr, Wr, $r, Xr, qr, Yr, Kr, Jr, Zr, Qr, ts, es, ns, is, rs, ss, os, as, ls, us, cs, hs, ds, fs, ps, ms, gs, vs, ys, bs, _s = 1,
            xs = Date.now,
            ws = xs(),
            Ms = 0,
            Ss = 0,
            Ts = function (t, e, n) {
                var i = Us(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
                return n["_" + e + "Clamp"] = i, i ? t.substr(6, t.length - 7) : t
            },
            Es = function (t, e) {
                return !e || Us(t) && "clamp(" === t.substr(0, 6) ? t : "clamp(" + t + ")"
            },
            Ds = function t() {
                return Ss && requestAnimationFrame(t)
            },
            Cs = function () {
                return Yr = 1
            },
            As = function () {
                return Yr = 0
            },
            Ps = function (t) {
                return t
            },
            Ls = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            Rs = function () {
                return "undefined" != typeof window
            },
            ks = function () {
                return Fr || Rs() && (Fr = window.gsap) && Fr.registerPlugin && Fr
            },
            Os = function (t) {
                return !!~Hr.indexOf(t)
            },
            Is = function (t) {
                return ("Height" === t ? ds : zr["inner" + t]) || Br["client" + t] || jr["client" + t]
            },
            Fs = function (t) {
                return yr(t, "getBoundingClientRect") || (Os(t) ? function () {
                    return Ko.width = zr.innerWidth, Ko.height = ds, Ko
                } : function () {
                    return lo(t)
                })
            },
            Ns = function (t, e) {
                var n = e.s,
                    i = e.d2,
                    r = e.d,
                    s = e.a;
                return Math.max(0, (n = "scroll" + i) && (s = yr(t, n)) ? s() - Fs(t)()[r] : Os(t) ? (Br[n] || jr[n]) - Is(i) : t[n] - t["offset" + i])
            },
            zs = function (t, e) {
                for (var n = 0; n < ts.length; n += 3)(!e || ~e.indexOf(ts[n + 1])) && t(ts[n], ts[n + 1], ts[n + 2])
            },
            Us = function (t) {
                return "string" == typeof t
            },
            Bs = function (t) {
                return "function" == typeof t
            },
            js = function (t) {
                return "number" == typeof t
            },
            Hs = function (t) {
                return "object" == typeof t
            },
            Vs = function (t, e, n) {
                return t && t.progress(e ? 0 : 1) && n && t.pause()
            },
            Gs = function (t, e) {
                if (t.enabled) {
                    var n = t._ctx ? t._ctx.add((function () {
                        return e(t)
                    })) : e(t);
                    n && n.totalTime && (t.callbackAnimation = n)
                }
            },
            Ws = Math.abs,
            $s = "left",
            Xs = "right",
            qs = "bottom",
            Ys = "width",
            Ks = "height",
            Js = "Right",
            Zs = "Left",
            Qs = "Top",
            to = "Bottom",
            eo = "padding",
            no = "margin",
            io = "Width",
            ro = "Height",
            so = "px",
            oo = function (t) {
                return zr.getComputedStyle(t)
            },
            ao = function (t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            },
            lo = function (t, e) {
                var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== oo(t)[Kr] && Fr.to(t, {
                    x: 0,
                    y: 0,
                    xPercent: 0,
                    yPercent: 0,
                    rotation: 0,
                    rotationX: 0,
                    rotationY: 0,
                    scale: 1,
                    skewX: 0,
                    skewY: 0
                }).progress(1),
                    i = t.getBoundingClientRect();
                return n && n.progress(0).kill(), i
            },
            uo = function (t, e) {
                var n = e.d2;
                return t["offset" + n] || t["client" + n] || 0
            },
            co = function (t) {
                var e, n = [],
                    i = t.labels,
                    r = t.duration();
                for (e in i) n.push(i[e] / r);
                return n
            },
            ho = function (t) {
                var e = Fr.utils.snap(t),
                    n = Array.isArray(t) && t.slice(0).sort((function (t, e) {
                        return t - e
                    }));
                return n ? function (t, i, r) {
                    var s;
                    if (void 0 === r && (r = .001), !i) return e(t);
                    if (i > 0) {
                        for (t -= r, s = 0; s < n.length; s++)
                            if (n[s] >= t) return n[s];
                        return n[s - 1]
                    }
                    for (s = n.length, t += r; s--;)
                        if (n[s] <= t) return n[s];
                    return n[0]
                } : function (n, i, r) {
                    void 0 === r && (r = .001);
                    var s = e(n);
                    return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : e(i < 0 ? n - t : n + t)
                }
            },
            fo = function (t, e, n, i) {
                return n.split(",").forEach((function (n) {
                    return t(e, n, i)
                }))
            },
            po = function (t, e, n, i, r) {
                return t.addEventListener(e, n, {
                    passive: !i,
                    capture: !!r
                })
            },
            mo = function (t, e, n, i) {
                return t.removeEventListener(e, n, !!i)
            },
            go = function (t, e, n) {
                (n = n && n.wheelHandler) && (t(e, "wheel", n), t(e, "touchmove", n))
            },
            vo = {
                startColor: "green",
                endColor: "red",
                indent: 0,
                fontSize: "16px",
                fontWeight: "normal"
            },
            yo = {
                toggleActions: "play",
                anticipatePin: 0
            },
            bo = {
                top: 0,
                left: 0,
                center: .5,
                bottom: 1,
                right: 1
            },
            _o = function (t, e) {
                if (Us(t)) {
                    var n = t.indexOf("="),
                        i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
                    ~n && (t.indexOf("%") > n && (i *= e / 100), t = t.substr(0, n - 1)), t = i + (t in bo ? bo[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
                }
                return t
            },
            xo = function (t, e, n, i, r, s, o, a) {
                var l = r.startColor,
                    u = r.endColor,
                    c = r.fontSize,
                    h = r.indent,
                    d = r.fontWeight,
                    f = Ur.createElement("div"),
                    p = Os(n) || "fixed" === yr(n, "pinType"),
                    m = -1 !== t.indexOf("scroller"),
                    g = p ? jr : n,
                    v = -1 !== t.indexOf("start"),
                    y = v ? l : u,
                    b = "border-color:" + y + ";font-size:" + c + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                return b += "position:" + ((m || a) && p ? "fixed;" : "absolute;"), (m || a || !p) && (b += (i === Dr ? Xs : qs) + ":" + (s + parseFloat(h)) + "px;"), o && (b += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), f._isStart = v, f.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")), f.style.cssText = b, f.innerText = e || 0 === e ? t + "-" + e : t, g.children[0] ? g.insertBefore(f, g.children[0]) : g.appendChild(f), f._offset = f["offset" + i.op.d2], wo(f, 0, i, v), f
            },
            wo = function (t, e, n, i) {
                var r = {
                    display: "block"
                },
                    s = n[i ? "os2" : "p2"],
                    o = n[i ? "p2" : "os2"];
                t._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + s + io] = 1, r["border" + o + io] = 0, r[n.p] = e + "px", Fr.set(t, r)
            },
            Mo = [],
            So = {},
            To = function () {
                return xs() - Ms > 34 && (gs || (gs = requestAnimationFrame(Vo)))
            },
            Eo = function () {
                (!rs || !rs.isPressed || rs.startX > jr.clientWidth) && (pr.cache++, rs ? gs || (gs = requestAnimationFrame(Vo)) : Vo(), Ms || Ro("scrollStart"), Ms = xs())
            },
            Do = function () {
                as = zr.innerWidth, os = zr.innerHeight
            },
            Co = function () {
                pr.cache++, !qr && !is && !Ur.fullscreenElement && !Ur.webkitFullscreenElement && (!ss || as !== zr.innerWidth || Math.abs(zr.innerHeight - os) > .25 * zr.innerHeight) && Vr.restart(!0)
            },
            Ao = {},
            Po = [],
            Lo = function t() {
                return mo(ia, "scrollEnd", t) || Bo(!0)
            },
            Ro = function (t) {
                return Ao[t] && Ao[t].map((function (t) {
                    return t()
                })) || Po
            },
            ko = [],
            Oo = function (t) {
                for (var e = 0; e < ko.length; e += 5)(!t || ko[e + 4] && ko[e + 4].query === t) && (ko[e].style.cssText = ko[e + 1], ko[e].getBBox && ko[e].setAttribute("transform", ko[e + 2] || ""), ko[e + 3].uncache = 1)
            },
            Io = function (t, e) {
                var n;
                for (Jr = 0; Jr < Mo.length; Jr++) !(n = Mo[Jr]) || e && n._ctx !== e || (t ? n.kill(1) : n.revert(!0, !0));
                fs = !0, e && Oo(e), e || Ro("revert")
            },
            Fo = function (t, e) {
                pr.cache++, (e || !vs) && pr.forEach((function (t) {
                    return Bs(t) && t.cacheID++ && (t.rec = 0)
                })), Us(t) && (zr.history.scrollRestoration = cs = t)
            },
            No = 0,
            zo = function () {
                jr.appendChild(hs), ds = !rs && hs.offsetHeight || zr.innerHeight, jr.removeChild(hs)
            },
            Uo = function (t) {
                return Gr(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach((function (e) {
                    return e.style.display = t ? "none" : "block"
                }))
            },
            Bo = function (t, e) {
                if (!Ms || t || fs) {
                    zo(), vs = ia.isRefreshing = !0, pr.forEach((function (t) {
                        return Bs(t) && ++t.cacheID && (t.rec = t())
                    }));
                    var n = Ro("refreshInit");
                    es && ia.sort(), e || Io(), pr.forEach((function (t) {
                        Bs(t) && (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0))
                    })), Mo.slice(0).forEach((function (t) {
                        return t.refresh()
                    })), fs = !1, Mo.forEach((function (t) {
                        if (t._subPinOffset && t.pin) {
                            var e = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                n = t.pin[e];
                            t.revert(!0, 1), t.adjustPinSpacing(t.pin[e] - n), t.refresh()
                        }
                    })), ps = 1, Uo(!0), Mo.forEach((function (t) {
                        var e = Ns(t.scroller, t._dir),
                            n = "max" === t.vars.end || t._endClamp && t.end > e,
                            i = t._startClamp && t.start >= e;
                        (n || i) && t.setPositions(i ? e - 1 : t.start, n ? Math.max(i ? e : t.start + 1, e) : t.end, !0)
                    })), Uo(!1), ps = 0, n.forEach((function (t) {
                        return t && t.render && t.render(-1)
                    })), pr.forEach((function (t) {
                        Bs(t) && (t.smooth && requestAnimationFrame((function () {
                            return t.target.style.scrollBehavior = "smooth"
                        })), t.rec && t(t.rec))
                    })), Fo(cs, 1), Vr.pause(), No++, vs = 2, Vo(2), Mo.forEach((function (t) {
                        return Bs(t.vars.onRefresh) && t.vars.onRefresh(t)
                    })), vs = ia.isRefreshing = !1, Ro("refresh")
                } else po(ia, "scrollEnd", Lo)
            },
            jo = 0,
            Ho = 1,
            Vo = function (t) {
                if (2 === t || !vs && !fs) {
                    ia.isUpdating = !0, bs && bs.update(0);
                    var e = Mo.length,
                        n = xs(),
                        i = n - ws >= 50,
                        r = e && Mo[0].scroll();
                    if (Ho = jo > r ? -1 : 1, vs || (jo = r), i && (Ms && !Yr && n - Ms > 200 && (Ms = 0, Ro("scrollEnd")), $r = ws, ws = n), Ho < 0) {
                        for (Jr = e; Jr-- > 0;) Mo[Jr] && Mo[Jr].update(0, i);
                        Ho = 1
                    } else
                        for (Jr = 0; Jr < e; Jr++) Mo[Jr] && Mo[Jr].update(0, i);
                    ia.isUpdating = !1
                }
                gs = 0
            },
            Go = [$s, "top", qs, Xs, no + to, no + Js, no + Qs, no + Zs, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
            Wo = Go.concat([Ys, Ks, "boxSizing", "max" + io, "max" + ro, "position", no, eo, eo + Qs, eo + Js, eo + to, eo + Zs]),
            $o = function (t, e, n, i) {
                if (!t._gsap.swappedIn) {
                    for (var r, s = Go.length, o = e.style, a = t.style; s--;) o[r = Go[s]] = n[r];
                    o.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (o.display = "inline-block"), a[qs] = a[Xs] = "auto", o.flexBasis = n.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[Ys] = uo(t, Er) + so, o[Ks] = uo(t, Dr) + so, o[eo] = a[no] = a.top = a[$s] = "0", qo(i), a[Ys] = a["max" + io] = n[Ys], a[Ks] = a["max" + ro] = n[Ks], a[eo] = n[eo], t.parentNode !== e && (t.parentNode.insertBefore(e, t), e.appendChild(t)), t._gsap.swappedIn = !0
                }
            },
            Xo = /([A-Z])/g,
            qo = function (t) {
                if (t) {
                    var e, n, i = t.t.style,
                        r = t.length,
                        s = 0;
                    for ((t.t._gsap || Fr.core.getCache(t.t)).uncache = 1; s < r; s += 2) n = t[s + 1], e = t[s], n ? i[e] = n : i[e] && i.removeProperty(e.replace(Xo, "-$1").toLowerCase())
                }
            },
            Yo = function (t) {
                for (var e = Wo.length, n = t.style, i = [], r = 0; r < e; r++) i.push(Wo[r], n[Wo[r]]);
                return i.t = t, i
            },
            Ko = {
                left: 0,
                top: 0
            },
            Jo = function (t, e, n, i, r, s, o, a, l, u, c, h, d, f) {
                Bs(t) && (t = t(a)), Us(t) && "max" === t.substr(0, 3) && (t = h + ("=" === t.charAt(4) ? _o("0" + t.substr(3), n) : 0));
                var p, m, g, v = d ? d.time() : 0;
                if (d && d.seek(0), isNaN(t) || (t = +t), js(t)) d && (t = Fr.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, h, t)), o && wo(o, n, i, !0);
                else {
                    Bs(e) && (e = e(a));
                    var y, b, _, x, w = (t || "0").split(" ");
                    g = Cr(e, a) || jr, (y = lo(g) || {}) && (y.left || y.top) || "none" !== oo(g).display || (x = g.style.display, g.style.display = "block", y = lo(g), x ? g.style.display = x : g.style.removeProperty("display")), b = _o(w[0], y[i.d]), _ = _o(w[1] || "0", n), t = y[i.p] - l[i.p] - u + b + r - _, o && wo(o, _, i, n - _ < 20 || o._isStart && _ > 20), n -= n - _
                }
                if (f && (a[f] = t || -.001, t < 0 && (t = 0)), s) {
                    var M = t + n,
                        S = s._isStart;
                    p = "scroll" + i.d2, wo(s, M, i, S && M > 20 || !S && (c ? Math.max(jr[p], Br[p]) : s.parentNode[p]) <= M + 1), c && (l = lo(o), c && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + so))
                }
                return d && g && (p = lo(g), d.seek(h), m = lo(g), d._caScrollDist = p[i.p] - m[i.p], t = t / d._caScrollDist * h), d && d.seek(v), d ? t : Math.round(t)
            },
            Zo = /(webkit|moz|length|cssText|inset)/i,
            Qo = function (t, e, n, i) {
                if (t.parentNode !== e) {
                    var r, s, o = t.style;
                    if (e === jr) {
                        for (r in t._stOrig = o.cssText, s = oo(t)) + r || Zo.test(r) || !s[r] || "string" != typeof o[r] || "0" === r || (o[r] = s[r]);
                        o.top = n, o.left = i
                    } else o.cssText = t._stOrig;
                    Fr.core.getCache(t).uncache = 1, e.appendChild(t)
                }
            },
            ta = function (t, e, n) {
                var i = e,
                    r = i;
                return function (e) {
                    var s = Math.round(t());
                    return s !== i && s !== r && Math.abs(s - i) > 3 && Math.abs(s - r) > 3 && (e = s, n && n()), r = i, i = e, e
                }
            },
            ea = function (t, e, n) {
                var i = {};
                i[e.p] = "+=" + n, Fr.set(t, i)
            },
            na = function (t, e) {
                var n = Ar(t, e),
                    i = "_scroll" + e.p2,
                    r = function e(r, s, o, a, l) {
                        var u = e.tween,
                            c = s.onComplete,
                            h = {};
                        o = o || n();
                        var d = ta(n, o, (function () {
                            u.kill(), e.tween = 0
                        }));
                        return l = a && l || 0, a = a || r - o, u && u.kill(), s[i] = r, s.inherit = !1, s.modifiers = h, h[i] = function () {
                            return d(o + a * u.ratio + l * u.ratio * u.ratio)
                        }, s.onUpdate = function () {
                            pr.cache++, e.tween && Vo()
                        }, s.onComplete = function () {
                            e.tween = 0, c && c.call(u)
                        }, u = e.tween = Fr.to(t, s)
                    };
                return t[i] = n, n.wheelHandler = function () {
                    return r.tween && r.tween.kill() && (r.tween = 0)
                }, po(t, "wheel", n.wheelHandler), ia.isTouch && po(t, "touchmove", n.wheelHandler), r
            },
            ia = function () {
                function t(e, n) {
                    Nr || t.register(Fr) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), us(this), this.init(e, n)
                }
                return t.prototype.init = function (e, n) {
                    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), Ss) {
                        var i, r, s, o, a, l, u, c, h, d, f, p, m, g, v, y, b, _, x, w, M, S, T, E, D, C, A, P, L, R, k, O, I, F, N, z, U, B, j, H, V, G, W = e = ao(Us(e) || js(e) || e.nodeType ? {
                            trigger: e
                        } : e, yo),
                            $ = W.onUpdate,
                            X = W.toggleClass,
                            q = W.id,
                            Y = W.onToggle,
                            K = W.onRefresh,
                            J = W.scrub,
                            Z = W.trigger,
                            Q = W.pin,
                            tt = W.pinSpacing,
                            et = W.invalidateOnRefresh,
                            nt = W.anticipatePin,
                            it = W.onScrubComplete,
                            rt = W.onSnapComplete,
                            st = W.once,
                            ot = W.snap,
                            at = W.pinReparent,
                            lt = W.pinSpacer,
                            ut = W.containerAnimation,
                            ct = W.fastScrollEnd,
                            ht = W.preventOverlaps,
                            dt = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? Er : Dr,
                            ft = !J && 0 !== J,
                            pt = Cr(e.scroller || zr),
                            mt = Fr.core.getCache(pt),
                            gt = Os(pt),
                            vt = "fixed" === ("pinType" in e ? e.pinType : yr(pt, "pinType") || gt && "fixed"),
                            yt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                            bt = ft && e.toggleActions.split(" "),
                            _t = "markers" in e ? e.markers : yo.markers,
                            xt = gt ? 0 : parseFloat(oo(pt)["border" + dt.p2 + io]) || 0,
                            wt = this,
                            Mt = e.onRefreshInit && function () {
                                return e.onRefreshInit(wt)
                            },
                            St = function (t, e, n) {
                                var i = n.d,
                                    r = n.d2,
                                    s = n.a;
                                return (s = yr(t, "getBoundingClientRect")) ? function () {
                                    return s()[i]
                                } : function () {
                                    return (e ? Is(r) : t["client" + r]) || 0
                                }
                            }(pt, gt, dt),
                            Tt = function (t, e) {
                                return !e || ~mr.indexOf(t) ? Fs(t) : function () {
                                    return Ko
                                }
                            }(pt, gt),
                            Et = 0,
                            Dt = 0,
                            Ct = 0,
                            At = Ar(pt, dt);
                        if (wt._startClamp = wt._endClamp = !1, wt._dir = dt, nt *= 45, wt.scroller = pt, wt.scroll = ut ? ut.time.bind(ut) : At, o = At(), wt.vars = e, n = n || e.animation, "refreshPriority" in e && (es = 1, -9999 === e.refreshPriority && (bs = wt)), mt.tweenScroll = mt.tweenScroll || {
                            top: na(pt, Dr),
                            left: na(pt, Er)
                        }, wt.tweenTo = i = mt.tweenScroll[dt.p], wt.scrubDuration = function (t) {
                            (I = js(t) && t) ? O ? O.duration(t) : O = Fr.to(n, {
                                ease: "expo",
                                totalProgress: "+=0",
                                inherit: !1,
                                duration: I,
                                paused: !0,
                                onComplete: function () {
                                    return it && it(wt)
                                }
                            }) : (O && O.progress(1).kill(), O = 0)
                        }, n && (n.vars.lazy = !1, n._initted && !wt.isReverted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.duration() && n.render(0, !0, !0), wt.animation = n.pause(), n.scrollTrigger = wt, wt.scrubDuration(J), R = 0, q || (q = n.vars.id)), ot && (Hs(ot) && !ot.push || (ot = {
                            snapTo: ot
                        }), "scrollBehavior" in jr.style && Fr.set(gt ? [jr, Br] : pt, {
                            scrollBehavior: "auto"
                        }), pr.forEach((function (t) {
                            return Bs(t) && t.target === (gt ? Ur.scrollingElement || Br : pt) && (t.smooth = !1)
                        })), s = Bs(ot.snapTo) ? ot.snapTo : "labels" === ot.snapTo ? function (t) {
                            return function (e) {
                                return Fr.utils.snap(co(t), e)
                            }
                        }(n) : "labelsDirectional" === ot.snapTo ? (H = n, function (t, e) {
                            return ho(co(H))(t, e.direction)
                        }) : !1 !== ot.directional ? function (t, e) {
                            return ho(ot.snapTo)(t, xs() - Dt < 500 ? 0 : e.direction)
                        } : Fr.utils.snap(ot.snapTo), F = ot.duration || {
                            min: .1,
                            max: 2
                        }, F = Hs(F) ? Wr(F.min, F.max) : Wr(F, F), N = Fr.delayedCall(ot.delay || I / 2 || .1, (function () {
                            var t = At(),
                                e = xs() - Dt < 500,
                                r = i.tween;
                            if (!(e || Math.abs(wt.getVelocity()) < 10) || r || Yr || Et === t) wt.isActive && Et !== t && N.restart(!0);
                            else {
                                var o, a, c = (t - l) / g,
                                    h = n && !ft ? n.totalProgress() : c,
                                    d = e ? 0 : (h - k) / (xs() - $r) * 1e3 || 0,
                                    f = Fr.utils.clamp(-c, 1 - c, Ws(d / 2) * d / .185),
                                    p = c + (!1 === ot.inertia ? 0 : f),
                                    m = ot,
                                    v = m.onStart,
                                    y = m.onInterrupt,
                                    b = m.onComplete;
                                if (o = s(p, wt), js(o) || (o = p), a = Math.round(l + o * g), t <= u && t >= l && a !== t) {
                                    if (r && !r._initted && r.data <= Ws(a - t)) return;
                                    !1 === ot.inertia && (f = o - c), i(a, {
                                        duration: F(Ws(.185 * Math.max(Ws(p - h), Ws(o - h)) / d / .05 || 0)),
                                        ease: ot.ease || "power3",
                                        data: Ws(a - t),
                                        onInterrupt: function () {
                                            return N.restart(!0) && y && y(wt)
                                        },
                                        onComplete: function () {
                                            wt.update(), Et = At(), n && (O ? O.resetTo("totalProgress", o, n._tTime / n._tDur) : n.progress(o)), R = k = n && !ft ? n.totalProgress() : wt.progress, rt && rt(wt), b && b(wt)
                                        }
                                    }, t, f * g, a - t - f * g), v && v(wt, i.tween)
                                }
                            }
                        })).pause()), q && (So[q] = wt), (j = (Z = wt.trigger = Cr(Z || !0 !== Q && Q)) && Z._gsap && Z._gsap.stRevert) && (j = j(wt)), Q = !0 === Q ? Z : Cr(Q), Us(X) && (X = {
                            targets: Z,
                            className: X
                        }), Q && (!1 === tt || tt === no || (tt = !(!tt && Q.parentNode && Q.parentNode.style && "flex" === oo(Q.parentNode).display) && eo), wt.pin = Q, (r = Fr.core.getCache(Q)).spacer ? v = r.pinState : (lt && ((lt = Cr(lt)) && !lt.nodeType && (lt = lt.current || lt.nativeElement), r.spacerIsNative = !!lt, lt && (r.spacerState = Yo(lt))), r.spacer = _ = lt || Ur.createElement("div"), _.classList.add("pin-spacer"), q && _.classList.add("pin-spacer-" + q), r.pinState = v = Yo(Q)), !1 !== e.force3D && Fr.set(Q, {
                            force3D: !0
                        }), wt.spacer = _ = r.spacer, L = oo(Q), E = L[tt + dt.os2], w = Fr.getProperty(Q), M = Fr.quickSetter(Q, dt.a, so), $o(Q, _, L), b = Yo(Q)), _t) {
                            p = Hs(_t) ? ao(_t, vo) : vo, d = xo("scroller-start", q, pt, dt, p, 0), f = xo("scroller-end", q, pt, dt, p, 0, d), x = d["offset" + dt.op.d2];
                            var Pt = Cr(yr(pt, "content") || pt);
                            c = this.markerStart = xo("start", q, Pt, dt, p, x, 0, ut), h = this.markerEnd = xo("end", q, Pt, dt, p, x, 0, ut), ut && (B = Fr.quickSetter([c, h], dt.a, so)), vt || mr.length && !0 === yr(pt, "fixedMarkers") || (G = oo(V = gt ? jr : pt).position, V.style.position = "absolute" === G || "fixed" === G ? G : "relative", Fr.set([d, f], {
                                force3D: !0
                            }), C = Fr.quickSetter(d, dt.a, so), P = Fr.quickSetter(f, dt.a, so))
                        }
                        if (ut) {
                            var Lt = ut.vars.onUpdate,
                                Rt = ut.vars.onUpdateParams;
                            ut.eventCallback("onUpdate", (function () {
                                wt.update(0, 0, 1), Lt && Lt.apply(ut, Rt || [])
                            }))
                        }
                        if (wt.previous = function () {
                            return Mo[Mo.indexOf(wt) - 1]
                        }, wt.next = function () {
                            return Mo[Mo.indexOf(wt) + 1]
                        }, wt.revert = function (t, e) {
                            if (!e) return wt.kill(!0);
                            var i = !1 !== t || !wt.enabled,
                                r = qr;
                            i !== wt.isReverted && (i && (z = Math.max(At(), wt.scroll.rec || 0), Ct = wt.progress, U = n && n.progress()), c && [c, h, d, f].forEach((function (t) {
                                return t.style.display = i ? "none" : "block"
                            })), i && (qr = wt, wt.update(i)), !Q || at && wt.isActive || (i ? function (t, e, n) {
                                qo(n);
                                var i = t._gsap;
                                if (i.spacerIsNative) qo(i.spacerState);
                                else if (t._gsap.swappedIn) {
                                    var r = e.parentNode;
                                    r && (r.insertBefore(t, e), r.removeChild(e))
                                }
                                t._gsap.swappedIn = !1
                            }(Q, _, v) : $o(Q, _, oo(Q), D)), i || wt.update(i), qr = r, wt.isReverted = i)
                        }, wt.refresh = function (r, s, p, x) {
                            if (!qr && wt.enabled || s)
                                if (Q && r && Ms) po(t, "scrollEnd", Lo);
                                else {
                                    !vs && Mt && Mt(wt), qr = wt, i.tween && !p && (i.tween.kill(), i.tween = 0), O && O.pause(), et && n && n.revert({
                                        kill: !1
                                    }).invalidate(), wt.isReverted || wt.revert(!0, !0), wt._subPinOffset = !1;
                                    var M, E, C, P, L, R, k, I, F, B, j, H, V, G = St(),
                                        W = Tt(),
                                        $ = ut ? ut.duration() : Ns(pt, dt),
                                        X = g <= .01,
                                        q = 0,
                                        Y = x || 0,
                                        J = Hs(p) ? p.end : e.end,
                                        nt = e.endTrigger || Z,
                                        it = Hs(p) ? p.start : e.start || (0 !== e.start && Z ? Q ? "0 0" : "0 100%" : 0),
                                        rt = wt.pinnedContainer = e.pinnedContainer && Cr(e.pinnedContainer, wt),
                                        st = Z && Math.max(0, Mo.indexOf(wt)) || 0,
                                        ot = st;
                                    for (_t && Hs(p) && (H = Fr.getProperty(d, dt.p), V = Fr.getProperty(f, dt.p)); ot--;)(R = Mo[ot]).end || R.refresh(0, 1) || (qr = wt), !(k = R.pin) || k !== Z && k !== Q && k !== rt || R.isReverted || (B || (B = []), B.unshift(R), R.revert(!0, !0)), R !== Mo[ot] && (st--, ot--);
                                    for (Bs(it) && (it = it(wt)), it = Ts(it, "start", wt), l = Jo(it, Z, G, dt, At(), c, d, wt, W, xt, vt, $, ut, wt._startClamp && "_startClamp") || (Q ? -.001 : 0), Bs(J) && (J = J(wt)), Us(J) && !J.indexOf("+=") && (~J.indexOf(" ") ? J = (Us(it) ? it.split(" ")[0] : "") + J : (q = _o(J.substr(2), G), J = Us(it) ? it : (ut ? Fr.utils.mapRange(0, ut.duration(), ut.scrollTrigger.start, ut.scrollTrigger.end, l) : l) + q, nt = Z)), J = Ts(J, "end", wt), u = Math.max(l, Jo(J || (nt ? "100% 0" : $), nt, G, dt, At() + q, h, f, wt, W, xt, vt, $, ut, wt._endClamp && "_endClamp")) || -.001, q = 0, ot = st; ot--;)(k = (R = Mo[ot]).pin) && R.start - R._pinPush <= l && !ut && R.end > 0 && (M = R.end - (wt._startClamp ? Math.max(0, R.start) : R.start), (k === Z && R.start - R._pinPush < l || k === rt) && isNaN(it) && (q += M * (1 - R.progress)), k === Q && (Y += M));
                                    if (l += q, u += q, wt._startClamp && (wt._startClamp += q), wt._endClamp && !vs && (wt._endClamp = u || -.001, u = Math.min(u, Ns(pt, dt))), g = u - l || (l -= .01) && .001, X && (Ct = Fr.utils.clamp(0, 1, Fr.utils.normalize(l, u, z))), wt._pinPush = Y, c && q && ((M = {})[dt.a] = "+=" + q, rt && (M[dt.p] = "-=" + At()), Fr.set([c, h], M)), !Q || ps && wt.end >= Ns(pt, dt)) {
                                        if (Z && At() && !ut)
                                            for (E = Z.parentNode; E && E !== jr;) E._pinOffset && (l -= E._pinOffset, u -= E._pinOffset), E = E.parentNode
                                    } else M = oo(Q), P = dt === Dr, C = At(), S = parseFloat(w(dt.a)) + Y, !$ && u > 1 && (j = {
                                        style: j = (gt ? Ur.scrollingElement || Br : pt).style,
                                        value: j["overflow" + dt.a.toUpperCase()]
                                    }, gt && "scroll" !== oo(jr)["overflow" + dt.a.toUpperCase()] && (j.style["overflow" + dt.a.toUpperCase()] = "scroll")), $o(Q, _, M), b = Yo(Q), E = lo(Q, !0), I = vt && Ar(pt, P ? Er : Dr)(), tt ? ((D = [tt + dt.os2, g + Y + so]).t = _, (ot = tt === eo ? uo(Q, dt) + g + Y : 0) && (D.push(dt.d, ot + so), "auto" !== _.style.flexBasis && (_.style.flexBasis = ot + so)), qo(D), rt && Mo.forEach((function (t) {
                                        t.pin === rt && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0)
                                    })), vt && At(z)) : (ot = uo(Q, dt)) && "auto" !== _.style.flexBasis && (_.style.flexBasis = ot + so), vt && ((L = {
                                        top: E.top + (P ? C - l : I) + so,
                                        left: E.left + (P ? I : C - l) + so,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    })[Ys] = L["max" + io] = Math.ceil(E.width) + so, L[Ks] = L["max" + ro] = Math.ceil(E.height) + so, L[no] = L[no + Qs] = L[no + Js] = L[no + to] = L[no + Zs] = "0", L[eo] = M[eo], L[eo + Qs] = M[eo + Qs], L[eo + Js] = M[eo + Js], L[eo + to] = M[eo + to], L[eo + Zs] = M[eo + Zs], y = function (t, e, n) {
                                        for (var i, r = [], s = t.length, o = n ? 8 : 0; o < s; o += 2) i = t[o], r.push(i, i in e ? e[i] : t[o + 1]);
                                        return r.t = t.t, r
                                    }(v, L, at), vs && At(0)), n ? (F = n._initted, ns(1), n.render(n.duration(), !0, !0), T = w(dt.a) - S + g + Y, A = Math.abs(g - T) > 1, vt && A && y.splice(y.length - 2, 2), n.render(0, !0, !0), F || n.invalidate(!0), n.parent || n.totalTime(n.totalTime()), ns(0)) : T = g, j && (j.value ? j.style["overflow" + dt.a.toUpperCase()] = j.value : j.style.removeProperty("overflow-" + dt.a));
                                    B && B.forEach((function (t) {
                                        return t.revert(!1, !0)
                                    })), wt.start = l, wt.end = u, o = a = vs ? z : At(), ut || vs || (o < z && At(z), wt.scroll.rec = 0), wt.revert(!1, !0), Dt = xs(), N && (Et = -1, N.restart(!0)), qr = 0, n && ft && (n._initted || U) && n.progress() !== U && n.progress(U || 0, !0).render(n.time(), !0, !0), (X || Ct !== wt.progress || ut || et) && (n && !ft && n.totalProgress(ut && l < -.001 && !Ct ? Fr.utils.normalize(l, u, 0) : Ct, !0), wt.progress = X || (o - l) / g === Ct ? 0 : Ct), Q && tt && (_._pinOffset = Math.round(wt.progress * T)), O && O.invalidate(), isNaN(H) || (H -= Fr.getProperty(d, dt.p), V -= Fr.getProperty(f, dt.p), ea(d, dt, H), ea(c, dt, H - (x || 0)), ea(f, dt, V), ea(h, dt, V - (x || 0))), X && !vs && wt.update(), !K || vs || m || (m = !0, K(wt), m = !1)
                                }
                        }, wt.getVelocity = function () {
                            return (At() - a) / (xs() - $r) * 1e3 || 0
                        }, wt.endAnimation = function () {
                            Vs(wt.callbackAnimation), n && (O ? O.progress(1) : n.paused() ? ft || Vs(n, wt.direction < 0, 1) : Vs(n, n.reversed()))
                        }, wt.labelToScroll = function (t) {
                            return n && n.labels && (l || wt.refresh() || l) + n.labels[t] / n.duration() * g || 0
                        }, wt.getTrailing = function (t) {
                            var e = Mo.indexOf(wt),
                                n = wt.direction > 0 ? Mo.slice(0, e).reverse() : Mo.slice(e + 1);
                            return (Us(t) ? n.filter((function (e) {
                                return e.vars.preventOverlaps === t
                            })) : n).filter((function (t) {
                                return wt.direction > 0 ? t.end <= l : t.start >= u
                            }))
                        }, wt.update = function (t, e, r) {
                            if (!ut || r || t) {
                                var s, c, h, f, p, m, v, x = !0 === vs ? z : wt.scroll(),
                                    w = t ? 0 : (x - l) / g,
                                    D = w < 0 ? 0 : w > 1 ? 1 : w || 0,
                                    L = wt.progress;
                                if (e && (a = o, o = ut ? At() : x, ot && (k = R, R = n && !ft ? n.totalProgress() : D)), nt && Q && !qr && !_s && Ms && (!D && l < x + (x - a) / (xs() - $r) * nt ? D = 1e-4 : 1 === D && u > x + (x - a) / (xs() - $r) * nt && (D = .9999)), D !== L && wt.enabled) {
                                    if (f = (p = (s = wt.isActive = !!D && D < 1) != (!!L && L < 1)) || !!D != !!L, wt.direction = D > L ? 1 : -1, wt.progress = D, f && !qr && (c = D && !L ? 0 : 1 === D ? 1 : 1 === L ? 2 : 3, ft && (h = !p && "none" !== bt[c + 1] && bt[c + 1] || bt[c], v = n && ("complete" === h || "reset" === h || h in n))), ht && (p || v) && (v || J || !n) && (Bs(ht) ? ht(wt) : wt.getTrailing(ht).forEach((function (t) {
                                        return t.endAnimation()
                                    }))), ft || (!O || qr || _s ? n && n.totalProgress(D, !(!qr || !Dt && !t)) : (O._dp._time - O._start !== O._time && O.render(O._dp._time - O._start), O.resetTo ? O.resetTo("totalProgress", D, n._tTime / n._tDur) : (O.vars.totalProgress = D, O.invalidate().restart()))), Q)
                                        if (t && tt && (_.style[tt + dt.os2] = E), vt) {
                                            if (f) {
                                                if (m = !t && D > L && u + 1 > x && x + 1 >= Ns(pt, dt), at)
                                                    if (t || !s && !m) Qo(Q, _);
                                                    else {
                                                        var I = lo(Q, !0),
                                                            F = x - l;
                                                        Qo(Q, jr, I.top + (dt === Dr ? F : 0) + so, I.left + (dt === Dr ? 0 : F) + so)
                                                    } qo(s || m ? y : b), A && D < 1 && s || M(S + (1 !== D || m ? 0 : T))
                                            }
                                        } else M(Ls(S + T * D));
                                    ot && !i.tween && !qr && !_s && N.restart(!0), X && (p || st && D && (D < 1 || !ms)) && Gr(X.targets).forEach((function (t) {
                                        return t.classList[s || st ? "add" : "remove"](X.className)
                                    })), $ && !ft && !t && $(wt), f && !qr ? (ft && (v && ("complete" === h ? n.pause().totalProgress(1) : "reset" === h ? n.restart(!0).pause() : "restart" === h ? n.restart(!0) : n[h]()), $ && $(wt)), !p && ms || (Y && p && Gs(wt, Y), yt[c] && Gs(wt, yt[c]), st && (1 === D ? wt.kill(!1, 1) : yt[c] = 0), p || yt[c = 1 === D ? 1 : 3] && Gs(wt, yt[c])), ct && !s && Math.abs(wt.getVelocity()) > (js(ct) ? ct : 2500) && (Vs(wt.callbackAnimation), O ? O.progress(1) : Vs(n, "reverse" === h ? 1 : !D, 1))) : ft && $ && !qr && $(wt)
                                }
                                if (P) {
                                    var U = ut ? x / ut.duration() * (ut._caScrollDist || 0) : x;
                                    C(U + (d._isFlipped ? 1 : 0)), P(U)
                                }
                                B && B(-x / ut.duration() * (ut._caScrollDist || 0))
                            }
                        }, wt.enable = function (e, n) {
                            wt.enabled || (wt.enabled = !0, po(pt, "resize", Co), gt || po(pt, "scroll", Eo), Mt && po(t, "refreshInit", Mt), !1 !== e && (wt.progress = Ct = 0, o = a = Et = At()), !1 !== n && wt.refresh())
                        }, wt.getTween = function (t) {
                            return t && i ? i.tween : O
                        }, wt.setPositions = function (t, e, n, i) {
                            if (ut) {
                                var r = ut.scrollTrigger,
                                    s = ut.duration(),
                                    o = r.end - r.start;
                                t = r.start + o * t / s, e = r.start + o * e / s
                            }
                            wt.refresh(!1, !1, {
                                start: Es(t, n && !!wt._startClamp),
                                end: Es(e, n && !!wt._endClamp)
                            }, i), wt.update()
                        }, wt.adjustPinSpacing = function (t) {
                            if (D && t) {
                                var e = D.indexOf(dt.d) + 1;
                                D[e] = parseFloat(D[e]) + t + so, D[1] = parseFloat(D[1]) + t + so, qo(D)
                            }
                        }, wt.disable = function (e, n) {
                            if (wt.enabled && (!1 !== e && wt.revert(!0, !0), wt.enabled = wt.isActive = !1, n || O && O.pause(), z = 0, r && (r.uncache = 1), Mt && mo(t, "refreshInit", Mt), N && (N.pause(), i.tween && i.tween.kill() && (i.tween = 0)), !gt)) {
                                for (var s = Mo.length; s--;)
                                    if (Mo[s].scroller === pt && Mo[s] !== wt) return;
                                mo(pt, "resize", Co), gt || mo(pt, "scroll", Eo)
                            }
                        }, wt.kill = function (t, i) {
                            wt.disable(t, i), O && !i && O.kill(), q && delete So[q];
                            var s = Mo.indexOf(wt);
                            s >= 0 && Mo.splice(s, 1), s === Jr && Ho > 0 && Jr--, s = 0, Mo.forEach((function (t) {
                                return t.scroller === wt.scroller && (s = 1)
                            })), s || vs || (wt.scroll.rec = 0), n && (n.scrollTrigger = null, t && n.revert({
                                kill: !1
                            }), i || n.kill()), c && [c, h, d, f].forEach((function (t) {
                                return t.parentNode && t.parentNode.removeChild(t)
                            })), bs === wt && (bs = 0), Q && (r && (r.uncache = 1), s = 0, Mo.forEach((function (t) {
                                return t.pin === Q && s++
                            })), s || (r.spacer = 0)), e.onKill && e.onKill(wt)
                        }, Mo.push(wt), wt.enable(!1, !1), j && j(wt), n && n.add && !g) {
                            var kt = wt.update;
                            wt.update = function () {
                                wt.update = kt, l || u || wt.refresh()
                            }, Fr.delayedCall(.01, wt.update), g = .01, l = u = 0
                        } else wt.refresh();
                        Q && function () {
                            if (ys !== No) {
                                var t = ys = No;
                                requestAnimationFrame((function () {
                                    return t === No && Bo(!0)
                                }))
                            }
                        }()
                    } else this.update = this.refresh = this.kill = Ps
                }, t.register = function (e) {
                    return Nr || (Fr = e || ks(), Rs() && window.document && t.enable(), Nr = Ss), Nr
                }, t.defaults = function (t) {
                    if (t)
                        for (var e in t) yo[e] = t[e];
                    return yo
                }, t.disable = function (t, e) {
                    Ss = 0, Mo.forEach((function (n) {
                        return n[e ? "kill" : "disable"](t)
                    })), mo(zr, "wheel", Eo), mo(Ur, "scroll", Eo), clearInterval(Xr), mo(Ur, "touchcancel", Ps), mo(jr, "touchstart", Ps), fo(mo, Ur, "pointerdown,touchstart,mousedown", Cs), fo(mo, Ur, "pointerup,touchend,mouseup", As), Vr.kill(), zs(mo);
                    for (var n = 0; n < pr.length; n += 3) go(mo, pr[n], pr[n + 1]), go(mo, pr[n], pr[n + 2])
                }, t.enable = function () {
                    if (zr = window, Ur = document, Br = Ur.documentElement, jr = Ur.body, Fr && (Gr = Fr.utils.toArray, Wr = Fr.utils.clamp, us = Fr.core.context || Ps, ns = Fr.core.suppressOverwrites || Ps, cs = zr.history.scrollRestoration || "auto", jo = zr.pageYOffset, Fr.core.globals("ScrollTrigger", t), jr)) {
                        Ss = 1, (hs = document.createElement("div")).style.height = "100vh", hs.style.position = "absolute", zo(), Ds(), Ir.register(Fr), t.isTouch = Ir.isTouch, ls = Ir.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), ss = 1 === Ir.isTouch, po(zr, "wheel", Eo), Hr = [zr, Ur, Br, jr], Fr.matchMedia ? (t.matchMedia = function (t) {
                            var e, n = Fr.matchMedia();
                            for (e in t) n.add(e, t[e]);
                            return n
                        }, Fr.addEventListener("matchMediaInit", (function () {
                            return Io()
                        })), Fr.addEventListener("matchMediaRevert", (function () {
                            return Oo()
                        })), Fr.addEventListener("matchMedia", (function () {
                            Bo(0, 1), Ro("matchMedia")
                        })), Fr.matchMedia("(orientation: portrait)", (function () {
                            return Do(), Do
                        }))) : console.warn("Requires GSAP 3.11.0 or later"), Do(), po(Ur, "scroll", Eo);
                        var e, n, i = jr.style,
                            r = i.borderTopStyle,
                            s = Fr.core.Animation.prototype;
                        for (s.revert || Object.defineProperty(s, "revert", {
                            value: function () {
                                return this.time(-.01, !0)
                            }
                        }), i.borderTopStyle = "solid", e = lo(jr), Dr.m = Math.round(e.top + Dr.sc()) || 0, Er.m = Math.round(e.left + Er.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), Xr = setInterval(To, 250), Fr.delayedCall(.5, (function () {
                            return _s = 0
                        })), po(Ur, "touchcancel", Ps), po(jr, "touchstart", Ps), fo(po, Ur, "pointerdown,touchstart,mousedown", Cs), fo(po, Ur, "pointerup,touchend,mouseup", As), Kr = Fr.utils.checkPrefix("transform"), Wo.push(Kr), Nr = xs(), Vr = Fr.delayedCall(.2, Bo).pause(), ts = [Ur, "visibilitychange", function () {
                            var t = zr.innerWidth,
                                e = zr.innerHeight;
                            Ur.hidden ? (Zr = t, Qr = e) : Zr === t && Qr === e || Co()
                        }, Ur, "DOMContentLoaded", Bo, zr, "load", Bo, zr, "resize", Co], zs(po), Mo.forEach((function (t) {
                            return t.enable(0, 1)
                        })), n = 0; n < pr.length; n += 3) go(mo, pr[n], pr[n + 1]), go(mo, pr[n], pr[n + 2])
                    }
                }, t.config = function (e) {
                    "limitCallbacks" in e && (ms = !!e.limitCallbacks);
                    var n = e.syncInterval;
                    n && clearInterval(Xr) || (Xr = n) && setInterval(To, n), "ignoreMobileResize" in e && (ss = 1 === t.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (zs(mo) || zs(po, e.autoRefreshEvents || "none"), is = -1 === (e.autoRefreshEvents + "").indexOf("resize"))
                }, t.scrollerProxy = function (t, e) {
                    var n = Cr(t),
                        i = pr.indexOf(n),
                        r = Os(n);
                    ~i && pr.splice(i, r ? 6 : 2), e && (r ? mr.unshift(zr, e, jr, e, Br, e) : mr.unshift(n, e))
                }, t.clearMatchMedia = function (t) {
                    Mo.forEach((function (e) {
                        return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0)
                    }))
                }, t.isInViewport = function (t, e, n) {
                    var i = (Us(t) ? Cr(t) : t).getBoundingClientRect(),
                        r = i[n ? Ys : Ks] * e || 0;
                    return n ? i.right - r > 0 && i.left + r < zr.innerWidth : i.bottom - r > 0 && i.top + r < zr.innerHeight
                }, t.positionInViewport = function (t, e, n) {
                    Us(t) && (t = Cr(t));
                    var i = t.getBoundingClientRect(),
                        r = i[n ? Ys : Ks],
                        s = null == e ? r / 2 : e in bo ? bo[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0;
                    return n ? (i.left + s) / zr.innerWidth : (i.top + s) / zr.innerHeight
                }, t.killAll = function (t) {
                    if (Mo.slice(0).forEach((function (t) {
                        return "ScrollSmoother" !== t.vars.id && t.kill()
                    })), !0 !== t) {
                        var e = Ao.killAll || [];
                        Ao = {}, e.forEach((function (t) {
                            return t()
                        }))
                    }
                }, t
            }();
        ia.version = "3.12.5", ia.saveStyles = function (t) {
            return t ? Gr(t).forEach((function (t) {
                if (t && t.style) {
                    var e = ko.indexOf(t);
                    e >= 0 && ko.splice(e, 5), ko.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), Fr.core.getCache(t), us())
                }
            })) : ko
        }, ia.revert = function (t, e) {
            return Io(!t, e)
        }, ia.create = function (t, e) {
            return new ia(t, e)
        }, ia.refresh = function (t) {
            return t ? Co() : (Nr || ia.register()) && Bo(!0)
        }, ia.update = function (t) {
            return ++pr.cache && Vo(!0 === t ? 2 : 0)
        }, ia.clearScrollMemory = Fo, ia.maxScroll = function (t, e) {
            return Ns(t, e ? Er : Dr)
        }, ia.getScrollFunc = function (t, e) {
            return Ar(Cr(t), e ? Er : Dr)
        }, ia.getById = function (t) {
            return So[t]
        }, ia.getAll = function () {
            return Mo.filter((function (t) {
                return "ScrollSmoother" !== t.vars.id
            }))
        }, ia.isScrolling = function () {
            return !!Ms
        }, ia.snapDirectional = ho, ia.addEventListener = function (t, e) {
            var n = Ao[t] || (Ao[t] = []);
            ~n.indexOf(e) || n.push(e)
        }, ia.removeEventListener = function (t, e) {
            var n = Ao[t],
                i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1)
        }, ia.batch = function (t, e) {
            var n, i = [],
                r = {},
                s = e.interval || .016,
                o = e.batchMax || 1e9,
                a = function (t, e) {
                    var n = [],
                        i = [],
                        r = Fr.delayedCall(s, (function () {
                            e(n, i), n = [], i = []
                        })).pause();
                    return function (t) {
                        n.length || r.restart(!0), n.push(t.trigger), i.push(t), o <= n.length && r.progress(1)
                    }
                };
            for (n in e) r[n] = "on" === n.substr(0, 2) && Bs(e[n]) && "onRefreshInit" !== n ? a(0, e[n]) : e[n];
            return Bs(o) && (o = o(), po(ia, "refresh", (function () {
                return o = e.batchMax()
            }))), Gr(t).forEach((function (t) {
                var e = {};
                for (n in r) e[n] = r[n];
                e.trigger = t, i.push(ia.create(e))
            })), i
        };
        var ra, sa = function (t, e, n, i) {
            return e > i ? t(i) : e < 0 && t(0), n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
        },
            oa = function t(e, n) {
                !0 === n ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === n ? "auto" : n ? "pan-" + n + (Ir.isTouch ? " pinch-zoom" : "") : "none", e === Br && t(jr, n)
            },
            aa = {
                auto: 1,
                scroll: 1
            },
            la = function (t) {
                var e, n = t.event,
                    i = t.target,
                    r = t.axis,
                    s = (n.changedTouches ? n.changedTouches[0] : n).target,
                    o = s._gsap || Fr.core.getCache(s),
                    a = xs();
                if (!o._isScrollT || a - o._isScrollT > 2e3) {
                    for (; s && s !== jr && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !aa[(e = oo(s)).overflowY] && !aa[e.overflowX]);) s = s.parentNode;
                    o._isScroll = s && s !== i && !Os(s) && (aa[(e = oo(s)).overflowY] || aa[e.overflowX]), o._isScrollT = a
                } (o._isScroll || "x" === r) && (n.stopPropagation(), n._gsapAllow = !0)
            },
            ua = function (t, e, n, i) {
                return Ir.create({
                    target: t,
                    capture: !0,
                    debounce: !1,
                    lockAxis: !0,
                    type: e,
                    onWheel: i = i && la,
                    onPress: i,
                    onDrag: i,
                    onScroll: i,
                    onEnable: function () {
                        return n && po(Ur, Ir.eventTypes[0], ha, !1, !0)
                    },
                    onDisable: function () {
                        return mo(Ur, Ir.eventTypes[0], ha, !0)
                    }
                })
            },
            ca = /(input|label|select|textarea)/i,
            ha = function (t) {
                var e = ca.test(t.target.tagName);
                (e || ra) && (t._gsapAllow = !0, ra = e)
            };
        ia.sort = function (t) {
            return Mo.sort(t || function (t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            })
        }, ia.observe = function (t) {
            return new Ir(t)
        }, ia.normalizeScroll = function (t) {
            if (void 0 === t) return rs;
            if (!0 === t && rs) return rs.enable();
            if (!1 === t) return rs && rs.kill(), void (rs = t);
            var e = t instanceof Ir ? t : function (t) {
                Hs(t) || (t = {}), t.preventDefault = t.isNormalizer = t.allowClicks = !0, t.type || (t.type = "wheel,touch"), t.debounce = !!t.debounce, t.id = t.id || "normalizer";
                var e, n, i, r, s, o, a, l, u = t,
                    c = u.normalizeScrollX,
                    h = u.momentum,
                    d = u.allowNestedScroll,
                    f = u.onRelease,
                    p = Cr(t.target) || Br,
                    m = Fr.core.globals().ScrollSmoother,
                    g = m && m.get(),
                    v = ls && (t.content && Cr(t.content) || g && !1 !== t.content && !g.smooth() && g.content()),
                    y = Ar(p, Dr),
                    b = Ar(p, Er),
                    _ = 1,
                    x = (Ir.isTouch && zr.visualViewport ? zr.visualViewport.scale * zr.visualViewport.width : zr.outerWidth) / zr.innerWidth,
                    w = 0,
                    M = Bs(h) ? function () {
                        return h(e)
                    } : function () {
                        return h || 2.8
                    },
                    S = ua(p, t.type, !0, d),
                    T = function () {
                        return r = !1
                    },
                    E = Ps,
                    D = Ps,
                    C = function () {
                        n = Ns(p, Dr), D = Wr(ls ? 1 : 0, n), c && (E = Wr(0, Ns(p, Er))), i = No
                    },
                    A = function () {
                        v._gsap.y = Ls(parseFloat(v._gsap.y) + y.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", y.offset = y.cacheID = 0
                    },
                    P = function () {
                        C(), s.isActive() && s.vars.scrollY > n && (y() > n ? s.progress(1) && y(n) : s.resetTo("scrollY", n))
                    };
                return v && Fr.set(v, {
                    y: "+=0"
                }), t.ignoreCheck = function (t) {
                    return ls && "touchmove" === t.type && function () {
                        if (r) {
                            requestAnimationFrame(T);
                            var t = Ls(e.deltaY / 2),
                                n = D(y.v - t);
                            if (v && n !== y.v + y.offset) {
                                y.offset = n - y.v;
                                var i = Ls((parseFloat(v && v._gsap.y) || 0) - y.offset);
                                v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + i + ", 0, 1)", v._gsap.y = i + "px", y.cacheID = pr.cache, Vo()
                            }
                            return !0
                        }
                        y.offset && A(), r = !0
                    }() || _ > 1.05 && "touchstart" !== t.type || e.isGesturing || t.touches && t.touches.length > 1
                }, t.onPress = function () {
                    r = !1;
                    var t = _;
                    _ = Ls((zr.visualViewport && zr.visualViewport.scale || 1) / x), s.pause(), t !== _ && oa(p, _ > 1.01 || !c && "x"), o = b(), a = y(), C(), i = No
                }, t.onRelease = t.onGestureStart = function (t, e) {
                    if (y.offset && A(), e) {
                        pr.cache++;
                        var i, r, o = M();
                        c && (r = (i = b()) + .05 * o * -t.velocityX / .227, o *= sa(b, i, r, Ns(p, Er)), s.vars.scrollX = E(r)), r = (i = y()) + .05 * o * -t.velocityY / .227, o *= sa(y, i, r, Ns(p, Dr)), s.vars.scrollY = D(r), s.invalidate().duration(o).play(.01), (ls && s.vars.scrollY >= n || i >= n - 1) && Fr.to({}, {
                            onUpdate: P,
                            duration: o
                        })
                    } else l.restart(!0);
                    f && f(t)
                }, t.onWheel = function () {
                    s._ts && s.pause(), xs() - w > 1e3 && (i = 0, w = xs())
                }, t.onChange = function (t, e, n, r, s) {
                    if (No !== i && C(), e && c && b(E(r[2] === e ? o + (t.startX - t.x) : b() + e - r[1])), n) {
                        y.offset && A();
                        var l = s[2] === n,
                            u = l ? a + t.startY - t.y : y() + n - s[1],
                            h = D(u);
                        l && u !== h && (a += h - u), y(h)
                    } (n || e) && Vo()
                }, t.onEnable = function () {
                    oa(p, !c && "x"), ia.addEventListener("refresh", P), po(zr, "resize", P), y.smooth && (y.target.style.scrollBehavior = "auto", y.smooth = b.smooth = !1), S.enable()
                }, t.onDisable = function () {
                    oa(p, !0), mo(zr, "resize", P), ia.removeEventListener("refresh", P), S.kill()
                }, t.lockAxis = !1 !== t.lockAxis, (e = new Ir(t)).iOS = ls, ls && !y() && y(1), ls && Fr.ticker.add(Ps), l = e._dc, s = Fr.to(e, {
                    ease: "power4",
                    paused: !0,
                    inherit: !1,
                    scrollX: c ? "+=0.1" : "+=0",
                    scrollY: "+=0.1",
                    modifiers: {
                        scrollY: ta(y, y(), (function () {
                            return s.pause()
                        }))
                    },
                    onUpdate: Vo,
                    onComplete: l.vars.onComplete
                }), e
            }(t);
            return rs && rs.target === e.target && rs.kill(), Os(e.target) && (rs = e), e
        }, ia.core = {
            _getVelocityProp: Pr,
            _inputObserver: ua,
            _scrollers: pr,
            _proxies: mr,
            bridge: {
                ss: function () {
                    Ms || Ro("scrollStart"), Ms = xs()
                },
                ref: function () {
                    return qr
                }
            }
        }, ks() && Fr.registerPlugin(ia);
        var da, fa, pa, ma, ga, va, ya, ba, _a = function () {
            return "undefined" != typeof window
        },
            xa = function () {
                return da || _a() && (da = window.gsap) && da.registerPlugin && da
            },
            wa = function (t) {
                return "string" == typeof t
            },
            Ma = function (t) {
                return "function" == typeof t
            },
            Sa = function (t, e) {
                var n = "x" === e ? "Width" : "Height",
                    i = "scroll" + n,
                    r = "client" + n;
                return t === pa || t === ma || t === ga ? Math.max(ma[i], ga[i]) - (pa["inner" + n] || ma[r] || ga[r]) : t[i] - t["offset" + n]
            },
            Ta = function (t, e) {
                var n = "scroll" + ("x" === e ? "Left" : "Top");
                return t === pa && (null != t.pageXOffset ? n = "page" + e.toUpperCase() + "Offset" : t = null != ma[n] ? ma : ga),
                    function () {
                        return t[n]
                    }
            },
            Ea = function (t, e) {
                if (!(t = va(t)[0]) || !t.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
                    x: 0,
                    y: 0
                };
                var n = t.getBoundingClientRect(),
                    i = !e || e === pa || e === ga,
                    r = i ? {
                        top: ma.clientTop - (pa.pageYOffset || ma.scrollTop || ga.scrollTop || 0),
                        left: ma.clientLeft - (pa.pageXOffset || ma.scrollLeft || ga.scrollLeft || 0)
                    } : e.getBoundingClientRect(),
                    s = {
                        x: n.left - r.left,
                        y: n.top - r.top
                    };
                return !i && e && (s.x += Ta(e, "x")(), s.y += Ta(e, "y")()), s
            },
            Da = function (t, e, n, i, r) {
                return isNaN(t) || "object" == typeof t ? wa(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i - r : "max" === t ? Sa(e, n) - r : Math.min(Sa(e, n), Ea(t, e)[n] - r) : parseFloat(t) - r
            },
            Ca = function () {
                da = xa(), _a() && da && "undefined" != typeof document && document.body && (pa = window, ga = document.body, ma = document.documentElement, va = da.utils.toArray, da.config({
                    autoKillThreshold: 7
                }), ya = da.config(), fa = 1)
            },
            Aa = {
                version: "3.12.5",
                name: "scrollTo",
                rawVars: 1,
                register: function (t) {
                    da = t, Ca()
                },
                init: function (t, e, n, i, r) {
                    fa || Ca();
                    var s = this,
                        o = da.getProperty(t, "scrollSnapType");
                    s.isWin = t === pa, s.target = t, s.tween = n, e = function (t, e, n, i) {
                        if (Ma(t) && (t = t(e, n, i)), "object" != typeof t) return wa(t) && "max" !== t && "=" !== t.charAt(1) ? {
                            x: t,
                            y: t
                        } : {
                            y: t
                        };
                        if (t.nodeType) return {
                            y: t,
                            x: t
                        };
                        var r, s = {};
                        for (r in t) s[r] = "onAutoKill" !== r && Ma(t[r]) ? t[r](e, n, i) : t[r];
                        return s
                    }(e, i, t, r), s.vars = e, s.autoKill = !!e.autoKill, s.getX = Ta(t, "x"), s.getY = Ta(t, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), ba || (ba = da.core.globals().ScrollTrigger), "smooth" === da.getProperty(t, "scrollBehavior") && da.set(t, {
                        scrollBehavior: "auto"
                    }), o && "none" !== o && (s.snap = 1, s.snapInline = t.style.scrollSnapType, t.style.scrollSnapType = "none"), null != e.x ? (s.add(s, "x", s.x, Da(e.x, t, "x", s.x, e.offsetX || 0), i, r), s._props.push("scrollTo_x")) : s.skipX = 1, null != e.y ? (s.add(s, "y", s.y, Da(e.y, t, "y", s.y, e.offsetY || 0), i, r), s._props.push("scrollTo_y")) : s.skipY = 1
                },
                render: function (t, e) {
                    for (var n, i, r, s, o, a = e._pt, l = e.target, u = e.tween, c = e.autoKill, h = e.xPrev, d = e.yPrev, f = e.isWin, p = e.snap, m = e.snapInline; a;) a.r(t, a.d), a = a._next;
                    n = f || !e.skipX ? e.getX() : h, r = (i = f || !e.skipY ? e.getY() : d) - d, s = n - h, o = ya.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), c && (!e.skipX && (s > o || s < -o) && n < Sa(l, "x") && (e.skipX = 1), !e.skipY && (r > o || r < -o) && i < Sa(l, "y") && (e.skipY = 1), e.skipX && e.skipY && (u.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(u, e.vars.onAutoKillParams || []))), f ? pa.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y) : (e.skipY || (l.scrollTop = e.y), e.skipX || (l.scrollLeft = e.x)), !p || 1 !== t && 0 !== t || (i = l.scrollTop, n = l.scrollLeft, m ? l.style.scrollSnapType = m : l.style.removeProperty("scroll-snap-type"), l.scrollTop = i + 1, l.scrollLeft = n + 1, l.scrollTop = i, l.scrollLeft = n), e.xPrev = e.x, e.yPrev = e.y, ba && ba.update()
                },
                kill: function (t) {
                    var e = "scrollTo" === t,
                        n = this._props.indexOf(t);
                    return (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1), n > -1 && this._props.splice(n, 1), !this._props.length
                }
            };
        Aa.max = Sa, Aa.getOffset = Ea, Aa.buildGetter = Ta, xa() && da.registerPlugin(Aa);
        var Pa, La, Ra, ka, Oa, Ia = function () {
            return "undefined" != typeof window
        },
            Fa = function () {
                return Pa || Ia() && (Pa = window.gsap) && Pa.registerPlugin && Pa
            },
            Na = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
            za = {
                rect: ["width", "height"],
                circle: ["r", "r"],
                ellipse: ["rx", "ry"],
                line: ["x2", "y2"]
            },
            Ua = function (t) {
                return Math.round(1e4 * t) / 1e4
            },
            Ba = function (t) {
                return parseFloat(t) || 0
            },
            ja = function (t, e) {
                var n = Ba(t);
                return ~t.indexOf("%") ? n / 100 * e : n
            },
            Ha = function (t, e) {
                return Ba(t.getAttribute(e))
            },
            Va = Math.sqrt,
            Ga = function (t, e, n, i, r, s) {
                return Va(Math.pow((Ba(n) - Ba(t)) * r, 2) + Math.pow((Ba(i) - Ba(e)) * s, 2))
            },
            Wa = function (t) {
                return console.warn(t)
            },
            $a = function (t) {
                return "non-scaling-stroke" === t.getAttribute("vector-effect")
            },
            Xa = function (t) {
                if (!(t = La(t)[0])) return 0;
                var e, n, i, r, s, o, a, l = t.tagName.toLowerCase(),
                    u = t.style,
                    c = 1,
                    h = 1;
                $a(t) && (h = t.getScreenCTM(), c = Va(h.a * h.a + h.b * h.b), h = Va(h.d * h.d + h.c * h.c));
                try {
                    n = t.getBBox()
                } catch (t) {
                    Wa("Some browsers won't measure invisible elements (like display:none or masks inside defs).")
                }
                var d = n || {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                    f = d.x,
                    p = d.y,
                    m = d.width,
                    g = d.height;
                if (n && (m || g) || !za[l] || (m = Ha(t, za[l][0]), g = Ha(t, za[l][1]), "rect" !== l && "line" !== l && (m *= 2, g *= 2), "line" === l && (f = Ha(t, "x1"), p = Ha(t, "y1"), m = Math.abs(m - f), g = Math.abs(g - p))), "path" === l) r = u.strokeDasharray, u.strokeDasharray = "none", e = t.getTotalLength() || 0, c !== h && Wa("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), e *= (c + h) / 2, u.strokeDasharray = r;
                else if ("rect" === l) e = 2 * m * c + 2 * g * h;
                else if ("line" === l) e = Ga(f, p, f + m, p + g, c, h);
                else if ("polyline" === l || "polygon" === l)
                    for (i = t.getAttribute("points").match(Na) || [], "polygon" === l && i.push(i[0], i[1]), e = 0, s = 2; s < i.length; s += 2) e += Ga(i[s - 2], i[s - 1], i[s], i[s + 1], c, h) || 0;
                else "circle" !== l && "ellipse" !== l || (o = m / 2 * c, a = g / 2 * h, e = Math.PI * (3 * (o + a) - Va((3 * o + a) * (o + 3 * a))));
                return e || 0
            },
            qa = function (t, e) {
                if (!(t = La(t)[0])) return [0, 0];
                e || (e = Xa(t) + 1);
                var n = Ra.getComputedStyle(t),
                    i = n.strokeDasharray || "",
                    r = Ba(n.strokeDashoffset),
                    s = i.indexOf(",");
                return s < 0 && (s = i.indexOf(" ")), (i = s < 0 ? e : Ba(i.substr(0, s))) > e && (i = e), [-r || 0, i - r || 0]
            },
            Ya = function () {
                Ia() && (document, Ra = window, Oa = Pa = Fa(), La = Pa.utils.toArray, ka = -1 !== ((Ra.navigator || {}).userAgent || "").indexOf("Edge"))
            },
            Ka = {
                version: "3.9.1",
                name: "drawSVG",
                register: function (t) {
                    Pa = t, Ya()
                },
                init: function (t, e, n, i, r) {
                    if (!t.getBBox) return !1;
                    Oa || Ya();
                    var s, o, a, l = Xa(t);
                    return this._style = t.style, this._target = t, e + "" == "true" ? e = "0 100%" : e ? -1 === (e + "").indexOf(" ") && (e = "0 " + e) : e = "0 0", o = function (t, e, n) {
                        var i, r, s = t.indexOf(" ");
                        return s < 0 ? (i = void 0 !== n ? n + "" : t, r = t) : (i = t.substr(0, s), r = t.substr(s + 1)), (i = ja(i, e)) > (r = ja(r, e)) ? [r, i] : [i, r]
                    }(e, l, (s = qa(t, l))[0]), this._length = Ua(l), this._dash = Ua(s[1] - s[0]), this._offset = Ua(-s[0]), this._dashPT = this.add(this, "_dash", this._dash, Ua(o[1] - o[0])), this._offsetPT = this.add(this, "_offset", this._offset, Ua(-o[0])), ka && (a = Ra.getComputedStyle(t)).strokeLinecap !== a.strokeLinejoin && (o = Ba(a.strokeMiterlimit), this.add(t.style, "strokeMiterlimit", o, o + .01)), this._live = $a(t) || ~(e + "").indexOf("live"), this._nowrap = ~(e + "").indexOf("nowrap"), this._props.push("drawSVG"), 1
                },
                render: function (t, e) {
                    var n, i, r, s, o = e._pt,
                        a = e._style;
                    if (o) {
                        for (e._live && (n = Xa(e._target)) !== e._length && (i = n / e._length, e._length = n, e._offsetPT && (e._offsetPT.s *= i, e._offsetPT.c *= i), e._dashPT ? (e._dashPT.s *= i, e._dashPT.c *= i) : e._dash *= i); o;) o.r(t, o.d), o = o._next;
                        r = e._dash || t && 1 !== t && 1e-4 || 0, n = e._length - r + .1, s = e._offset, r && s && r + Math.abs(s % e._length) > e._length - .2 && (s += s < 0 ? .1 : -.1) && (n += .1), a.strokeDashoffset = r ? s : s + .001, a.strokeDasharray = n < .2 ? "none" : r ? r + "px," + (e._nowrap ? 999999 : n) + "px" : "0px, 999999px"
                    }
                },
                getLength: Xa,
                getPosition: qa
            };
        Fa() && Pa.registerPlugin(Ka);
        var Ja, Za, Qa, tl, el, nl, il, rl, sl, ol = "transform",
            al = ol + "Origin",
            ll = function (t) {
                var e = t.ownerDocument || t;
                !(ol in t.style) && "msTransform" in t.style && (al = (ol = "msTransform") + "Origin");
                for (; e.parentNode && (e = e.parentNode););
                if (Za = window, il = new yl, e) {
                    Ja = e, Qa = e.documentElement, tl = e.body, (rl = Ja.createElementNS("http://www.w3.org/2000/svg", "g")).style.transform = "none";
                    var n = e.createElement("div"),
                        i = e.createElement("div"),
                        r = e && (e.body || e.firstElementChild);
                    r && r.appendChild && (r.appendChild(n), n.appendChild(i), n.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), sl = i.offsetParent !== n, r.removeChild(n))
                }
                return e
            },
            ul = [],
            cl = [],
            hl = function () {
                return Za.pageYOffset || Ja.scrollTop || Qa.scrollTop || tl.scrollTop || 0
            },
            dl = function () {
                return Za.pageXOffset || Ja.scrollLeft || Qa.scrollLeft || tl.scrollLeft || 0
            },
            fl = function (t) {
                return t.ownerSVGElement || ("svg" === (t.tagName + "").toLowerCase() ? t : null)
            },
            pl = function t(e) {
                return "fixed" === Za.getComputedStyle(e).position || ((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0)
            },
            ml = function t(e, n) {
                if (e.parentNode && (Ja || ll(e))) {
                    var i = fl(e),
                        r = i ? i.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                        s = i ? n ? "rect" : "g" : "div",
                        o = 2 !== n ? 0 : 100,
                        a = 3 === n ? 100 : 0,
                        l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                        u = Ja.createElementNS ? Ja.createElementNS(r.replace(/^https/, "http"), s) : Ja.createElement(s);
                    return n && (i ? (nl || (nl = t(e)), u.setAttribute("width", .01), u.setAttribute("height", .01), u.setAttribute("transform", "translate(" + o + "," + a + ")"), nl.appendChild(u)) : (el || ((el = t(e)).style.cssText = l), u.style.cssText = l + "width:0.1px;height:0.1px;top:" + a + "px;left:" + o + "px", el.appendChild(u))), u
                }
                throw "Need document and parent."
            },
            gl = function (t) {
                var e, n = t.getCTM();
                return n || (e = t.style[ol], t.style[ol] = "none", t.appendChild(rl), n = rl.getCTM(), t.removeChild(rl), e ? t.style[ol] = e : t.style.removeProperty(ol.replace(/([A-Z])/g, "-$1").toLowerCase())), n || il.clone()
            },
            vl = function (t, e, n, i, r, s, o) {
                return t.a = e, t.b = n, t.c = i, t.d = r, t.e = s, t.f = o, t
            },
            yl = function () {
                function t(t, e, n, i, r, s) {
                    void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === s && (s = 0), vl(this, t, e, n, i, r, s)
                }
                var e = t.prototype;
                return e.inverse = function () {
                    var t = this.a,
                        e = this.b,
                        n = this.c,
                        i = this.d,
                        r = this.e,
                        s = this.f,
                        o = t * i - e * n || 1e-10;
                    return vl(this, i / o, -e / o, -n / o, t / o, (n * s - i * r) / o, -(t * s - e * r) / o)
                }, e.multiply = function (t) {
                    var e = this.a,
                        n = this.b,
                        i = this.c,
                        r = this.d,
                        s = this.e,
                        o = this.f,
                        a = t.a,
                        l = t.c,
                        u = t.b,
                        c = t.d,
                        h = t.e,
                        d = t.f;
                    return vl(this, a * e + u * i, a * n + u * r, l * e + c * i, l * n + c * r, s + h * e + d * i, o + h * n + d * r)
                }, e.clone = function () {
                    return new t(this.a, this.b, this.c, this.d, this.e, this.f)
                }, e.equals = function (t) {
                    var e = this.a,
                        n = this.b,
                        i = this.c,
                        r = this.d,
                        s = this.e,
                        o = this.f;
                    return e === t.a && n === t.b && i === t.c && r === t.d && s === t.e && o === t.f
                }, e.apply = function (t, e) {
                    void 0 === e && (e = {});
                    var n = t.x,
                        i = t.y,
                        r = this.a,
                        s = this.b,
                        o = this.c,
                        a = this.d,
                        l = this.e,
                        u = this.f;
                    return e.x = n * r + i * o + l || 0, e.y = n * s + i * a + u || 0, e
                }, t
            }();

        function bl(t, e, n, i) {
            if (!t || !t.parentNode || (Ja || ll(t)).documentElement === t) return new yl;
            var r = function (t) {
                for (var e, n; t && t !== tl;)(n = t._gsap) && n.uncache && n.get(t, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), e ? e.push(n) : e = [n]), t = t.parentNode;
                return e
            }(t),
                s = fl(t) ? ul : cl,
                o = function (t, e) {
                    var n, i, r, s, o, a, l = fl(t),
                        u = t === l,
                        c = l ? ul : cl,
                        h = t.parentNode;
                    if (t === Za) return t;
                    if (c.length || c.push(ml(t, 1), ml(t, 2), ml(t, 3)), n = l ? nl : el, l) u ? (s = -(r = gl(t)).e / r.a, o = -r.f / r.d, i = il) : t.getBBox ? (r = t.getBBox(), i = (i = t.transform ? t.transform.baseVal : {}).numberOfItems ? i.numberOfItems > 1 ? function (t) {
                        for (var e = new yl, n = 0; n < t.numberOfItems; n++) e.multiply(t.getItem(n).matrix);
                        return e
                    }(i) : i.getItem(0).matrix : il, s = i.a * r.x + i.c * r.y, o = i.b * r.x + i.d * r.y) : (i = new yl, s = o = 0), e && "g" === t.tagName.toLowerCase() && (s = o = 0), (u ? l : h).appendChild(n), n.setAttribute("transform", "matrix(" + i.a + "," + i.b + "," + i.c + "," + i.d + "," + (i.e + s) + "," + (i.f + o) + ")");
                    else {
                        if (s = o = 0, sl)
                            for (i = t.offsetParent, r = t; r && (r = r.parentNode) && r !== i && r.parentNode;)(Za.getComputedStyle(r)[ol] + "").length > 4 && (s = r.offsetLeft, o = r.offsetTop, r = 0);
                        if ("absolute" !== (a = Za.getComputedStyle(t)).position && "fixed" !== a.position)
                            for (i = t.offsetParent; h && h !== i;) s += h.scrollLeft || 0, o += h.scrollTop || 0, h = h.parentNode;
                        (r = n.style).top = t.offsetTop - o + "px", r.left = t.offsetLeft - s + "px", r[ol] = a[ol], r[al] = a[al], r.position = "fixed" === a.position ? "fixed" : "absolute", t.parentNode.appendChild(n)
                    }
                    return n
                }(t, n),
                a = s[0].getBoundingClientRect(),
                l = s[1].getBoundingClientRect(),
                u = s[2].getBoundingClientRect(),
                c = o.parentNode,
                h = !i && pl(t),
                d = new yl((l.left - a.left) / 100, (l.top - a.top) / 100, (u.left - a.left) / 100, (u.top - a.top) / 100, a.left + (h ? 0 : dl()), a.top + (h ? 0 : hl()));
            if (c.removeChild(o), r)
                for (a = r.length; a--;)(l = r[a]).scaleX = l.scaleY = 0, l.renderTransform(1, l);
            return e ? d.inverse() : d
        }
        var _l, xl, wl, Ml, Sl, Tl, El, Dl, Cl = 1,
            Al = function (t, e) {
                return t.actions.forEach((function (t) {
                    return t.vars[e] && t.vars[e](t)
                }))
            },
            Pl = {},
            Ll = 180 / Math.PI,
            Rl = Math.PI / 180,
            kl = {},
            Ol = {},
            Il = {},
            Fl = function (t) {
                return "string" == typeof t ? t.split(" ").join("").split(",") : t
            },
            Nl = Fl("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"),
            zl = Fl("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"),
            Ul = function (t) {
                return _l(t)[0] || console.warn("Element not found:", t)
            },
            Bl = function (t) {
                return Math.round(1e4 * t) / 1e4 || 0
            },
            jl = function (t, e, n) {
                return t.forEach((function (t) {
                    return t.classList[n](e)
                }))
            },
            Hl = {
                zIndex: 1,
                kill: 1,
                simple: 1,
                spin: 1,
                clearProps: 1,
                targets: 1,
                toggleClass: 1,
                onComplete: 1,
                onUpdate: 1,
                onInterrupt: 1,
                onStart: 1,
                delay: 1,
                repeat: 1,
                repeatDelay: 1,
                yoyo: 1,
                scale: 1,
                fade: 1,
                absolute: 1,
                props: 1,
                onEnter: 1,
                onLeave: 1,
                custom: 1,
                paused: 1,
                nested: 1,
                prune: 1,
                absoluteOnLeave: 1
            },
            Vl = {
                zIndex: 1,
                simple: 1,
                clearProps: 1,
                scale: 1,
                absolute: 1,
                fitChild: 1,
                getVars: 1,
                props: 1
            },
            Gl = function (t) {
                return t.replace(/([A-Z])/g, "-$1").toLowerCase()
            },
            Wl = function (t, e) {
                var n, i = {};
                for (n in t) e[n] || (i[n] = t[n]);
                return i
            },
            $l = {},
            Xl = function (t) {
                var e = $l[t] = Fl(t);
                return Il[t] = e.concat(zl), e
            },
            ql = function t(e, n, i) {
                void 0 === i && (i = 0);
                for (var r = e.parentNode, s = 1e3 * Math.pow(10, i) * (n ? -1 : 1), o = n ? 900 * -s : 0; e;) o += s, e = e.previousSibling;
                return r ? o + t(r, n, i + 1) : o
            },
            Yl = function (t, e, n) {
                return t.forEach((function (t) {
                    return t.d = ql(n ? t.element : t.t, e)
                })), t.sort((function (t, e) {
                    return t.d - e.d
                })), t
            },
            Kl = function (t, e) {
                for (var n, i, r = t.element.style, s = t.css = t.css || [], o = e.length; o--;) i = r[n = e[o]] || r.getPropertyValue(n), s.push(i ? n : Ol[n] || (Ol[n] = Gl(n)), i);
                return r
            },
            Jl = function (t) {
                var e = t.css,
                    n = t.element.style,
                    i = 0;
                for (t.cache.uncache = 1; i < e.length; i += 2) e[i + 1] ? n[e[i]] = e[i + 1] : n.removeProperty(e[i]);
                !e[e.indexOf("transform") + 1] && n.translate && (n.removeProperty("translate"), n.removeProperty("scale"), n.removeProperty("rotate"))
            },
            Zl = function (t, e) {
                t.forEach((function (t) {
                    return t.a.cache.uncache = 1
                })), e || t.finalStates.forEach(Jl)
            },
            Ql = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","),
            tu = function (t, e, n) {
                var i, r, s, o = t.element,
                    a = t.width,
                    l = t.height,
                    u = t.uncache,
                    c = t.getProp,
                    h = o.style,
                    d = 4;
                if ("object" != typeof e && (e = t), wl && 1 !== n) return wl._abs.push({
                    t: o,
                    b: t,
                    a: t,
                    sd: 0
                }), wl._final.push((function () {
                    return (t.cache.uncache = 1) && Jl(t)
                })), o;
                for (r = "none" === c("display"), t.isVisible && !r || (r && (Kl(t, ["display"]).display = e.display), t.matrix = e.matrix, t.width = a = t.width || e.width, t.height = l = t.height || e.height), Kl(t, Ql), s = window.getComputedStyle(o); d--;) h[Ql[d]] = s[Ql[d]];
                if (h.gridArea = "1 / 1 / 1 / 1", h.transition = "none", h.position = "absolute", h.width = a + "px", h.height = l + "px", h.top || (h.top = "0px"), h.left || (h.left = "0px"), u) i = new yu(o);
                else if ((i = Wl(t, kl)).position = "absolute", t.simple) {
                    var f = o.getBoundingClientRect();
                    i.matrix = new yl(1, 0, 0, 1, f.left + dl(), f.top + hl())
                } else i.matrix = bl(o, !1, !1, !0);
                return i = au(i, t, !0), t.x = Tl(i.x, .01), t.y = Tl(i.y, .01), o
            },
            eu = function (t, e) {
                return !0 !== e && (e = _l(e), t = t.filter((function (t) {
                    if (-1 !== e.indexOf((t.sd < 0 ? t.b : t.a).element)) return !0;
                    t.t._gsap.renderTransform(1), t.b.isVisible && (t.t.style.width = t.b.width + "px", t.t.style.height = t.b.height + "px")
                }))), t
            },
            nu = function (t) {
                return Yl(t, !0).forEach((function (t) {
                    return (t.a.isVisible || t.b.isVisible) && tu(t.sd < 0 ? t.b : t.a, t.b, 1)
                }))
            },
            iu = function (t, e, n, i) {
                return t instanceof yu ? t : t instanceof vu ? function (t, e) {
                    return e && t.idLookup[iu(e).id] || t.elementStates[0]
                }(t, i) : new yu("string" == typeof t ? Ul(t) || console.warn(t + " not found") : t, e, n)
            },
            ru = function (t, e) {
                var n, i = t.style || t;
                for (n in e) i[n] = e[n]
            },
            su = function (t) {
                return t.map((function (t) {
                    return t.element
                }))
            },
            ou = function (t, e, n) {
                return t && e.length && n.add(t(su(e), n, new vu(e, 0, !0)), 0)
            },
            au = function (t, e, n, i, r, s) {
                var o, a, l, u, c, h, d, f = t.element,
                    p = t.cache,
                    m = t.parent,
                    g = t.x,
                    v = t.y,
                    y = e.width,
                    b = e.height,
                    _ = e.scaleX,
                    x = e.scaleY,
                    w = e.rotation,
                    M = e.bounds,
                    S = s && El && El(f, "transform"),
                    T = t,
                    E = e.matrix,
                    D = E.e,
                    C = E.f,
                    A = t.bounds.width !== M.width || t.bounds.height !== M.height || t.scaleX !== _ || t.scaleY !== x || t.rotation !== w,
                    P = !A && t.simple && e.simple && !r;
                return P || !m ? (_ = x = 1, w = o = 0) : (c = function (t) {
                    var e = t._gsap || xl.core.getCache(t);
                    return e.gmCache === xl.ticker.frame ? e.gMatrix : (e.gmCache = xl.ticker.frame, e.gMatrix = bl(t, !0, !1, !0))
                }(m), h = c.clone().multiply(e.ctm ? e.matrix.clone().multiply(e.ctm) : e.matrix), w = Bl(Math.atan2(h.b, h.a) * Ll), o = Bl(Math.atan2(h.c, h.d) * Ll + w) % 360, _ = Math.sqrt(Math.pow(h.a, 2) + Math.pow(h.b, 2)), x = Math.sqrt(Math.pow(h.c, 2) + Math.pow(h.d, 2)) * Math.cos(o * Rl), r && (r = _l(r)[0], u = xl.getProperty(r), d = r.getBBox && "function" == typeof r.getBBox && r.getBBox(), T = {
                    scaleX: u("scaleX"),
                    scaleY: u("scaleY"),
                    width: d ? d.width : Math.ceil(parseFloat(u("width", "px"))),
                    height: d ? d.height : parseFloat(u("height", "px"))
                }), p.rotation = w + "deg", p.skewX = o + "deg"), n ? (_ *= y !== T.width && T.width ? y / T.width : 1, x *= b !== T.height && T.height ? b / T.height : 1, p.scaleX = _, p.scaleY = x) : (y = Tl(y * _ / T.scaleX, 0), b = Tl(b * x / T.scaleY, 0), f.style.width = y + "px", f.style.height = b + "px"), i && ru(f, e.props), P || !m ? (g += D - t.matrix.e, v += C - t.matrix.f) : A || m !== e.parent ? (p.renderTransform(1, p), h = bl(r || f, !1, !1, !0), a = c.apply({
                    x: h.e,
                    y: h.f
                }), g += (l = c.apply({
                    x: D,
                    y: C
                })).x - a.x, v += l.y - a.y) : (c.e = c.f = 0, g += (l = c.apply({
                    x: D - t.matrix.e,
                    y: C - t.matrix.f
                })).x, v += l.y), g = Tl(g, .02), v = Tl(v, .02), !s || s instanceof yu ? (p.x = g + "px", p.y = v + "px", p.renderTransform(1, p)) : S && S.revert(), s && (s.x = g, s.y = v, s.rotation = w, s.skewX = o, n ? (s.scaleX = _, s.scaleY = x) : (s.width = y, s.height = b)), s || p
            },
            lu = function (t, e) {
                return t instanceof vu ? t : new vu(t, e)
            },
            uu = function (t, e, n) {
                var i = t.idLookup[n],
                    r = t.alt[n];
                return !r.isVisible || (e.getElementState(r.element) || r).isVisible && i.isVisible ? i : r
            },
            cu = [],
            hu = "width,height,overflowX,overflowY".split(","),
            du = function (t) {
                if (t !== Dl) {
                    var e = Sl.style,
                        n = Sl.clientWidth === window.outerWidth,
                        i = Sl.clientHeight === window.outerHeight,
                        r = 4;
                    if (t && (n || i)) {
                        for (; r--;) cu[r] = e[hu[r]];
                        n && (e.width = Sl.clientWidth + "px", e.overflowY = "hidden"), i && (e.height = Sl.clientHeight + "px", e.overflowX = "hidden"), Dl = t
                    } else if (Dl) {
                        for (; r--;) cu[r] ? e[hu[r]] = cu[r] : e.removeProperty(Gl(hu[r]));
                        Dl = t
                    }
                }
            },
            fu = function (t, e, n, i) {
                t instanceof vu && e instanceof vu || console.warn("Not a valid state object.");
                var r, s, o, a, l, u, c, h, d, f, p, m, g, v, y, b = n = n || {},
                    _ = b.clearProps,
                    x = b.onEnter,
                    w = b.onLeave,
                    M = b.absolute,
                    S = b.absoluteOnLeave,
                    T = b.custom,
                    E = b.delay,
                    D = b.paused,
                    C = b.repeat,
                    A = b.repeatDelay,
                    P = b.yoyo,
                    L = b.toggleClass,
                    R = b.nested,
                    k = b.zIndex,
                    O = b.scale,
                    I = b.fade,
                    F = b.stagger,
                    N = b.spin,
                    z = b.prune,
                    U = ("props" in n ? n : t).props,
                    B = Wl(n, Hl),
                    j = xl.timeline({
                        delay: E,
                        paused: D,
                        repeat: C,
                        repeatDelay: A,
                        yoyo: P,
                        data: "isFlip"
                    }),
                    H = B,
                    V = [],
                    G = [],
                    W = [],
                    $ = [],
                    X = !0 === N ? 1 : N || 0,
                    q = "function" == typeof N ? N : function () {
                        return X
                    },
                    Y = t.interrupted || e.interrupted,
                    K = j[1 !== i ? "to" : "from"];
                for (s in e.idLookup) p = e.alt[s] ? uu(e, t, s) : e.idLookup[s], l = p.element, f = t.idLookup[s], t.alt[s] && l === f.element && (t.alt[s].isVisible || !p.isVisible) && (f = t.alt[s]), f ? (u = {
                    t: l,
                    b: f,
                    a: p,
                    sd: f.element === l ? 0 : p.isVisible ? 1 : -1
                }, W.push(u), u.sd && (u.sd < 0 && (u.b = p, u.a = f), Y && Kl(u.b, U ? Il[U] : zl), I && W.push(u.swap = {
                    t: f.element,
                    b: u.b,
                    a: u.a,
                    sd: -u.sd,
                    swap: u
                })), l._flip = f.element._flip = wl ? wl.timeline : j) : p.isVisible && (W.push({
                    t: l,
                    b: Wl(p, {
                        isVisible: 1
                    }),
                    a: p,
                    sd: 0,
                    entering: 1
                }), l._flip = wl ? wl.timeline : j);
                U && ($l[U] || Xl(U)).forEach((function (t) {
                    return B[t] = function (e) {
                        return W[e].a.props[t]
                    }
                })), W.finalStates = d = [], m = function () {
                    for (Yl(W), du(!0), a = 0; a < W.length; a++) u = W[a], g = u.a, v = u.b, !z || g.isDifferent(v) || u.entering ? (l = u.t, R && !(u.sd < 0) && a && (g.matrix = bl(l, !1, !1, !0)), v.isVisible && g.isVisible ? (u.sd < 0 ? (c = new yu(l, U, t.simple), au(c, g, O, 0, 0, c), c.matrix = bl(l, !1, !1, !0), c.css = u.b.css, u.a = g = c, I && (l.style.opacity = Y ? v.opacity : g.opacity), F && $.push(l)) : u.sd > 0 && I && (l.style.opacity = Y ? g.opacity - v.opacity : "0"), au(g, v, O, U)) : v.isVisible !== g.isVisible && (v.isVisible ? g.isVisible || (v.css = g.css, G.push(v), W.splice(a--, 1), M && R && au(g, v, O, U)) : (g.isVisible && V.push(g), W.splice(a--, 1))), O || (l.style.maxWidth = Math.max(g.width, v.width) + "px", l.style.maxHeight = Math.max(g.height, v.height) + "px", l.style.minWidth = Math.min(g.width, v.width) + "px", l.style.minHeight = Math.min(g.height, v.height) + "px"), R && L && l.classList.add(L)) : W.splice(a--, 1), d.push(g);
                    var e;
                    if (L && (e = d.map((function (t) {
                        return t.element
                    })), R && e.forEach((function (t) {
                        return t.classList.remove(L)
                    }))), du(!1), O ? (B.scaleX = function (t) {
                        return W[t].a.scaleX
                    }, B.scaleY = function (t) {
                        return W[t].a.scaleY
                    }) : (B.width = function (t) {
                        return W[t].a.width + "px"
                    }, B.height = function (t) {
                        return W[t].a.height + "px"
                    }, B.autoRound = n.autoRound || !1), B.x = function (t) {
                        return W[t].a.x + "px"
                    }, B.y = function (t) {
                        return W[t].a.y + "px"
                    }, B.rotation = function (t) {
                        return W[t].a.rotation + (N ? 360 * q(t, h[t], h) : 0)
                    }, B.skewX = function (t) {
                        return W[t].a.skewX
                    }, h = W.map((function (t) {
                        return t.t
                    })), (k || 0 === k) && (B.modifiers = {
                        zIndex: function () {
                            return k
                        }
                    }, B.zIndex = k, B.immediateRender = !1 !== n.immediateRender), I && (B.opacity = function (t) {
                        return W[t].sd < 0 ? 0 : W[t].sd > 0 ? W[t].a.opacity : "+=0"
                    }), $.length) {
                        F = xl.utils.distribute(F);
                        var i = h.slice($.length);
                        B.stagger = function (t, e) {
                            return F(~$.indexOf(e) ? h.indexOf(W[t].swap.t) : t, e, i)
                        }
                    }
                    if (Nl.forEach((function (t) {
                        return n[t] && j.eventCallback(t, n[t], n[t + "Params"])
                    })), T && h.length)
                        for (s in H = Wl(B, Hl), "scale" in T && (T.scaleX = T.scaleY = T.scale, delete T.scale), T) (r = Wl(T[s], Vl))[s] = B[s], !("duration" in r) && "duration" in B && (r.duration = B.duration), r.stagger = B.stagger, K.call(j, h, r, 0), delete H[s];
                    (h.length || G.length || V.length) && (L && j.add((function () {
                        return jl(e, L, j._zTime < 0 ? "remove" : "add")
                    }), 0) && !D && jl(e, L, "add"), h.length && K.call(j, h, H, 0)), ou(x, V, j), ou(w, G, j);
                    var f = wl && wl.timeline;
                    f && (f.add(j, 0), wl._final.push((function () {
                        return Zl(W, !_)
                    }))), o = j.duration(), j.call((function () {
                        var t = j.time() >= o;
                        t && !f && Zl(W, !_), L && jl(e, L, t ? "remove" : "add")
                    }))
                }, S && (M = W.filter((function (t) {
                    return !t.sd && !t.a.isVisible && t.b.isVisible
                })).map((function (t) {
                    return t.a.element
                }))), wl ? (M && (y = wl._abs).push.apply(y, eu(W, M)), wl._run.push(m)) : (M && nu(eu(W, M)), m());
                var J = wl ? wl.timeline : j;
                return J.revert = function () {
                    return mu(J, 1, 1)
                }, J
            },
            pu = function t(e) {
                e.vars.onInterrupt && e.vars.onInterrupt.apply(e, e.vars.onInterruptParams || []), e.getChildren(!0, !1, !0).forEach(t)
            },
            mu = function (t, e, n) {
                if (t && t.progress() < 1 && (!t.paused() || n)) return e && (pu(t), e < 2 && t.progress(1), t.kill()), !0
            },
            gu = function (t) {
                for (var e, n = t.idLookup = {}, i = t.alt = {}, r = t.elementStates, s = r.length; s--;) n[(e = r[s]).id] ? i[e.id] = e : n[e.id] = e
            },
            vu = function () {
                function t(t, e, n) {
                    if (this.props = e && e.props, this.simple = !(!e || !e.simple), n) this.targets = su(t), this.elementStates = t, gu(this);
                    else {
                        this.targets = _l(t);
                        var i = e && (!1 === e.kill || e.batch && !e.kill);
                        wl && !i && wl._kill.push(this), this.update(i || !!wl)
                    }
                }
                var e = t.prototype;
                return e.update = function (t) {
                    var e = this;
                    return this.elementStates = this.targets.map((function (t) {
                        return new yu(t, e.props, e.simple)
                    })), gu(this), this.interrupt(t), this.recordInlineStyles(), this
                }, e.clear = function () {
                    return this.targets.length = this.elementStates.length = 0, gu(this), this
                }, e.fit = function (t, e, n) {
                    for (var i, r, s = Yl(this.elementStates.slice(0), !1, !0), o = (t || this).idLookup, a = 0; a < s.length; a++) i = s[a], n && (i.matrix = bl(i.element, !1, !1, !0)), (r = o[i.id]) && au(i, r, e, !0, 0, i), i.matrix = bl(i.element, !1, !1, !0);
                    return this
                }, e.getProperty = function (t, e) {
                    var n = this.getElementState(t) || kl;
                    return (e in n ? n : n.props || kl)[e]
                }, e.add = function (t) {
                    for (var e, n, i, r = t.targets.length, s = this.idLookup, o = this.alt; r--;)(i = s[(n = t.elementStates[r]).id]) && (n.element === i.element || o[n.id] && o[n.id].element === n.element) ? (e = this.elementStates.indexOf(n.element === i.element ? i : o[n.id]), this.targets.splice(e, 1, t.targets[r]), this.elementStates.splice(e, 1, n)) : (this.targets.push(t.targets[r]), this.elementStates.push(n));
                    return t.interrupted && (this.interrupted = !0), t.simple || (this.simple = !1), gu(this), this
                }, e.compare = function (t) {
                    var e, n, i, r, s, o, a, l, u = t.idLookup,
                        c = this.idLookup,
                        h = [],
                        d = [],
                        f = [],
                        p = [],
                        m = [],
                        g = t.alt,
                        v = this.alt,
                        y = function (t, e, n) {
                            return (t.isVisible !== e.isVisible ? t.isVisible ? f : p : t.isVisible ? d : h).push(n) && m.push(n)
                        },
                        b = function (t, e, n) {
                            return m.indexOf(n) < 0 && y(t, e, n)
                        };
                    for (i in u) s = g[i], o = v[i], r = (e = s ? uu(t, this, i) : u[i]).element, n = c[i], o ? (l = n.isVisible || !o.isVisible && r === n.element ? n : o, (a = !s || e.isVisible || s.isVisible || l.element !== s.element ? e : s).isVisible && l.isVisible && a.element !== l.element ? ((a.isDifferent(l) ? d : h).push(a.element, l.element), m.push(a.element, l.element)) : y(a, l, a.element), s && a.element === s.element && (s = u[i]), b(a.element !== n.element && s ? s : a, n, n.element), b(s && s.element === o.element ? s : a, o, o.element), s && b(s, o.element === s.element ? o : n, s.element)) : (n ? n.isDifferent(e) ? y(e, n, r) : h.push(r) : f.push(r), s && b(s, n, s.element));
                    for (i in c) u[i] || (p.push(c[i].element), v[i] && p.push(v[i].element));
                    return {
                        changed: d,
                        unchanged: h,
                        enter: f,
                        leave: p
                    }
                }, e.recordInlineStyles = function () {
                    for (var t = Il[this.props] || zl, e = this.elementStates.length; e--;) Kl(this.elementStates[e], t)
                }, e.interrupt = function (t) {
                    var e = this,
                        n = [];
                    this.targets.forEach((function (i) {
                        var r = i._flip,
                            s = mu(r, t ? 0 : 1);
                        t && s && n.indexOf(r) < 0 && r.add((function () {
                            return e.updateVisibility()
                        })), s && n.push(r)
                    })), !t && n.length && this.updateVisibility(), this.interrupted || (this.interrupted = !!n.length)
                }, e.updateVisibility = function () {
                    this.elementStates.forEach((function (t) {
                        var e = t.element.getBoundingClientRect();
                        t.isVisible = !!(e.width || e.height || e.top || e.left), t.uncache = 1
                    }))
                }, e.getElementState = function (t) {
                    return this.elementStates[this.targets.indexOf(Ul(t))]
                }, e.makeAbsolute = function () {
                    return Yl(this.elementStates.slice(0), !0, !0).map(tu)
                }, t
            }(),
            yu = function () {
                function t(t, e, n) {
                    this.element = t, this.update(e, n)
                }
                var e = t.prototype;
                return e.isDifferent = function (t) {
                    var e = this.bounds,
                        n = t.bounds;
                    return e.top !== n.top || e.left !== n.left || e.width !== n.width || e.height !== n.height || !this.matrix.equals(t.matrix) || this.opacity !== t.opacity || this.props && t.props && JSON.stringify(this.props) !== JSON.stringify(t.props)
                }, e.update = function (t, e) {
                    var n, i, r = this,
                        s = r.element,
                        o = xl.getProperty(s),
                        a = xl.core.getCache(s),
                        l = s.getBoundingClientRect(),
                        u = s.getBBox && "function" == typeof s.getBBox && "svg" !== s.nodeName.toLowerCase() && s.getBBox(),
                        c = e ? new yl(1, 0, 0, 1, l.left + dl(), l.top + hl()) : bl(s, !1, !1, !0);
                    r.getProp = o, r.element = s, r.id = ((i = (n = s).getAttribute("data-flip-id")) || n.setAttribute("data-flip-id", i = "auto-" + Cl++), i), r.matrix = c, r.cache = a, r.bounds = l, r.isVisible = !!(l.width || l.height || l.left || l.top), r.display = o("display"), r.position = o("position"), r.parent = s.parentNode, r.x = o("x"), r.y = o("y"), r.scaleX = a.scaleX, r.scaleY = a.scaleY, r.rotation = o("rotation"), r.skewX = o("skewX"), r.opacity = o("opacity"), r.width = u ? u.width : Tl(o("width", "px"), .04), r.height = u ? u.height : Tl(o("height", "px"), .04), t && function (t, e) {
                        for (var n = xl.getProperty(t.element, null, "native"), i = t.props = {}, r = e.length; r--;) i[e[r]] = (n(e[r]) + "").trim();
                        i.zIndex && (i.zIndex = parseFloat(i.zIndex) || 0)
                    }(r, $l[t] || Xl(t)), r.ctm = s.getCTM && "svg" === s.nodeName.toLowerCase() && gl(s).inverse(), r.simple = e || 1 === Bl(c.a) && !Bl(c.b) && !Bl(c.c) && 1 === Bl(c.d), r.uncache = 0
                }, t
            }(),
            bu = function () {
                function t(t, e) {
                    this.vars = t, this.batch = e, this.states = [], this.timeline = e.timeline
                }
                var e = t.prototype;
                return e.getStateById = function (t) {
                    for (var e = this.states.length; e--;)
                        if (this.states[e].idLookup[t]) return this.states[e]
                }, e.kill = function () {
                    this.batch.remove(this)
                }, t
            }(),
            _u = function () {
                function t(t) {
                    this.id = t, this.actions = [], this._kill = [], this._final = [], this._abs = [], this._run = [], this.data = {}, this.state = new vu, this.timeline = xl.timeline()
                }
                var e = t.prototype;
                return e.add = function (t) {
                    var e = this.actions.filter((function (e) {
                        return e.vars === t
                    }));
                    return e.length ? e[0] : (e = new bu("function" == typeof t ? {
                        animate: t
                    } : t, this), this.actions.push(e), e)
                }, e.remove = function (t) {
                    var e = this.actions.indexOf(t);
                    return e >= 0 && this.actions.splice(e, 1), this
                }, e.getState = function (t) {
                    var e = this,
                        n = wl,
                        i = Ml;
                    return wl = this, this.state.clear(), this._kill.length = 0, this.actions.forEach((function (n) {
                        n.vars.getState && (n.states.length = 0, Ml = n, n.state = n.vars.getState(n)), t && n.states.forEach((function (t) {
                            return e.state.add(t)
                        }))
                    })), Ml = i, wl = n, this.killConflicts(), this
                }, e.animate = function () {
                    var t, e, n = this,
                        i = wl,
                        r = this.timeline,
                        s = this.actions.length;
                    for (wl = this, r.clear(), this._abs.length = this._final.length = this._run.length = 0, this.actions.forEach((function (t) {
                        t.vars.animate && t.vars.animate(t);
                        var e, n, i = t.vars.onEnter,
                            r = t.vars.onLeave,
                            s = t.targets;
                        s && s.length && (i || r) && (e = new vu, t.states.forEach((function (t) {
                            return e.add(t)
                        })), (n = e.compare(xu.getState(s))).enter.length && i && i(n.enter), n.leave.length && r && r(n.leave))
                    })), nu(this._abs), this._run.forEach((function (t) {
                        return t()
                    })), e = r.duration(), t = this._final.slice(0), r.add((function () {
                        e <= r.time() && (t.forEach((function (t) {
                            return t()
                        })), Al(n, "onComplete"))
                    })), wl = i; s--;) this.actions[s].vars.once && this.actions[s].kill();
                    return Al(this, "onStart"), r.restart(), this
                }, e.loadState = function (t) {
                    t || (t = function () {
                        return 0
                    });
                    var e = [];
                    return this.actions.forEach((function (n) {
                        if (n.vars.loadState) {
                            var i, r = function r(s) {
                                s && (n.targets = s), ~(i = e.indexOf(r)) && (e.splice(i, 1), e.length || t())
                            };
                            e.push(r), n.vars.loadState(r)
                        }
                    })), e.length || t(), this
                }, e.setState = function () {
                    return this.actions.forEach((function (t) {
                        return t.targets = t.vars.setState && t.vars.setState(t)
                    })), this
                }, e.killConflicts = function (t) {
                    return this.state.interrupt(t), this._kill.forEach((function (e) {
                        return e.interrupt(t)
                    })), this
                }, e.run = function (t, e) {
                    var n = this;
                    return this !== wl && (t || this.getState(e), this.loadState((function () {
                        n._killed || (n.setState(), n.animate())
                    }))), this
                }, e.clear = function (t) {
                    this.state.clear(), t || (this.actions.length = 0)
                }, e.getStateById = function (t) {
                    for (var e, n = this.actions.length; n--;)
                        if (e = this.actions[n].getStateById(t)) return e;
                    return this.state.idLookup[t] && this.state
                }, e.kill = function () {
                    this._killed = 1, this.clear(), delete Pl[this.id]
                }, t
            }(),
            xu = function () {
                function t() { }
                return t.getState = function (e, n) {
                    var i = lu(e, n);
                    return Ml && Ml.states.push(i), n && n.batch && t.batch(n.batch).state.add(i), i
                }, t.from = function (t, e) {
                    return "clearProps" in (e = e || {}) || (e.clearProps = !0), fu(t, lu(e.targets || t.targets, {
                        props: e.props || t.props,
                        simple: e.simple,
                        kill: !!e.kill
                    }), e, -1)
                }, t.to = function (t, e) {
                    return fu(t, lu(e.targets || t.targets, {
                        props: e.props || t.props,
                        simple: e.simple,
                        kill: !!e.kill
                    }), e, 1)
                }, t.fromTo = function (t, e, n) {
                    return fu(t, e, n)
                }, t.fit = function (t, e, n) {
                    var i = n ? Wl(n, Vl) : {},
                        r = n || i,
                        s = r.absolute,
                        o = r.scale,
                        a = r.getVars,
                        l = r.props,
                        u = r.runBackwards,
                        c = r.onComplete,
                        h = r.simple,
                        d = n && n.fitChild && Ul(n.fitChild),
                        f = iu(e, l, h, t),
                        p = iu(t, 0, h, f),
                        m = l ? Il[l] : zl,
                        g = xl.context();
                    return l && ru(i, f.props), Kl(p, m), u && ("immediateRender" in i || (i.immediateRender = !0), i.onComplete = function () {
                        Jl(p), c && c.apply(this, arguments)
                    }), s && tu(p, f), i = au(p, f, o || d, l, d, i.duration || a ? i : 0), g && !a && g.add((function () {
                        return function () {
                            return Jl(p)
                        }
                    })), a ? i : i.duration ? xl.to(p.element, i) : null
                }, t.makeAbsolute = function (t, e) {
                    return (t instanceof vu ? t : new vu(t, e)).makeAbsolute()
                }, t.batch = function (t) {
                    return t || (t = "default"), Pl[t] || (Pl[t] = new _u(t))
                }, t.killFlipsOf = function (t, e) {
                    (t instanceof vu ? t.targets : _l(t)).forEach((function (t) {
                        return t && mu(t._flip, !1 !== e ? 1 : 2)
                    }))
                }, t.isFlipping = function (e) {
                    var n = t.getByTarget(e);
                    return !!n && n.isActive()
                }, t.getByTarget = function (t) {
                    return (Ul(t) || kl)._flip
                }, t.getElementState = function (t, e) {
                    return new yu(Ul(t), e)
                }, t.convertCoordinates = function (t, e, n) {
                    var i = bl(e, !0, !0).multiply(bl(t));
                    return n ? i.apply(n) : i
                }, t.register = function (t) {
                    if (Sl = "undefined" != typeof document && document.body) {
                        xl = t, ll(Sl), _l = xl.utils.toArray, El = xl.core.getStyleSaver;
                        var e = xl.utils.snap(.1);
                        Tl = function (t, n) {
                            return e(parseFloat(t) + n)
                        }
                    }
                }, t
            }();
        xu.version = "3.12.5", "undefined" != typeof window && window.gsap && window.gsap.registerPlugin(xu);
        var wu = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
            Mu = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
            Su = Math.PI / 180,
            Tu = (Math.PI, Math.sin),
            Eu = Math.cos,
            Du = Math.abs,
            Cu = Math.sqrt,
            Au = (Math.atan2, function (t) {
                return "number" == typeof t
            }),
            Pu = 1e5,
            Lu = function (t) {
                return Math.round(t * Pu) / Pu || 0
            };

        function Ru(t, e, n, i, r, s, o, a, l) {
            if (t !== a || e !== l) {
                n = Du(n), i = Du(i);
                var u = r % 360 * Su,
                    c = Eu(u),
                    h = Tu(u),
                    d = Math.PI,
                    f = 2 * d,
                    p = (t - a) / 2,
                    m = (e - l) / 2,
                    g = c * p + h * m,
                    v = -h * p + c * m,
                    y = g * g,
                    b = v * v,
                    _ = y / (n * n) + b / (i * i);
                _ > 1 && (n = Cu(_) * n, i = Cu(_) * i);
                var x = n * n,
                    w = i * i,
                    M = (x * w - x * b - w * y) / (x * b + w * y);
                M < 0 && (M = 0);
                var S = (s === o ? -1 : 1) * Cu(M),
                    T = S * (n * v / i),
                    E = S * (-i * g / n),
                    D = (t + a) / 2 + (c * T - h * E),
                    C = (e + l) / 2 + (h * T + c * E),
                    A = (g - T) / n,
                    P = (v - E) / i,
                    L = (-g - T) / n,
                    R = (-v - E) / i,
                    k = A * A + P * P,
                    O = (P < 0 ? -1 : 1) * Math.acos(A / Cu(k)),
                    I = (A * R - P * L < 0 ? -1 : 1) * Math.acos((A * L + P * R) / Cu(k * (L * L + R * R)));
                isNaN(I) && (I = d), !o && I > 0 ? I -= f : o && I < 0 && (I += f), O %= f, I %= f;
                var F, N = Math.ceil(Du(I) / (f / 4)),
                    z = [],
                    U = I / N,
                    B = 4 / 3 * Tu(U / 2) / (1 + Eu(U / 2)),
                    j = c * n,
                    H = h * n,
                    V = h * -i,
                    G = c * i;
                for (F = 0; F < N; F++) g = Eu(r = O + F * U), v = Tu(r), A = Eu(r += U), P = Tu(r), z.push(g - B * v, v + B * g, A + B * P, P - B * A, A, P);
                for (F = 0; F < z.length; F += 2) g = z[F], v = z[F + 1], z[F] = g * j + v * V + D, z[F + 1] = g * H + v * G + C;
                return z[F - 2] = a, z[F - 1] = l, z
            }
        }
        var ku, Ou, Iu = function () {
            return ku || "undefined" != typeof window && (ku = window.gsap) && ku.registerPlugin && ku
        },
            Fu = function () {
                (ku = Iu()) ? (ku.registerEase("_CE", ju.create), Ou = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
            },
            Nu = function (t) {
                return ~~(1e3 * t + (t < 0 ? -.5 : .5)) / 1e3
            },
            zu = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi,
            Uu = /[cLlsSaAhHvVtTqQ]/g,
            Bu = function t(e, n, i, r, s, o, a, l, u, c, h) {
                var d, f = (e + i) / 2,
                    p = (n + r) / 2,
                    m = (i + s) / 2,
                    g = (r + o) / 2,
                    v = (s + a) / 2,
                    y = (o + l) / 2,
                    b = (f + m) / 2,
                    _ = (p + g) / 2,
                    x = (m + v) / 2,
                    w = (g + y) / 2,
                    M = (b + x) / 2,
                    S = (_ + w) / 2,
                    T = a - e,
                    E = l - n,
                    D = Math.abs((i - a) * E - (r - l) * T),
                    C = Math.abs((s - a) * E - (o - l) * T);
                return c || (c = [{
                    x: e,
                    y: n
                }, {
                    x: a,
                    y: l
                }], h = 1), c.splice(h || c.length - 1, 0, {
                    x: M,
                    y: S
                }), (D + C) * (D + C) > u * (T * T + E * E) && (d = c.length, t(e, n, f, p, b, _, M, S, u, c, h), t(M, S, x, w, v, y, a, l, u, c, h + 1 + (c.length - d))), c
            },
            ju = function () {
                function t(t, e, n) {
                    Ou || Fu(), this.id = t, this.setData(e, n)
                }
                var e = t.prototype;
                return e.setData = function (t, e) {
                    e = e || {};
                    var n, i, r, s, o, a, l, u, c, h = (t = t || "0,0,1,1").match(zu),
                        d = 1,
                        f = [],
                        p = [],
                        m = e.precision || 1,
                        g = m <= 1;
                    if (this.data = t, (Uu.test(t) || ~t.indexOf("M") && t.indexOf("C") < 0) && (h = function (t) {
                        var e, n, i, r, s, o, a, l, u, c, h, d, f, p, m, g = (t + "").replace(Mu, (function (t) {
                            var e = +t;
                            return e < 1e-4 && e > -1e-4 ? 0 : e
                        })).match(wu) || [],
                            v = [],
                            y = 0,
                            b = 0,
                            _ = 2 / 3,
                            x = g.length,
                            w = 0,
                            M = "ERROR: malformed path: " + t,
                            S = function (t, e, n, i) {
                                c = (n - t) / 3, h = (i - e) / 3, a.push(t + c, e + h, n - c, i - h, n, i)
                            };
                        if (!t || !isNaN(g[0]) || isNaN(g[1])) return console.log(M), v;
                        for (e = 0; e < x; e++)
                            if (f = s, isNaN(g[e]) ? o = (s = g[e].toUpperCase()) !== g[e] : e--, i = +g[e + 1], r = +g[e + 2], o && (i += y, r += b), e || (l = i, u = r), "M" === s) a && (a.length < 8 ? v.length -= 1 : w += a.length), y = l = i, b = u = r, a = [i, r], v.push(a), e += 2, s = "L";
                            else if ("C" === s) a || (a = [0, 0]), o || (y = b = 0), a.push(i, r, y + 1 * g[e + 3], b + 1 * g[e + 4], y += 1 * g[e + 5], b += 1 * g[e + 6]), e += 6;
                            else if ("S" === s) c = y, h = b, "C" !== f && "S" !== f || (c += y - a[a.length - 4], h += b - a[a.length - 3]), o || (y = b = 0), a.push(c, h, i, r, y += 1 * g[e + 3], b += 1 * g[e + 4]), e += 4;
                            else if ("Q" === s) c = y + (i - y) * _, h = b + (r - b) * _, o || (y = b = 0), y += 1 * g[e + 3], b += 1 * g[e + 4], a.push(c, h, y + (i - y) * _, b + (r - b) * _, y, b), e += 4;
                            else if ("T" === s) c = y - a[a.length - 4], h = b - a[a.length - 3], a.push(y + c, b + h, i + (y + 1.5 * c - i) * _, r + (b + 1.5 * h - r) * _, y = i, b = r), e += 2;
                            else if ("H" === s) S(y, b, y = i, b), e += 1;
                            else if ("V" === s) S(y, b, y, b = i + (o ? b - y : 0)), e += 1;
                            else if ("L" === s || "Z" === s) "Z" === s && (i = l, r = u, a.closed = !0), ("L" === s || Du(y - i) > .5 || Du(b - r) > .5) && (S(y, b, i, r), "L" === s && (e += 2)), y = i, b = r;
                            else if ("A" === s) {
                                if (p = g[e + 4], m = g[e + 5], c = g[e + 6], h = g[e + 7], n = 7, p.length > 1 && (p.length < 3 ? (h = c, c = m, n--) : (h = m, c = p.substr(2), n -= 2), m = p.charAt(1), p = p.charAt(0)), d = Ru(y, b, +g[e + 1], +g[e + 2], +g[e + 3], +p, +m, (o ? y : 0) + 1 * c, (o ? b : 0) + 1 * h), e += n, d)
                                    for (n = 0; n < d.length; n++) a.push(d[n]);
                                y = a[a.length - 2], b = a[a.length - 1]
                            } else console.log(M);
                        return (e = a.length) < 6 ? (v.pop(), e = 0) : a[0] === a[e - 2] && a[1] === a[e - 1] && (a.closed = !0), v.totalPoints = w + e, v
                    }(t)[0]), 4 === (n = h.length)) h.unshift(0, 0), h.push(1, 1), n = 8;
                    else if ((n - 2) % 6) throw "Invalid CustomEase";
                    for (0 == +h[0] && 1 == +h[n - 2] || function (t, e, n) {
                        n || 0 === n || (n = Math.max(+t[t.length - 1], +t[1]));
                        var i, r = -1 * +t[0],
                            s = -n,
                            o = t.length,
                            a = 1 / (+t[o - 2] + r),
                            l = -e || (Math.abs(+t[o - 1] - +t[1]) < .01 * (+t[o - 2] - +t[0]) ? function (t) {
                                var e, n = t.length,
                                    i = 1e20;
                                for (e = 1; e < n; e += 6) + t[e] < i && (i = +t[e]);
                                return i
                            }(t) + s : +t[o - 1] + s);
                        for (l = l ? 1 / l : -a, i = 0; i < o; i += 2) t[i] = (+t[i] + r) * a, t[i + 1] = (+t[i + 1] + s) * l
                    }(h, e.height, e.originY), this.segment = h, s = 2; s < n; s += 6) i = {
                        x: +h[s - 2],
                        y: +h[s - 1]
                    }, r = {
                        x: +h[s + 4],
                        y: +h[s + 5]
                    }, f.push(i, r), Bu(i.x, i.y, +h[s], +h[s + 1], +h[s + 2], +h[s + 3], r.x, r.y, 1 / (2e5 * m), f, f.length - 1);
                    for (n = f.length, s = 0; s < n; s++) l = f[s], u = f[s - 1] || l, (l.x > u.x || u.y !== l.y && u.x === l.x || l === u) && l.x <= 1 ? (u.cx = l.x - u.x, u.cy = l.y - u.y, u.n = l, u.nx = l.x, g && s > 1 && Math.abs(u.cy / u.cx - f[s - 2].cy / f[s - 2].cx) > 2 && (g = 0), u.cx < d && (u.cx ? d = u.cx : (u.cx = .001, s === n - 1 && (u.x -= .001, d = Math.min(d, .001), g = 0)))) : (f.splice(s--, 1), n--);
                    if (o = 1 / (n = 1 / d + 1 | 0), a = 0, l = f[0], g) {
                        for (s = 0; s < n; s++) c = s * o, l.nx < c && (l = f[++a]), i = l.y + (c - l.x) / l.cx * l.cy, p[s] = {
                            x: c,
                            cx: o,
                            y: i,
                            cy: 0,
                            nx: 9
                        }, s && (p[s - 1].cy = i - p[s - 1].y);
                        p[n - 1].cy = f[f.length - 1].y - i
                    } else {
                        for (s = 0; s < n; s++) l.nx < s * o && (l = f[++a]), p[s] = l;
                        a < f.length - 1 && (p[s - 1] = f[f.length - 2])
                    }
                    return this.ease = function (t) {
                        var e = p[t * n | 0] || p[n - 1];
                        return e.nx < t && (e = e.n), e.y + (t - e.x) / e.cx * e.cy
                    }, this.ease.custom = this, this.id && ku && ku.registerEase(this.id, this.ease), this
                }, e.getSVGData = function (e) {
                    return t.getSVGData(this, e)
                }, t.create = function (e, n, i) {
                    return new t(e, n, i).ease
                }, t.register = function (t) {
                    ku = t, Fu()
                }, t.get = function (t) {
                    return ku.parseEase(t)
                }, t.getSVGData = function (e, n) {
                    var i, r, s, o, a, l, u, c, h, d, f = (n = n || {}).width || 100,
                        p = n.height || 100,
                        m = n.x || 0,
                        g = (n.y || 0) + p,
                        v = ku.utils.toArray(n.path)[0];
                    if (n.invert && (p = -p, g = 0), "string" == typeof e && (e = ku.parseEase(e)), e.custom && (e = e.custom), e instanceof t) i = function (t) {
                        Au(t[0]) && (t = [t]);
                        var e, n, i, r, s = "",
                            o = t.length;
                        for (n = 0; n < o; n++) {
                            for (r = t[n], s += "M" + Lu(r[0]) + "," + Lu(r[1]) + " C", e = r.length, i = 2; i < e; i++) s += Lu(r[i++]) + "," + Lu(r[i++]) + " " + Lu(r[i++]) + "," + Lu(r[i++]) + " " + Lu(r[i++]) + "," + Lu(r[i]) + " ";
                            r.closed && (s += "z")
                        }
                        return s
                    }(function (t, e, n, i, r, s, o) {
                        for (var a, l, u, c, h, d = t.length; --d > -1;)
                            for (l = (a = t[d]).length, u = 0; u < l; u += 2) c = a[u], h = a[u + 1], a[u] = c * e + 0 * h + s, a[u + 1] = 0 * c + h * r + o;
                        return t._dirty = 1, t
                    }([e.segment], f, 0, 0, -p, m, g));
                    else {
                        for (i = [m, g], o = 1 / (u = Math.max(5, 200 * (n.precision || 1))), c = 5 / (u += 2), h = Nu(m + o * f), r = ((d = Nu(g + e(o) * -p)) - g) / (h - m), s = 2; s < u; s++) a = Nu(m + s * o * f), l = Nu(g + e(s * o) * -p), (Math.abs((l - d) / (a - h) - r) > c || s === u - 1) && (i.push(h, d), r = (l - d) / (a - h)), h = a, d = l;
                        i = "M" + i.join(",")
                    }
                    return v && v.setAttribute("d", i), i
                }, t
            }();

        function Hu() {
            if (!(this instanceof Hu)) return new Hu;
            this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = []
        }
        Iu() && ku.registerPlugin(ju), ju.version = "3.12.5", Ki.registerPlugin(ia, xu, Aa, Ka, ju), Ki.config({
            defaults: {
                ease: "none"
            }
        }), ju.create("snappy", "M0,0 C0.094,0.026 0.124,0.127 0.157,0.29 0.197,0.486 0.254,0.8 0.348,0.884 0.42,0.949 0.374,1 1,1");
        var Vu = window.document.documentElement,
            Gu = Vu.matches || Vu.webkitMatchesSelector || Vu.mozMatchesSelector || Vu.oMatchesSelector || Vu.msMatchesSelector;
        Hu.prototype.matchesSelector = function (t, e) {
            return Gu.call(t, e)
        }, Hu.prototype.querySelectorAll = function (t, e) {
            return e.querySelectorAll(t)
        }, Hu.prototype.indexes = [];
        var Wu = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        Hu.prototype.indexes.push({
            name: "ID",
            selector: function (t) {
                var e;
                if (e = t.match(Wu)) return e[0].slice(1)
            },
            element: function (t) {
                if (t.id) return [t.id]
            }
        });
        var $u = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        Hu.prototype.indexes.push({
            name: "CLASS",
            selector: function (t) {
                var e;
                if (e = t.match($u)) return e[0].slice(1)
            },
            element: function (t) {
                var e = t.className;
                if (e) {
                    if ("string" == typeof e) return e.split(/\s/);
                    if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/)
                }
            }
        });
        var Xu, qu = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
        Hu.prototype.indexes.push({
            name: "TAG",
            selector: function (t) {
                var e;
                if (e = t.match(qu)) return e[0].toUpperCase()
            },
            element: function (t) {
                return [t.nodeName.toUpperCase()]
            }
        }), Hu.prototype.indexes.default = {
            name: "UNIVERSAL",
            selector: function () {
                return !0
            },
            element: function () {
                return [!0]
            }
        }, Xu = "function" == typeof window.Map ? window.Map : function () {
            function t() {
                this.map = {}
            }
            return t.prototype.get = function (t) {
                return this.map[t + " "]
            }, t.prototype.set = function (t, e) {
                this.map[t + " "] = e
            }, t
        }();
        var Yu = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;

        function Ku(t, e) {
            var n, i, r, s, o, a, l = (t = t.slice(0).concat(t.default)).length,
                u = e,
                c = [];
            do {
                if (Yu.exec(""), (r = Yu.exec(u)) && (u = r[3], r[2] || !u))
                    for (n = 0; n < l; n++)
                        if (o = (a = t[n]).selector(r[1])) {
                            for (i = c.length, s = !1; i--;)
                                if (c[i].index === a && c[i].key === o) {
                                    s = !0;
                                    break
                                } s || c.push({
                                    index: a,
                                    key: o
                                });
                            break
                        }
            } while (r);
            return c
        }

        function Ju(t, e) {
            var n, i, r;
            for (n = 0, i = t.length; n < i; n++)
                if (r = t[n], e.isPrototypeOf(r)) return r
        }

        function Zu(t, e) {
            return t.id - e.id
        }
        Hu.prototype.logDefaultIndexUsed = function () { }, Hu.prototype.add = function (t, e) {
            var n, i, r, s, o, a, l, u, c = this.activeIndexes,
                h = this.selectors,
                d = this.selectorObjects;
            if ("string" == typeof t) {
                for (d[(n = {
                    id: this.uid++,
                    selector: t,
                    data: e
                }).id] = n, l = Ku(this.indexes, t), i = 0; i < l.length; i++) s = (u = l[i]).key, (o = Ju(c, r = u.index)) || ((o = Object.create(r)).map = new Xu, c.push(o)), r === this.indexes.default && this.logDefaultIndexUsed(n), (a = o.map.get(s)) || (a = [], o.map.set(s, a)), a.push(n);
                this.size++, h.push(t)
            }
        }, Hu.prototype.remove = function (t, e) {
            if ("string" == typeof t) {
                var n, i, r, s, o, a, l, u, c = this.activeIndexes,
                    h = this.selectors = [],
                    d = this.selectorObjects,
                    f = {},
                    p = 1 === arguments.length;
                for (n = Ku(this.indexes, t), r = 0; r < n.length; r++)
                    for (i = n[r], s = c.length; s--;)
                        if (a = c[s], i.index.isPrototypeOf(a)) {
                            if (l = a.map.get(i.key))
                                for (o = l.length; o--;)(u = l[o]).selector !== t || !p && u.data !== e || (l.splice(o, 1), f[u.id] = !0);
                            break
                        } for (r in f) delete d[r], this.size--;
                for (r in d) h.push(d[r].selector)
            }
        }, Hu.prototype.queryAll = function (t) {
            if (!this.selectors.length) return [];
            var e, n, i, r, s, o, a, l, u = {},
                c = [],
                h = this.querySelectorAll(this.selectors.join(", "), t);
            for (e = 0, i = h.length; e < i; e++)
                for (s = h[e], n = 0, r = (o = this.matches(s)).length; n < r; n++) u[(l = o[n]).id] ? a = u[l.id] : (a = {
                    id: l.id,
                    selector: l.selector,
                    data: l.data,
                    elements: []
                }, u[l.id] = a, c.push(a)), a.elements.push(s);
            return c.sort(Zu)
        }, Hu.prototype.matches = function (t) {
            if (!t) return [];
            var e, n, i, r, s, o, a, l, u, c, h, d = this.activeIndexes,
                f = {},
                p = [];
            for (e = 0, r = d.length; e < r; e++)
                if (l = (a = d[e]).element(t))
                    for (n = 0, s = l.length; n < s; n++)
                        if (u = a.map.get(l[n]))
                            for (i = 0, o = u.length; i < o; i++) !f[h = (c = u[i]).id] && this.matchesSelector(t, c.selector) && (f[h] = !0, p.push(c));
            return p.sort(Zu)
        };
        const Qu = {},
            tc = {},
            ec = ["mouseenter", "mouseleave", "pointerenter", "pointerleave"];

        function nc(t) {
            void 0 === tc[t] && (tc[t] = [])
        }

        function ic(t) {
            return "string" == typeof t ? document.querySelectorAll(t) : t
        }

        function rc(t) {
            let e = function (t, e) {
                const n = [];
                let i = e;
                do {
                    if (1 !== i.nodeType) break;
                    const e = t.matches(i);
                    e.length && n.push({
                        delegatedTarget: i,
                        stack: e
                    })
                } while (i = i.parentElement);
                return n
            }(Qu[t.type], t.target);
            if (e.length)
                for (let n = 0; n < e.length; n++)
                    for (let i = 0; i < e[n].stack.length; i++) - 1 !== ec.indexOf(t.type) ? (sc(t, e[n].delegatedTarget), t.target === e[n].delegatedTarget && e[n].stack[i].data(t)) : (sc(t, e[n].delegatedTarget), e[n].stack[i].data(t))
        }

        function sc(t, e) {
            Object.defineProperty(t, "currentTarget", {
                configurable: !0,
                enumerable: !0,
                get: () => e
            })
        }

        function oc(t) {
            return JSON.parse(JSON.stringify(t))
        }
        const ac = new class {
            bindAll(t, e) {
                e || (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t)));
                for (let n = 0; n < e.length; n++) t[e[n]] = t[e[n]].bind(t)
            }
            on(t, e, n, i) {
                const r = t.split(" ");
                for (let t = 0; t < r.length; t++)
                    if ("function" != typeof e || void 0 !== n)
                        if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(r[t], n, i);
                        else {
                            e = ic(e);
                            for (let s = 0; s < e.length; s++) e[s].addEventListener(r[t], n, i)
                        }
                    else nc(r[t]), tc[r[t]].push(e)
            }
            delegate(t, e, n) {
                const i = t.split(" ");
                for (let t = 0; t < i.length; t++) {
                    let r = Qu[i[t]];
                    void 0 === r && (r = new Hu, Qu[i[t]] = r, -1 !== ec.indexOf(i[t]) ? document.addEventListener(i[t], rc, !0) : document.addEventListener(i[t], rc)), r.add(e, n)
                }
            }
            off(t, e, n, i) {
                const r = t.split(" ");
                for (let t = 0; t < r.length; t++) {
                    if (void 0 === e) {
                        tc[r[t]] = [];
                        continue
                    }
                    if ("function" == typeof e) {
                        nc(r[t]);
                        for (let n = 0; n < tc[r[t]].length; n++) tc[r[t]][n] === e && tc[r[t]].splice(n, 1);
                        continue
                    }
                    const s = Qu[r[t]];
                    if (void 0 === s || (s.remove(e, n), 0 !== s.size))
                        if (void 0 === e.removeEventListener) {
                            e = ic(e);
                            for (let s = 0; s < e.length; s++) e[s].removeEventListener(r[t], n, i)
                        } else e.removeEventListener(r[t], n, i);
                    else delete Qu[r[t]], -1 !== ec.indexOf(r[t]) ? document.removeEventListener(r[t], rc, !0) : document.removeEventListener(r[t], rc)
                }
            }
            emit(t, ...e) {
                ! function (t, e) {
                    if (tc[t])
                        for (let n = 0; n < tc[t].length; n++) tc[t][n](...e)
                }(t, e)
            }
            debugDelegated() {
                return oc(Qu)
            }
            debugBus() {
                return oc(tc)
            }
        },
            lc = ac;

        function uc(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
            return i
        }
        var cc = function (t) {
            return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document).querySelector(t)
        },
            hc = function (t) {
                return function (t) {
                    return function (t) {
                        if (Array.isArray(t)) return uc(t)
                    }(t) || function (t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || function (t, e) {
                        if (t) {
                            if ("string" == typeof t) return uc(t, e);
                            var n = {}.toString.call(t).slice(8, -1);
                            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? uc(t, e) : void 0
                        }
                    }(t) || function () {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }((arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document).querySelectorAll(t))
            },
            dc = function (t) {
                return t.getBoundingClientRect()
            },
            fc = function (t, e) {
                return arguments.length > 2 && void 0 !== arguments[2] && arguments[2] ? Math.random() * (e - t + 1) + t : Math.floor(Math.random() * (e - t + 1) + t)
            },
            pc = function (t) {
                return t.offsetWidth > 0 && t.offsetHeight > 0
            },
            mc = {
                body: document.body,
                sc: cc(".js-sc"),
                sp: cc(".js-sp"),
                sh: cc(".js-sh"),
                sf: cc(".js-sf"),
                mask: cc(".js-mask"),
                maskSpin: cc(".js-mask-spin"),
                switch: cc(".js-works-switch"),
                maskLines: cc(".js-mask-lines"),
                maskLine: hc(".js-mask-line")
            },
            gc = {
                ww: window.innerWidth,
                wh: window.innerHeight,
                maxScroll: 0
            },
            vc = {
                isFirefox: navigator.userAgent.indexOf("Firefox") > -1,
                isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1,
                isSmall: window.matchMedia("(max-width: 649px)").matches,
                isPortrait: window.matchMedia("(orientation: portrait)").matches
            };
        const yc = {
            dom: mc,
            bounds: gc,
            flags: {
                locked: !1,
                infiniteScroll: !1,
                scrolling: !1,
                resizing: !1,
                menu: !1
            },
            fromPage: {
                routes: [],
                total: 0
            },
            device: vc,
            features: {
                hasWheelEvent: "onwheel" in document,
                hasMouseWheelEvent: "onmousewheel" in document,
                hasTouch: "ontouchstart" in document,
                hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                hasPointer: !!window.navigator.msPointerEnabled,
                hasKeyDown: "onkeydown" in document,
                hasSmoothScroll: !vc.isMobile
            }
        };

        function bc(t, e, n) {
            return (e = Sc(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function _c(t) {
            return _c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, _c(t)
        }

        function xc(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function wc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Sc(i.key), i)
            }
        }

        function Mc(t, e, n) {
            return e && wc(t.prototype, e), n && wc(t, n), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function Sc(t) {
            var e = function (t, e) {
                if ("object" != _c(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != _c(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == _c(e) ? e : e + ""
        }

        function Tc(t, e, n) {
            return Math.max(t, Math.min(e, n))
        }
        var Ec = function () {
            return Mc((function t() {
                xc(this, t)
            }), [{
                key: "advance",
                value: function (t) {
                    var e;
                    if (this.isRunning) {
                        var n = !1;
                        if (this.duration && this.easing) {
                            this.currentTime += t;
                            var i = Tc(0, this.currentTime / this.duration, 1),
                                r = (n = i >= 1) ? 1 : this.easing(i);
                            this.value = this.from + (this.to - this.from) * r
                        } else this.lerp ? (this.value = function (t, e, n, i) {
                            return function (t, e, n) {
                                return (1 - n) * t + n * e
                            }(t, e, 1 - Math.exp(-n * i))
                        }(this.value, this.to, 60 * this.lerp, t), Math.round(this.value) === this.to && (this.value = this.to, n = !0)) : (this.value = this.to, n = !0);
                        n && this.stop(), null === (e = this.onUpdate) || void 0 === e || e.call(this, this.value, n)
                    }
                }
            }, {
                key: "stop",
                value: function () {
                    this.isRunning = !1
                }
            }, {
                key: "fromTo",
                value: function (t, e, n) {
                    var i = n.lerp,
                        r = n.duration,
                        s = n.easing,
                        o = n.onStart,
                        a = n.onUpdate;
                    this.from = this.value = t, this.to = e, this.lerp = i, this.duration = r, this.easing = s, this.currentTime = 0, this.isRunning = !0, null != o && o(), this.onUpdate = a
                }
            }])
        }(),
            Dc = function () {
                return Mc((function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        i = n.wrapper,
                        r = n.content,
                        s = n.autoResize,
                        o = void 0 === s || s,
                        a = n.debounce,
                        l = void 0 === a ? 250 : a;
                    xc(this, t), bc(this, "resize", (function () {
                        e.onWrapperResize(), e.onContentResize()
                    })), bc(this, "onWrapperResize", (function () {
                        e.wrapper === window ? (e.width = window.innerWidth, e.height = window.innerHeight) : (e.width = e.wrapper.clientWidth, e.height = e.wrapper.clientHeight)
                    })), bc(this, "onContentResize", (function () {
                        e.wrapper === window ? (e.scrollHeight = e.content.scrollHeight, e.scrollWidth = e.content.scrollWidth) : (e.scrollHeight = e.wrapper.scrollHeight, e.scrollWidth = e.wrapper.scrollWidth)
                    })), this.wrapper = i, this.content = r, o && (this.debouncedResize = function (t, e) {
                        var n;
                        return function () {
                            var i = arguments,
                                r = this;
                            clearTimeout(n), n = setTimeout((function () {
                                t.apply(r, i)
                            }), e)
                        }
                    }(this.resize, l), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
                }), [{
                    key: "destroy",
                    value: function () {
                        var t, e;
                        null !== (t = this.wrapperResizeObserver) && void 0 !== t && t.disconnect(), null !== (e = this.contentResizeObserver) && void 0 !== e && e.disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
                    }
                }, {
                    key: "limit",
                    get: function () {
                        return {
                            x: this.scrollWidth - this.width,
                            y: this.scrollHeight - this.height
                        }
                    }
                }])
            }(),
            Cc = function () {
                return Mc((function t() {
                    xc(this, t), this.events = {}
                }), [{
                    key: "emit",
                    value: function (t) {
                        for (var e = this.events[t] || [], n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                        for (var s = 0, o = e.length; s < o; s++) e[s].apply(e, i)
                    }
                }, {
                    key: "on",
                    value: function (t, e) {
                        var n, i = this;
                        return null !== (n = this.events[t]) && void 0 !== n && n.push(e) || (this.events[t] = [e]),
                            function () {
                                var n;
                                i.events[t] = null === (n = i.events[t]) || void 0 === n ? void 0 : n.filter((function (t) {
                                    return e !== t
                                }))
                            }
                    }
                }, {
                    key: "off",
                    value: function (t, e) {
                        var n;
                        this.events[t] = null === (n = this.events[t]) || void 0 === n ? void 0 : n.filter((function (t) {
                            return e !== t
                        }))
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        this.events = {}
                    }
                }])
            }(),
            Ac = 100 / 6,
            Pc = function () {
                return Mc((function t(e, n) {
                    var i = this,
                        r = n.wheelMultiplier,
                        s = void 0 === r ? 1 : r,
                        o = n.touchMultiplier,
                        a = void 0 === o ? 1 : o;
                    xc(this, t), bc(this, "onTouchStart", (function (t) {
                        var e = t.targetTouches ? t.targetTouches[0] : t,
                            n = e.clientX,
                            r = e.clientY;
                        i.touchStart.x = n, i.touchStart.y = r, i.lastDelta = {
                            x: 0,
                            y: 0
                        }, i.emitter.emit("scroll", {
                            deltaX: 0,
                            deltaY: 0,
                            event: t
                        })
                    })), bc(this, "onTouchMove", (function (t) {
                        var e = t.targetTouches ? t.targetTouches[0] : t,
                            n = e.clientX,
                            r = e.clientY,
                            s = -(n - i.touchStart.x) * i.touchMultiplier,
                            o = -(r - i.touchStart.y) * i.touchMultiplier;
                        i.touchStart.x = n, i.touchStart.y = r, i.lastDelta = {
                            x: s,
                            y: o
                        }, i.emitter.emit("scroll", {
                            deltaX: s,
                            deltaY: o,
                            event: t
                        })
                    })), bc(this, "onTouchEnd", (function (t) {
                        i.emitter.emit("scroll", {
                            deltaX: i.lastDelta.x,
                            deltaY: i.lastDelta.y,
                            event: t
                        })
                    })), bc(this, "onWheel", (function (t) {
                        var e = t.deltaX,
                            n = t.deltaY,
                            r = t.deltaMode;
                        e *= 1 === r ? Ac : 2 === r ? i.windowWidth : 1, n *= 1 === r ? Ac : 2 === r ? i.windowHeight : 1, e *= i.wheelMultiplier, n *= i.wheelMultiplier, i.emitter.emit("scroll", {
                            deltaX: e,
                            deltaY: n,
                            event: t
                        })
                    })), bc(this, "onWindowResize", (function () {
                        i.windowWidth = window.innerWidth, i.windowHeight = window.innerHeight
                    })), this.element = e, this.wheelMultiplier = s, this.touchMultiplier = a, this.touchStart = {
                        x: null,
                        y: null
                    }, this.emitter = new Cc, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, {
                        passive: !1
                    }), this.element.addEventListener("touchstart", this.onTouchStart, {
                        passive: !1
                    }), this.element.addEventListener("touchmove", this.onTouchMove, {
                        passive: !1
                    }), this.element.addEventListener("touchend", this.onTouchEnd, {
                        passive: !1
                    })
                }), [{
                    key: "on",
                    value: function (t, e) {
                        return this.emitter.on(t, e)
                    }
                }, {
                    key: "destroy",
                    value: function () {
                        this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, {
                            passive: !1
                        }), this.element.removeEventListener("touchstart", this.onTouchStart, {
                            passive: !1
                        }), this.element.removeEventListener("touchmove", this.onTouchMove, {
                            passive: !1
                        }), this.element.removeEventListener("touchend", this.onTouchEnd, {
                            passive: !1
                        })
                    }
                }])
            }(),
            Lc = function () {
                return Mc((function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        i = n.wrapper,
                        r = void 0 === i ? window : i,
                        s = n.content,
                        o = void 0 === s ? document.documentElement : s,
                        a = n.wheelEventsTarget,
                        l = void 0 === a ? r : a,
                        u = n.eventsTarget,
                        c = void 0 === u ? l : u,
                        h = n.smoothWheel,
                        d = void 0 === h || h,
                        f = n.syncTouch,
                        p = void 0 !== f && f,
                        m = n.syncTouchLerp,
                        g = void 0 === m ? .075 : m,
                        v = n.touchInertiaMultiplier,
                        y = void 0 === v ? 35 : v,
                        b = n.duration,
                        _ = n.easing,
                        x = void 0 === _ ? function (t) {
                            return Math.min(1, 1.001 - Math.pow(2, -10 * t))
                        } : _,
                        w = n.lerp,
                        M = void 0 === w ? .1 : w,
                        S = n.infinite,
                        T = void 0 !== S && S,
                        E = n.orientation,
                        D = void 0 === E ? "vertical" : E,
                        C = n.gestureOrientation,
                        A = void 0 === C ? "vertical" : C,
                        P = n.touchMultiplier,
                        L = void 0 === P ? 1 : P,
                        R = n.wheelMultiplier,
                        k = void 0 === R ? 1 : R,
                        O = n.autoResize,
                        I = void 0 === O || O,
                        F = n.prevent,
                        N = void 0 !== F && F,
                        z = n.__experimental__naiveDimensions,
                        U = void 0 !== z && z;
                    xc(this, t), this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.direction = 0, this.onVirtualScroll = function (t) {
                        var n = t.deltaX,
                            i = t.deltaY,
                            r = t.event;
                        if (!r.ctrlKey) {
                            var s = r.type.includes("touch"),
                                o = r.type.includes("wheel");
                            if (e.isTouching = "touchstart" === r.type || "touchmove" === r.type, !e.options.syncTouch || !s || "touchstart" !== r.type || e.isStopped || e.isLocked) {
                                var a = 0 === n && 0 === i,
                                    l = "vertical" === e.options.gestureOrientation && 0 === i || "horizontal" === e.options.gestureOrientation && 0 === n;
                                if (!a && !l) {
                                    var u = r.composedPath();
                                    u = u.slice(0, u.indexOf(e.rootElement));
                                    var c = e.options.prevent;
                                    if (!u.find((function (t) {
                                        var e, n, i, r, a;
                                        return t instanceof Element && (("function" == typeof c ? null == c ? void 0 : c(t) : c) || (null === (e = t.hasAttribute) || void 0 === e ? void 0 : e.call(t, "data-lenis-prevent")) || s && (null === (n = t.hasAttribute) || void 0 === n ? void 0 : n.call(t, "data-lenis-prevent-touch")) || o && (null === (i = t.hasAttribute) || void 0 === i ? void 0 : i.call(t, "data-lenis-prevent-wheel")) || (null === (r = t.classList) || void 0 === r ? void 0 : r.contains("lenis")) && !(null === (a = t.classList) || void 0 === a ? void 0 : a.contains("lenis-stopped")))
                                    })))
                                        if (e.isStopped || e.isLocked) r.preventDefault();
                                        else {
                                            if (!(e.options.syncTouch && s || e.options.smoothWheel && o)) return e.isScrolling = "native", void e.animate.stop();
                                            r.preventDefault();
                                            var h = i;
                                            "both" === e.options.gestureOrientation ? h = Math.abs(i) > Math.abs(n) ? i : n : "horizontal" === e.options.gestureOrientation && (h = n);
                                            var d = s && e.options.syncTouch,
                                                f = s && "touchend" === r.type && Math.abs(h) > 5;
                                            f && (h = e.velocity * e.options.touchInertiaMultiplier), e.scrollTo(e.targetScroll + h, Object.assign({
                                                programmatic: !1
                                            }, d ? {
                                                lerp: f ? e.options.syncTouchLerp : 1
                                            } : {
                                                lerp: e.options.lerp,
                                                duration: e.options.duration,
                                                easing: e.options.easing
                                            }))
                                        }
                                }
                            } else e.reset()
                        }
                    }, this.onNativeScroll = function () {
                        if (clearTimeout(e.__resetVelocityTimeout), delete e.__resetVelocityTimeout, e.__preventNextNativeScrollEvent) delete e.__preventNextNativeScrollEvent;
                        else if (!1 === e.isScrolling || "native" === e.isScrolling) {
                            var t = e.animatedScroll;
                            e.animatedScroll = e.targetScroll = e.actualScroll, e.lastVelocity = e.velocity, e.velocity = e.animatedScroll - t, e.direction = Math.sign(e.animatedScroll - t), e.isScrolling = "native", e.emit(), 0 !== e.velocity && (e.__resetVelocityTimeout = setTimeout((function () {
                                e.lastVelocity = e.velocity, e.velocity = 0, e.isScrolling = !1, e.emit()
                            }), 400))
                        }
                    }, window.lenisVersion = "1.1.3", r && r !== document.documentElement && r !== document.body || (r = window), this.options = {
                        wrapper: r,
                        content: o,
                        wheelEventsTarget: l,
                        eventsTarget: c,
                        smoothWheel: d,
                        syncTouch: p,
                        syncTouchLerp: g,
                        touchInertiaMultiplier: y,
                        duration: b,
                        easing: x,
                        lerp: M,
                        infinite: T,
                        gestureOrientation: A,
                        orientation: D,
                        touchMultiplier: L,
                        wheelMultiplier: k,
                        autoResize: I,
                        prevent: N,
                        __experimental__naiveDimensions: U
                    }, this.animate = new Ec, this.emitter = new Cc, this.dimensions = new Dc({
                        wrapper: r,
                        content: o,
                        autoResize: I
                    }), this.updateClassName(), this.userData = {}, this.time = 0, this.velocity = this.lastVelocity = 0, this.isLocked = !1, this.isStopped = !1, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new Pc(c, {
                        touchMultiplier: L,
                        wheelMultiplier: k
                    }), this.virtualScroll.on("scroll", this.onVirtualScroll)
                }), [{
                    key: "destroy",
                    value: function () {
                        this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName()
                    }
                }, {
                    key: "on",
                    value: function (t, e) {
                        return this.emitter.on(t, e)
                    }
                }, {
                    key: "off",
                    value: function (t, e) {
                        return this.emitter.off(t, e)
                    }
                }, {
                    key: "setScroll",
                    value: function (t) {
                        this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
                    }
                }, {
                    key: "resize",
                    value: function () {
                        this.dimensions.resize()
                    }
                }, {
                    key: "emit",
                    value: function () {
                        this.emitter.emit("scroll", this)
                    }
                }, {
                    key: "reset",
                    value: function () {
                        this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop()
                    }
                }, {
                    key: "start",
                    value: function () {
                        this.isStopped && (this.isStopped = !1, this.reset())
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
                    }
                }, {
                    key: "raf",
                    value: function (t) {
                        var e = t - (this.time || t);
                        this.time = t, this.animate.advance(.001 * e)
                    }
                }, {
                    key: "scrollTo",
                    value: function (t) {
                        var e = this,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            i = n.offset,
                            r = void 0 === i ? 0 : i,
                            s = n.immediate,
                            o = void 0 !== s && s,
                            a = n.lock,
                            l = void 0 !== a && a,
                            u = n.duration,
                            c = void 0 === u ? this.options.duration : u,
                            h = n.easing,
                            d = void 0 === h ? this.options.easing : h,
                            f = n.lerp,
                            p = void 0 === f ? this.options.lerp : f,
                            m = n.onStart,
                            g = n.onComplete,
                            v = n.force,
                            y = void 0 !== v && v,
                            b = n.programmatic,
                            _ = void 0 === b || b,
                            x = n.userData,
                            w = void 0 === x ? {} : x;
                        if (!this.isStopped && !this.isLocked || y) {
                            if ("string" == typeof t && ["top", "left", "start"].includes(t)) t = 0;
                            else if ("string" == typeof t && ["bottom", "right", "end"].includes(t)) t = this.limit;
                            else {
                                var M;
                                if ("string" == typeof t ? M = document.querySelector(t) : t instanceof HTMLElement && (null == t ? void 0 : t.nodeType) && (M = t), M) {
                                    if (this.options.wrapper !== window) {
                                        var S = this.rootElement.getBoundingClientRect();
                                        r -= this.isHorizontal ? S.left : S.top
                                    }
                                    var T = M.getBoundingClientRect();
                                    t = (this.isHorizontal ? T.left : T.top) + this.animatedScroll
                                }
                            }
                            if ("number" == typeof t && (t += r, t = Math.round(t), this.options.infinite ? _ && (this.targetScroll = this.animatedScroll = this.scroll) : t = Tc(0, t, this.limit), t !== this.targetScroll)) {
                                if (this.userData = w, o) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), null == g || g(this), void (this.userData = {});
                                _ || (this.targetScroll = t), this.animate.fromTo(this.animatedScroll, t, {
                                    duration: c,
                                    easing: d,
                                    lerp: p,
                                    onStart: function () {
                                        l && (e.isLocked = !0), e.isScrolling = "smooth", null == m || m(e)
                                    },
                                    onUpdate: function (t, n) {
                                        e.isScrolling = "smooth", e.lastVelocity = e.velocity, e.velocity = t - e.animatedScroll, e.direction = Math.sign(e.velocity), e.animatedScroll = t, e.setScroll(e.scroll), _ && (e.targetScroll = t), n || e.emit(), n && (e.reset(), e.emit(), null == g || g(e), e.userData = {}, e.preventNextNativeScrollEvent())
                                    }
                                })
                            }
                        }
                    }
                }, {
                    key: "preventNextNativeScrollEvent",
                    value: function () {
                        var t = this;
                        this.__preventNextNativeScrollEvent = !0, requestAnimationFrame((function () {
                            delete t.__preventNextNativeScrollEvent
                        }))
                    }
                }, {
                    key: "rootElement",
                    get: function () {
                        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
                    }
                }, {
                    key: "limit",
                    get: function () {
                        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
                    }
                }, {
                    key: "isHorizontal",
                    get: function () {
                        return "horizontal" === this.options.orientation
                    }
                }, {
                    key: "actualScroll",
                    get: function () {
                        return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
                    }
                }, {
                    key: "scroll",
                    get: function () {
                        return this.options.infinite ? function (t, e) {
                            return (t % e + e) % e
                        }(this.animatedScroll, this.limit) : this.animatedScroll
                    }
                }, {
                    key: "progress",
                    get: function () {
                        return 0 === this.limit ? 1 : this.scroll / this.limit
                    }
                }, {
                    key: "isScrolling",
                    get: function () {
                        return this.__isScrolling
                    },
                    set: function (t) {
                        this.__isScrolling !== t && (this.__isScrolling = t, this.updateClassName())
                    }
                }, {
                    key: "isStopped",
                    get: function () {
                        return this.__isStopped
                    },
                    set: function (t) {
                        this.__isStopped !== t && (this.__isStopped = t, this.updateClassName())
                    }
                }, {
                    key: "isLocked",
                    get: function () {
                        return this.__isLocked
                    },
                    set: function (t) {
                        this.__isLocked !== t && (this.__isLocked = t, this.updateClassName())
                    }
                }, {
                    key: "isSmooth",
                    get: function () {
                        return "smooth" === this.isScrolling
                    }
                }, {
                    key: "className",
                    get: function () {
                        var t = "lenis";
                        return this.isStopped && (t += " lenis-stopped"), this.isLocked && (t += " lenis-locked"), this.isScrolling && (t += " lenis-scrolling"), "smooth" === this.isScrolling && (t += " lenis-smooth"), t
                    }
                }, {
                    key: "updateClassName",
                    value: function () {
                        this.cleanUpClassName(), this.rootElement.className = "".concat(this.rootElement.className, " ").concat(this.className).trim()
                    }
                }, {
                    key: "cleanUpClassName",
                    value: function () {
                        this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
                    }
                }])
            }(),
            Rc = n(884),
            kc = n.n(Rc),
            Oc = yc.device,
            Ic = (yc.dom, yc.bounds),
            Fc = yc.flags,
            Nc = Oc.isWindows,
            zc = Oc.isFirefox,
            Uc = cc;
        Ki.registerPlugin(ia, Aa, Ka);
        var Bc = yc.device.isMobile,
            jc = yc.bounds,
            Hc = yc.device,
            Vc = yc.dom,
            Gc = Hc.isMobile;

        function Wc(t) {
            return Wc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Wc(t)
        }

        function $c(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function Xc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, qc(i.key), i)
            }
        }

        function qc(t) {
            var e = function (t, e) {
                if ("object" != Wc(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Wc(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Wc(e) ? e : e + ""
        }
        var Yc = function () {
            return function (t, e, n) {
                return n && Xc(t, n), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t
            }((function t() {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t)
            }), 0, [{
                key: "init",
                value: function () {
                    this.urlParams = new URLSearchParams(location.search), "1" == this.urlParams.get("remove_sw") ? this.removeSw() : this.registerSw()
                }
            }, {
                key: "registerSw",
                value: function () {
                    Motto.swEnable && "serviceWorker" in navigator && navigator.serviceWorker.register("/service-worker.js", {
                        scope: "/"
                    })
                }
            }, {
                key: "removeSw",
                value: function () {
                    navigator.serviceWorker.getRegistrations().then((function (t) {
                        var e, n = function (t, e) {
                            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                            if (!n) {
                                if (Array.isArray(t) || (n = function (t, e) {
                                    if (t) {
                                        if ("string" == typeof t) return $c(t, e);
                                        var n = {}.toString.call(t).slice(8, -1);
                                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? $c(t, e) : void 0
                                    }
                                }(t)) || e && t && "number" == typeof t.length) {
                                    n && (t = n);
                                    var i = 0,
                                        r = function () { };
                                    return {
                                        s: r,
                                        n: function () {
                                            return i >= t.length ? {
                                                done: !0
                                            } : {
                                                done: !1,
                                                value: t[i++]
                                            }
                                        },
                                        e: function (t) {
                                            throw t
                                        },
                                        f: r
                                    }
                                }
                                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                            }
                            var s, o = !0,
                                a = !1;
                            return {
                                s: function () {
                                    n = n.call(t)
                                },
                                n: function () {
                                    var t = n.next();
                                    return o = t.done, t
                                },
                                e: function (t) {
                                    a = !0, s = t
                                },
                                f: function () {
                                    try {
                                        o || null == n.return || n.return()
                                    } finally {
                                        if (a) throw s
                                    }
                                }
                            }
                        }(t);
                        try {
                            for (n.s(); !(e = n.n()).done;) e.value.unregister()
                        } catch (t) {
                            n.e(t)
                        } finally {
                            n.f()
                        }
                        location.href = "/"
                    }))
                }
            }])
        }();
        const Kc = Yc;
        var Jc = n(919),
            Zc = n.n(Jc),
            Qc = cc,
            th = hc,
            eh = yc.dom,
            nh = yc.flags;

        function ih() {
            var t, e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : eh.body;
            (e = Qc(".js-p-hero", n)) && Ki.fromTo(e, {
                yPercent: 0
            }, {
                yPercent: 25,
                ease: "none",
                scrollTrigger: {
                    trigger: e,
                    start: "top top",
                    scrub: !0
                }
            }), (t = th(".js-toggle-active", n)).length && t.forEach((function (t) {
                ia.create({
                    trigger: t,
                    onToggle: function (e) {
                        e.isActive ? t.classList.add("is-active") : t.classList.remove("is-active")
                    }
                })
            })), (t = th(".js-p-parallax", n)).length && t.forEach((function (t) {
                var e = t.dataset.parallax ? JSON.parse(t.dataset.parallax) : ["-10rem", "10rem"];
                Ki.fromTo(t, {
                    y: e[0]
                }, {
                    y: e[1],
                    ease: "none",
                    scrollTrigger: {
                        trigger: t.parentNode,
                        scrub: !0
                    }
                })
            })), (e = Qc(".js-p-foot")) && Ki.fromTo(e, {
                yPercent: -50
            }, {
                yPercent: 0,
                ease: "none",
                force3D: !0,
                scrollTrigger: {
                    trigger: e.parentNode,
                    start: "top bottom",
                    end: "bottom bottom",
                    scrub: !0
                }
            }), (e = Qc(".js-no-mix-blend", n)) && ia.create({
                trigger: e,
                start: "top top",
                end: "bottom top",
                onEnterBack: function () {
                    eh.sh.classList.add("no-mix-blend")
                },
                onLeave: function () {
                    eh.sh.classList.remove("no-mix-blend")
                }
            }), (t = th(".js-p-rotate", n)).length && t.forEach((function (t) {
                Ki.fromTo(t, {
                    rotaton: 0
                }, {
                    rotation: -270,
                    ease: "none",
                    scrollTrigger: {
                        trigger: t,
                        scrub: !0
                    }
                })
            })), (e = Qc(".js-p-founders", n)) && Ki.fromTo(e, {
                yPercent: 0
            }, {
                yPercent: 50,
                ease: "none",
                scrollTrigger: {
                    trigger: eh.body,
                    endTrigger: e,
                    start: "top top",
                    scrub: !0
                }
            }), (e = Qc(".js-s-hide-sh", n) || Qc(".js-s-hide-sh")) && !nh.headDisabled && ia.create({
                trigger: e,
                start: "top center",
                onToggle: function (t) {
                    t.isActive ? eh.sh.classList.add("is-hidden") : eh.sh.classList.remove("is-hidden")
                }
            }), (t = th("[data-split]", n)).length && t.forEach((function (t) {
                var e = new (Zc())(t, {
                    type: "lines"
                }),
                    n = new (Zc())(e.lines, {
                        type: "lines"
                    });
                Ki.set(e.lines, {
                    overflow: "hidden"
                }), Ki.fromTo(n.lines, {
                    yPercent: 101
                }, {
                    yPercent: 0,
                    duration: 1.25,
                    stagger: .2,
                    ease: "expo",
                    scrollTrigger: {
                        trigger: t
                    }
                }, 1)
            }))
        }
        var rh = cc;

        function sh(t) {
            var e = rh(".js-dd-content", t),
                n = t.dataset.first;
            n && Ki.set(e, {
                height: 0
            });
            var i = Ki.timeline({
                paused: !0,
                defaults: {
                    duration: .5,
                    ease: "expo.inOut"
                }
            }).fromTo(e, {
                height: 0
            }, {
                height: "auto"
            }),
                r = n;

            function s() {
                r ? (r = !1, t.classList.remove("is-active"), i.reverse()) : (r = !0, t.classList.add("is-active"), i.play())
            }
            return n && i.progress(1), lc.on("click", t, s), {
                unmount: function () {
                    lc.off("click", t, s), i && i.kill()
                }
            }
        }
        var oh = cc,
            ah = hc,
            lh = dc,
            uh = yc.bounds;

        function ch(t) {
            var e = void 0 !== t.dataset.reverse,
                n = void 0 !== t.dataset.extendedSt,
                i = void 0 !== t.dataset.zoomable,
                r = oh(".js-marquee-child", t),
                s = ah(".js-spin", t),
                o = oh(".js-marquee-text", t),
                a = 0,
                l = 0,
                u = !1,
                c = 0,
                h = null,
                d = null,
                f = Ki.quickSetter(t, "x", "px");

            function p() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                u && (c = t.diff ? Math.abs(t.diff) * (e ? -.65 : .65) : 0, a = Ki.utils.wrap(0, -l, a + (e ? -2 : 2) + c), f(a), d.forEach((function (t) {
                    var e, n, i;
                    n = (e = t).start, i = e.end, -a > n && -a < i ? (t.out && (t.out = !1), t.rotate(.5 * a)) : t.out || (t.out = !0, t.rotate(.5 * a))
                })))
            }

            function m() {
                if (l = lh(r).width, h = [], d = s.map((function (t) {
                    var e = Ki.quickSetter(t, "rotation", "deg"),
                        n = lh(t),
                        i = n.left,
                        r = n.right,
                        s = i - uh.ww,
                        o = r;
                    return h.push(s), {
                        start: s,
                        end: o,
                        rotate: e,
                        out: !0
                    }
                })), i) {
                    var e = lh(oh(".js-marquee-scale-ref", t.parentNode));
                    e.width, lh(o).width, e.left
                }
            }
            return ia.create({
                trigger: t,
                start: "top bottom",
                end: function () {
                    return n ? "+=".concat(2 * uh.wh) : "bottom top"
                },
                onToggle: function (t) {
                    return u = t.isActive
                }
            }), m(), lc.on("tick", p), lc.on("resize", m), {
                unmount: function () {
                    lc.off("tick", p), lc.off("resize", m)
                }
            }
        }
        var hh = cc,
            dh = dc;

        function fh(t) {
            var e = 0,
                n = 0,
                i = 0,
                r = 0,
                s = null,
                o = null,
                a = !1,
                l = t.parentNode,
                u = hh(".js-mouse-follow-inner", t);

            function c(s) {
                var o = s.y;
                a && (i = kc()(i, e, .15), r = kc()(r, n + o, .15), t.style.transform = "translate3d(".concat(i, "px, ").concat(r, "px, 0)"))
            }

            function h(t) {
                var i = t.x,
                    r = t.y;
                if (a) {
                    var l = s,
                        u = l.left,
                        c = l.top;
                    e = i - (u + o.width - o.width / 2), n = r - (c + o.height - o.height / 2)
                }
            }

            function d() {
                Ki.to(u, {
                    alpha: 1,
                    scale: 1,
                    duration: .5,
                    ease: "expo"
                })
            }

            function f() {
                Ki.to(u, {
                    alpha: 0,
                    scale: 0,
                    duration: .5,
                    ease: "expo"
                })
            }

            function p() {
                s = dh(l), o = dh(t)
            }
            return ia.create({
                trigger: l,
                onToggle: function (t) {
                    return a = t.isActive
                }
            }), requestAnimationFrame((function () {
                p(), lc.on("tick", c), lc.on("mousemove", h), lc.on("resize-reset", p), lc.on("mouseenter", l, d), lc.on("mouseleave", l, f), Ki.set(u, {
                    scale: 0,
                    alpha: 0
                })
            })), {
                pos: function () {
                    return {
                        tx: e,
                        ty: n
                    }
                },
                unmount: function () {
                    lc.off("tick", c), lc.off("mousemove", h), lc.off("resize-reset", p), lc.off("mouseenter", l, d), lc.off("mouseleave", l, f)
                }
            }
        }

        function ph(t) {
            return ph = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ph(t)
        }

        function mh(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, vh(i.key), i)
            }
        }

        function gh(t, e, n) {
            return (e = vh(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function vh(t) {
            var e = function (t, e) {
                if ("object" != ph(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != ph(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == ph(e) ? e : e + ""
        }
        var yh = cc,
            bh = hc,
            _h = dc,
            xh = pc,
            wh = yc.bounds,
            Mh = (yc.flags, function () {
                return function (t, e, n) {
                    return e && mh(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), gh(this, "down", (function (t) {
                        var e = t.x,
                            i = t.y,
                            r = t.target;
                        (r === n.el || n.el.contains(r)) && (n.isDragging = !0, n.cancelX = e, n.cancelY = i, n.on = n.tx + e * n.speed, n.clamp())
                    })), gh(this, "move", (function (t) {
                        var e = t.x,
                            i = t.y,
                            r = t.e;
                        n.$cursor && (e <= wh.ww / 2 && n.isNext ? (n.isNext = !1, n.$cursor.textContent = "") : e > wh.ww / 2 && !n.isNext && (n.isNext = !0, n.$cursor.textContent = "")), n.isDragging && (Math.abs(e - n.cancelX) > Math.abs(i - n.cancelY) && r.cancelable && (r.preventDefault(), r.stopPropagation()), n.tx = n.on - e * n.speed, n.clamp())
                    })), gh(this, "up", (function (t) {
                        var e = t.click,
                            i = t.target;
                        n.isDragging && (n.isDragging = !1, "BUTTON" !== i.nodeName && (e ? i.dataset.href ? i.nextElementSibling.click() : n.doClick ? n.isNext ? n.next() : n.previous() : n.$modal && n.openModal(i) : n.snap()))
                    })), gh(this, "previous", (function () {
                        n.idxLast = n.idxCurrent, n.idxCurrent = Math.max(0, n.idxCurrent - 1), n.tx = n.snaps[n.idxCurrent], n.setCurrent(), n.clamp()
                    })), gh(this, "next", (function () {
                        n.idxLast = n.idxCurrent, n.idxCurrent = Math.min(n.total, n.idxCurrent + 1), n.tx = n.snaps[n.idxCurrent], n.setCurrent(), n.clamp()
                    })), gh(this, "tick", (function () {
                        n.detectUsage(), n.still || (n.cx = kc()(n.cx, n.tx, n.ease), !n.isResizing && n.transformSlides())
                    })), gh(this, "closeModal", (function () {
                        n.modal = !1, Ki.to(n.$modal, {
                            autoAlpha: 0,
                            duration: .5,
                            ease: "power1",
                            onComplete: function () {
                                n.$modalVid.pause(), n.$modalVid.src = ""
                            }
                        })
                    })), gh(this, "resize", (function () {
                        n.isResizing = !0, n.setCache(), n.idxMap = Ki.utils.mapRange(0, n.max, 0, n.total + 1), n.transformSlides(), n.isResizing = !1
                    })), this.el = e, this.$container = yh(".js-slides", e), this.$cursor = yh(".js-mouse-follow-inner", e), this.$modal = yh(".js-modal", e), this.el.classList.remove("hidden"), this.$slides = bh(".js-slide", e), this.$slides = this.$slides.filter((function (t) {
                        return xh(t)
                    })), this.$slides.length > 0 ? (this.el.classList.remove("hidden"), this.$slides[0].classList.add("is-active")) : this.el.classList.add("hidden"), this.$current = yh(".js-current", e), this.$total = yh(".js-total", e), this.$previous = bh(".js-previous", e), this.$next = bh(".js-next", e), this.total = this.$slides.length - 1, this.$total && (this.$total.innerHTML = this.$slides.length), this.tx = 0, this.cx = 0, this.max = 0, this.cancelX = 0, this.cancelY = 0, this.on = 0, this.ease = .1, this.speed = 2, this.idxLast = null, this.idxCurrent = 0, this.idxMap = null, this.isDragging = !1, this.isResizing = !1, this.isNext = !0, this.doClick = yh("[data-disabled-mobile]", this.el), e.instance = this, this.setCurrent(), requestAnimationFrame((function () {
                        n.mount(), ia.create({
                            trigger: n.el,
                            onToggle: function (t) {
                                t.isActive ? n.bindEvents() : n.unbindEvents()
                            }
                        })
                    }))
                }), [{
                    key: "setCache",
                    value: function () {
                        var t = this,
                            e = _h(this.$container);
                        this.snaps = [], this.cache = this.$slides.map((function (n, i) {
                            n.style.transform = "translate3d(0, 0, 0)";
                            var r = yh("[data-video-src]", n),
                                s = _h(n),
                                o = s.left,
                                a = s.right,
                                l = s.width;
                            return t.snaps.push(o - e.left), i === t.total && (t.max = a - e.left - e.width), {
                                slide: n,
                                left: o,
                                width: l,
                                tl: null,
                                start: o - wh.ww,
                                end: a,
                                out: !0,
                                slideVid: r
                            }
                        }))
                    }
                }, {
                    key: "clamp",
                    value: function () {
                        this.tx = Ki.utils.clamp(0, this.max, this.tx)
                    }
                }, {
                    key: "snap",
                    value: function () {
                        this.tx = Ki.utils.snap(this.snaps, this.tx), this.idxLast = this.idxCurrent, this.idxCurrent = this.snaps.indexOf(this.tx), this.setCurrent(), this.clamp()
                    }
                }, {
                    key: "visible",
                    value: function (t, e, n, i) {
                        var r = this.cx > t && this.cx < e,
                            s = 0;
                        return r && (s = Ki.utils.clamp(0, 1, 1 + (this.cx - i - n) / (wh.ww + n))), {
                            isVisible: r,
                            progress: s
                        }
                    }
                }, {
                    key: "detectUsage",
                    value: function () {
                        this.diff = this.tx - this.cx, this.still = Math.abs(this.diff) < .05
                    }
                }, {
                    key: "setCurrent",
                    value: function () {
                        var t = this;
                        this.$current && (this.$slides.forEach((function (e) {
                            e === t.$slides[t.idxCurrent] ? e.classList.add("is-active") : e.classList.remove("is-active")
                        })), this.idxCurrent !== this.idxLast && (this.$current.textContent = this.idxCurrent + 1))
                    }
                }, {
                    key: "transformSlides",
                    value: function () {
                        var t = this;
                        this.cache.forEach((function (e, n) {
                            var i = e.start,
                                r = e.end,
                                s = e.width,
                                o = e.left,
                                a = e.slide,
                                l = e.tl,
                                u = t.visible(i, r, s, o),
                                c = u.isVisible,
                                h = u.progress;
                            c || t.isResizing ? (e.out && (e.out = !1), t.transform(a, -t.cx, h, l)) : e.out || (e.out = !0, t.transform(a, -t.cx, h, l))
                        }))
                    }
                }, {
                    key: "transform",
                    value: function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -this.cx,
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                        t.style.transform = "translate3d(".concat(e, "px, 0, 0)"), i && i.progress(n)
                    }
                }, {
                    key: "openModal",
                    value: function (t) {
                        var e = t.closest(".js-slide");
                        if (e) {
                            var n = this.cache.find((function (t) {
                                return t.slide === e
                            })).slideVid;
                            if (n) {
                                var i = n.dataset.videoSrc;
                                i && (!this.$modalVid && (this.$modalVid = yh(".js-modal-vid", this.$modal)), this.$modalVid.src = i, this.$modalVid.currentTime = 0, this.$modalVid.play(), this.isModal = !0, Ki.to(this.$modal, {
                                    autoAlpha: 1,
                                    duration: .5,
                                    ease: "power1"
                                }))
                            }
                        }
                    }
                }, {
                    key: "bindEvents",
                    value: function () {
                        this.inited || (this.inited = !0, lc.on("mousedown", this.down), lc.on("mouseup", this.up), lc.on("mousemove", this.move), lc.on("resize", this.resize), lc.on("tick", this.tick), this.$modal && (this.$modalClose = yh(".js-modal-close", this.$modal), lc.on("click", this.$modalClose, this.closeModal)), this.$previous.length && lc.on("click", this.$previous, this.previous), this.$next.length && lc.on("click", this.$next, this.next))
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        this.inited && (this.inited = !1, lc.off("mousedown", this.down), lc.off("mouseup", this.up), lc.off("mousemove", this.move), lc.off("resize", this.resize), lc.off("tick", this.tick), this.$modal && lc.off("click", this.$modalClose, this.closeModal), this.$previous.length && lc.off("click", this.$previous, this.previous), this.$next.length && lc.off("click", this.$next, this.next))
                    }
                }, {
                    key: "mount",
                    value: function () {
                        this.resize()
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }());

        function Sh(t) {
            return Sh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Sh(t)
        }

        function Th(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Dh(i.key), i)
            }
        }

        function Eh(t, e, n) {
            return e && Th(t.prototype, e), n && Th(t, n), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function Dh(t) {
            var e = function (t, e) {
                if ("object" != Sh(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Sh(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Sh(e) ? e : e + ""
        }
        var Ch = Eh((function t(e) {
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = e.querySelector("iframe"),
                i = function () {
                    var t, e, n, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        r = Array.isArray(null == i ? void 0 : i.match(/vimeo/gi)),
                        s = Array.isArray(null == i ? void 0 : i.match(/youtu/gi));
                    if (r) {
                        var o, a = null === (o = i.split("com/")) || void 0 === o ? void 0 : o[1];
                        t = a ? "https://player.vimeo.com/video/".concat(a, "?title=0&byline=0&portrait=0&autoplay=0") : null, e = "vimeo"
                    } else if (s) {
                        var l = void 0 !== (n = (n = i).replace(/(>|<)/gi, "").split(/(vi\/|v=|\/v\/|youtu\.be\/|\/embed\/)/))[2] ? n[2].split(/[^0-9a-z_\-]/i)[0] : n;
                        t = l ? "https://www.youtube.com/embed/".concat(l, "?autoplay=0&rel=0") : null, e = "youtube"
                    } else t = null;
                    return {
                        embededUrl: t,
                        platform: e
                    }
                }(n.dataset.src),
                r = i.embededUrl;
            i.platform, n.src = r
        })),
            Ah = 0,
            Ph = [];

        function Lh() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            if (t !== Ah) {
                var e = document.createElement("script");
                e.setAttribute("src", Ph[t].src), e.setAttribute("id", Ph[t].id), e.async = !1, document.body.appendChild(e), t < Ah && (e.onload = Lh(t + 1))
            }
        }

        function Rh(t) {
            Ph = t, Ah = t.length, Lh()
        }

        function kh(t) {
            return kh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, kh(t)
        }

        function Oh(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Ih(i.key), i)
            }
        }

        function Ih(t) {
            var e = function (t, e) {
                if ("object" != kh(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != kh(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == kh(e) ? e : e + ""
        }
        var Fh = cc,
            Nh = hc,
            zh = function () {
                return function (t, e, n) {
                    return e && Oh(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.el = e, this.status = {
                        jsonJs: !1,
                        extraJs: !1,
                        main: !1,
                        condLogicExtra: !1,
                        maskedInput: !1,
                        condLogic: !1,
                        recaptcha: !0
                    }, Motto.fromTransition && this.init()
                }), [{
                    key: "init",
                    value: function () {
                        Fh("#wp-dom-ready-js") || this.initWpDomReadyJs(), Fh("#gform_json-js") ? (this.status.jsonJs = !0, this.checkAllLoaded()) : this.initJsonJS(), Fh("#gform_gravityforms-js-extra") ? (this.status.extraJs = !0, this.checkAllLoaded()) : this.initExtraJs(), Fh("#gform_gravityforms-js") ? (this.status.main = !0, this.checkAllLoaded()) : this.initMainJs(), Fh("#gform_conditional_logic-js-extra") ? (this.status.condLogicExtra = !0, this.checkAllLoaded()) : this.initConditionalLogicExtra(), Fh("#gform_conditional_logic-js") ? (this.status.condLogic = !0, this.checkAllLoaded()) : this.initConditionalLogic(), Fh("#gform_masked_input-js") ? (this.status.maskedInput = !0, this.checkAllLoaded()) : this.initMaskedInput()
                    }
                }, {
                    key: "initializeGF",
                    value: function () {
                        if (Motto.fromTransition) {
                            var t = Nh("script", this.el),
                                e = t.length;
                            t.forEach((function (t, n) {
                                var i = document.createElement("script");
                                i.classList.add("gform_form_scripts_hook1"), n == e - 1 && i.classList.add("gform_form_scripts_last_script"), i.innerHTML = t.innerHTML, i.id = "gform_form_scripts_hook1_".concat(n), Fh("body").append(i)
                            })), window.dispatchEvent(new Event("DOMContentLoaded"))
                        }
                    }
                }, {
                    key: "unmountHook1",
                    value: function () {
                        Nh(".gform_form_scripts_hook1").forEach((function (t) {
                            t.remove()
                        }))
                    }
                }, {
                    key: "initConditionalLogic",
                    value: function () {
                        var t = document.createElement("script");
                        this._onLoadConditionalLogicJs = this.onLoadConditionalLogicJs.bind(this), t.addEventListener("load", this._onLoadConditionalLogicJs), t.src = "".concat(window.Motto.site_url, "/app/plugins/gravityforms/js/conditional_logic.js?ver=2.6.4"), t.id = "gform_conditional_logic-js", Fh("body").append(t)
                    }
                }, {
                    key: "initMaskedInput",
                    value: function () {
                        var t = document.createElement("script");
                        this._onLoadMaskedInputJs = this.onLoadMaskedInputJs.bind(this), t.addEventListener("load", this._onLoadMaskedInputJs), t.src = "".concat(window.Motto.site_url, "/app/plugins/gravityforms/js/jquery.maskedinput.js?ver=2.6.4"), t.id = "gform_masked_input-js", Fh("body").append(t)
                    }
                }, {
                    key: "initWpDomReadyJs",
                    value: function () {
                        Motto.statusWpScripts.domReady || (Motto.statusWpScripts.domReady = !0, Rh([{
                            src: "".concat(window.Motto.site_url, "/cms/wp-includes/js/dist/dom-ready.js"),
                            id: "wp-dom-ready-js"
                        }, {
                            src: "".concat(window.Motto.site_url, "/cms/wp-includes/js/dist/hooks.js"),
                            id: "wp-hooks-js"
                        }, {
                            src: "".concat(window.Motto.site_url, "/cms/wp-includes/js/dist/i18n.js"),
                            id: "wp-i18n-js"
                        }, {
                            src: "".concat(window.Motto.site_url, "/cms/wp-includes/js/dist/a11y.js"),
                            id: "wp-a11y-js"
                        }]))
                    }
                }, {
                    key: "initConditionalLogicExtra",
                    value: function () {
                        var t = document.createElement("script");
                        t.innerHTML = '\n      /* <![CDATA[ */\n      var gf_legacy = {"is_legacy":""};\n      /* ]]> */\n    ', t.id = "gform_conditional_logic-js-extra", this.status.condLogicExtra = !0, Fh("body").append(t)
                    }
                }, {
                    key: "initMainJs",
                    value: function () {
                        var t = document.createElement("script");
                        this._onLoadMainJs = this.onLoadMainJs.bind(this), t.addEventListener("load", this._onLoadMainJs), t.src = "".concat(window.Motto.site_url, "/app/plugins/gravityforms/js/gravityforms.js?ver=2.6.4"), t.id = "gform_gravityforms-js", Fh("body").append(t)
                    }
                }, {
                    key: "initExtraJs",
                    value: function () {
                        var t = document.createElement("script");
                        t.innerHTML = "\n      /* <![CDATA[ */\n      var gform_i18n = ".concat(JSON.stringify(Motto.gform_i18n), ";\n      var gf_legacy_multi = ").concat(JSON.stringify(Motto.gf_legacy_multi), ";\n      var gform_gravityforms = ").concat(JSON.stringify(Motto.gform_gravityforms), ";\n      var gf_global = ").concat(JSON.stringify(Motto.gf_global), ";\n      /* ]]> */\n    "), t.id = "gform_gravityforms-js-extra", this.status.extraJs = !0, Fh("body").append(t)
                    }
                }, {
                    key: "initJsonJS",
                    value: function () {
                        var t = document.createElement("script");
                        this._onLoadJson = this.onLoadJson.bind(this), t.addEventListener("load", this._onLoadJson), t.src = "".concat(window.Motto.site_url, "/app/plugins/gravityforms/js/jquery.json.js?ver=2.6.4"), t.id = "gform_json-js", Fh("body").append(t)
                    }
                }, {
                    key: "checkAllLoaded",
                    value: function () {
                        var t = !0;
                        for (var e in this.status) Object.hasOwnProperty.call(this.status, e) && (this.status[e] || (t = !1));
                        t && this.initializeGF()
                    }
                }, {
                    key: "onLoadJson",
                    value: function (t) {
                        this.status.jsonJs = !0, this.checkAllLoaded()
                    }
                }, {
                    key: "onLoadMainJs",
                    value: function (t) {
                        this.status.main = !0, this.checkAllLoaded()
                    }
                }, {
                    key: "onLoadConditionalLogicJs",
                    value: function (t) {
                        this.status.condLogic = !0, this.checkAllLoaded()
                    }
                }, {
                    key: "onLoadMaskedInputJs",
                    value: function (t) {
                        this.status.maskedInput = !0, this.checkAllLoaded()
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unmountHook1()
                    }
                }])
            }();

        function Uh(t) {
            return Uh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Uh(t)
        }

        function Bh(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, jh(i.key), i)
            }
        }

        function jh(t) {
            var e = function (t, e) {
                if ("object" != Uh(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Uh(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Uh(e) ? e : e + ""
        }
        var Hh = hc,
            Vh = function () {
                return function (t, e, n) {
                    return e && Bh(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                        function (t, e, n) {
                            (e = jh(e)) in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n
                        }(this, "toggle", (function (t) {
                            var e = t.currentTarget;
                            n.$toggles.forEach((function (t) {
                                t === e ? t.classList.add("is-active") : t.classList.remove("is-active")
                            })), n.idxLast = n.idxCurrent, n.idxCurrent = n.$toggles.indexOf(e), n.animate()
                        })), this.el = e, this.$toggles = Hh(".js-toggle-tab", e), this.$tabs = Hh(".js-tab", e), this.idxLast = -1, this.idxCurrent = 0, this.tl = Ki.timeline({
                            paused: !0,
                            defaults: {
                                duration: .35,
                                ease: "power1"
                            }
                        }), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("click", this.$toggles, this.toggle)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.$toggles, this.toggle)
                    }
                }, {
                    key: "animate",
                    value: function () {
                        var t = this.$tabs[this.idxCurrent],
                            e = this.$tabs[this.idxLast];
                        t.style.display = "block", e.style.display = "none"
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }(),
            Gh = cc;

        function Wh(t) {
            var e = Gh(".js-cover", t),
                n = Gh(".js-vid", t),
                i = !1;

            function r() {
                i = !0, lc.off("click", t, r), Ki.to(e, {
                    alpha: 0,
                    duration: .5,
                    ease: "power1",
                    onComplete: e.remove()
                }), n.classList.remove("pointer-events-none"), n.src = n.src.replace("autoplay=0", "autoplay=1")
            }
            return lc.on("click", t, r), {
                unmount: function () {
                    !i && lc.off("click", t, r)
                }
            }
        }

        function $h(t) {
            return $h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, $h(t)
        }

        function Xh(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Yh(i.key), i)
            }
        }

        function qh(t, e, n) {
            return (e = Yh(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Yh(t) {
            var e = function (t, e) {
                if ("object" != $h(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != $h(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == $h(e) ? e : e + ""
        }
        var Kh = cc,
            Jh = hc,
            Zh = dc,
            Qh = yc.device,
            td = function () {
                return function (t, e, n) {
                    return e && Xh(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), qh(this, "toggle", (function (t) {
                        var e = t.currentTarget;
                        n.$toggles.forEach((function (t) {
                            t === e ? (t.classList.add("pointer-events-none"), t.classList.remove("opacity-25")) : (t.classList.remove("pointer-events-none"), t.classList.add("opacity-25"))
                        })), n.idxLast = n.idxCurrent, n.idxCurrent = n.$toggles.indexOf(e), !Qh.isSmall && n.$tabsParent && Ki.to(n.$tabsParent, {
                            x: -Math.min(n.max, n.snaps[n.idxCurrent]),
                            duration: .5,
                            ease: "power3"
                        }), n.animate()
                    })), qh(this, "resize", (function () {
                        if (!Qh.isSmall && n.$tabsParent) {
                            Ki.set(n.$tabsParent, {
                                x: 0
                            });
                            var t = Zh(n.$tabsParent),
                                e = t.left,
                                i = t.width,
                                r = n.$toggles.length - 1;
                            n.snaps = n.$toggles.map((function (t, s) {
                                var o = Zh(t),
                                    a = o.left,
                                    l = o.right;
                                return s === r && (n.max = l - i - e), a - e
                            })), Ki.set(n.$tabsParent, {
                                x: -Math.min(n.max, n.snaps[n.idxCurrent])
                            })
                        }
                    })), this.el = e, this.$toggles = Jh(".js-toggle-tab", e), this.$tabs = Jh(".js-tab", e), this.$tabsParent = Kh(".js-toggle-tab-parent", e), this.idxLast = 0, this.idxCurrent = 0, this.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: .5,
                            ease: "power1"
                        }
                    }), this.resize(), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("click", this.$toggles, this.toggle), lc.on("resize-reset", this.resize)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.$toggles, this.toggle), lc.off("resize-reset", this.resize)
                    }
                }, {
                    key: "animate",
                    value: function () {
                        this.tl.clear().to(this.$tabs[this.idxLast], {
                            alpha: 0
                        }).set([this.$tabs[this.idxLast], this.$tabs[this.idxCurrent]], {
                            display: Ki.utils.wrap(["none", "block"])
                        }).to(this.$tabs[this.idxCurrent], {
                            alpha: 1
                        }).restart()
                    }
                }, {
                    key: "ummount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function ed(t) {
            return ed = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ed(t)
        }

        function nd(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, id(i.key), i)
            }
        }

        function id(t) {
            var e = function (t, e) {
                if ("object" != ed(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != ed(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == ed(e) ? e : e + ""
        }
        var rd = cc,
            sd = hc,
            od = function () {
                return function (t, e, n) {
                    return e && nd(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.el = e, this.$filterSelector = rd(".filter-works-list", e), this.$items = sd("article", e), this.bindEvents()
                }), [{
                    key: "filterList",
                    value: function (t) {
                        this.$items.forEach((function (e) {
                            -1 !== e.dataset.categories.indexOf(t) ? e.classList.remove("hidden") : e.classList.add("hidden")
                        }))
                    }
                }, {
                    key: "changeFilter",
                    value: function (t) {
                        var e = t.target.value;
                        this.filterList(e)
                    }
                }, {
                    key: "bindEvents",
                    value: function () {
                        this._changeFilter = this.changeFilter.bind(this), lc.on("change", this.$filterSelector, this._changeFilter)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("change", this.$filterSelector, this._changeFilter)
                    }
                }, {
                    key: "ummount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function ad(t) {
            return ad = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ad(t)
        }

        function ld(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, ud(i.key), i)
            }
        }

        function ud(t) {
            var e = function (t, e) {
                if ("object" != ad(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != ad(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == ad(e) ? e : e + ""
        }
        var cd = cc,
            hd = hc,
            dd = pc,
            fd = function () {
                return function (t, e, n) {
                    return e && ld(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.el = e, this.itemsPerPage = e.dataset.componentItemsPerPage ? Number.parseInt(e.dataset.componentItemsPerPage) : 12, this.totalFilteredPosts = 0, this.$items = hd(".js-post-item", e), this.$itemsSlider = hd(".js-post-item-slider", e), this.$tabs = hd(".js-filter-tab", e), this.$loadMore = cd(".js-load-more", e), this.$totalVisiblePosts = cd("#total_visible_posts", e), this.$totalPosts = cd("#total_posts", e), this.totalItems = this.$items.length, this.featuredSlider = cd('[data-component="DraggableBase"]'), this.filterActive = !1;
                    var i = !!e.dataset.componentSelected && e.dataset.componentSelected;
                    this.bindEvents(), i ? setTimeout((function () {
                        n.$tabs.find((function (t) {
                            return t.dataset.category == i
                        })).click()
                    }), 10) : (this.setVisibleItems(!1), this.checkLoadMoreVisibility(), this.updateTotalMessage())
                }), [{
                    key: "bindEvents",
                    value: function () {
                        this._toggle = this.toggle.bind(this), lc.on("click", this.$tabs, this._toggle), this._onLoadMoreClick = this.onLoadMoreClick.bind(this), lc.on("click", this.$loadMore, this._onLoadMoreClick)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.$tabs, this._toggle), lc.off("click", this.$loadMore, this._onLoadMoreClick)
                    }
                }, {
                    key: "onLoadMoreClick",
                    value: function (t) {
                        this.setVisibleItems(this.filterActive), this.checkLoadMoreVisibility(), this.updateTotalMessage()
                    }
                }, {
                    key: "toggle",
                    value: function (t) {
                        this.hideAllItems();
                        var e = this.filterActive != t.target.dataset.category && t.target.dataset.category;
                        this.filter(e)
                    }
                }, {
                    key: "filter",
                    value: function (t) {
                        this.setVisibleItems(t), this.filterActive = t, this.updateTabs(), this.updateFeaturedSlider(), this.checkLoadMoreVisibility(), this.updateTotalMessage()
                    }
                }, {
                    key: "updateFeaturedSlider",
                    value: function () {
                        this.featuredSlider && (this.featuredSlider.instance.unmount(), new Mh(this.featuredSlider))
                    }
                }, {
                    key: "hideAllItems",
                    value: function () {
                        for (var t = 0; t < this.$items.length; t++) this.$items[t].classList.add("hidden");
                        for (var e = 0; e < this.$itemsSlider.length; e++) this.$itemsSlider[e].classList.add("hidden")
                    }
                }, {
                    key: "setVisibleItems",
                    value: function (t) {
                        for (var e = 0; e < this.$itemsSlider.length; e++) {
                            var n = this.$itemsSlider[e];
                            t && n.dataset.categoryId != t || n.classList.remove("hidden")
                        }
                        for (var i = this.itemsPerPage, r = 0; r < this.$items.length; r++) {
                            var s = this.$items[r];
                            if (!(t && s.dataset.categoryId != t || dd(s))) {
                                if (!i) break;
                                s.classList.remove("hidden"), i--
                            }
                        }
                    }
                }, {
                    key: "getTotalFilteredPosts",
                    value: function () {
                        var t = this.filterActive ? '[data-category-id="'.concat(this.filterActive, '"]') : "";
                        return hd(".js-post-item".concat(t), this.el).length
                    }
                }, {
                    key: "getTotalVisiblePosts",
                    value: function () {
                        var t = 0;
                        return this.$items.forEach((function (e) {
                            t += dd(e) ? 1 : 0
                        })), t
                    }
                }, {
                    key: "updateTotalMessage",
                    value: function () {
                        var t = this.getTotalVisiblePosts();
                        this.$totalVisiblePosts && (this.$totalVisiblePosts.innerHTML = t), this.$totalPosts && (this.$totalPosts.innerHTML = this.totalFilteredPosts)
                    }
                }, {
                    key: "updateTabs",
                    value: function () {
                        var t = this;
                        this.$tabs.forEach((function (e) {
                            e.classList.remove("bg-black", "text-white"), e.classList.add("bg-white", "text-black"), t.filterActive == e.dataset.category && (e.classList.remove("bg-white", "text-black"), e.classList.add("bg-black", "text-white"))
                        }))
                    }
                }, {
                    key: "checkLoadMoreVisibility",
                    value: function () {
                        this.totalFilteredPosts = this.getTotalFilteredPosts();
                        var t = this.getTotalVisiblePosts();
                        this.totalFilteredPosts == t ? this.$loadMore.parentElement.classList.add("hidden") : this.$loadMore.parentElement.classList.remove("hidden")
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function pd(t) {
            return pd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, pd(t)
        }

        function md(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, gd(i.key), i)
            }
        }

        function gd(t) {
            var e = function (t, e) {
                if ("object" != pd(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != pd(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == pd(e) ? e : e + ""
        }
        var vd = hc,
            yd = function () {
                return function (t, e, n) {
                    return e && md(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.el = e, this.$tabs = vd(".js-filter-tab", e), this.filterSelected = !1, this.selectedFilters = {}, this.$tabs.forEach((function (t) {
                        n.selectedFilters[t.dataset.category] = !1
                    })), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        this._toggle = this.toggle.bind(this), lc.on("click", this.$tabs, this._toggle)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.$tabs, this._toggle)
                    }
                }, {
                    key: "toggle",
                    value: function (t) {
                        this.selectedFilters[t.target.dataset.category] = !this.selectedFilters[t.target.dataset.category], this.filter()
                    }
                }, {
                    key: "filter",
                    value: function () {
                        this.updateTabs();
                        var t = !1;
                        for (var e in this.selectedFilters) this.selectedFilters[e] && (t = !0);
                        for (var n in this.selectedFilters) {
                            document.getElementById(n).style.display = t ? this.selectedFilters[n] ? "block" : "none" : "block"
                        }
                    }
                }, {
                    key: "updateTabs",
                    value: function () {
                        var t = this;
                        this.$tabs.forEach((function (e) {
                            var n = e.dataset.category;
                            t.selectedFilters[n] ? (e.classList.remove("bg-white", "text-black"), e.classList.add("bg-black", "text-white")) : (e.classList.remove("bg-black", "text-white"), e.classList.add("bg-white", "text-black"))
                        }))
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function bd(t) {
            return bd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, bd(t)
        }

        function _d(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, xd(i.key), i)
            }
        }

        function xd(t) {
            var e = function (t, e) {
                if ("object" != bd(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != bd(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == bd(e) ? e : e + ""
        }
        var wd = cc,
            Md = hc,
            Sd = pc,
            Td = function () {
                return function (t, e, n) {
                    return e && _d(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.el = e, this.itemsPerPage = e.dataset.componentItemsPerPage ? Number.parseInt(e.dataset.componentItemsPerPage) : 12, this.totalFilteredPosts = 0, this.$items = Md(".js-post-item", e), this.$itemsContainer = wd("#list-items-container", e), window.$items = this.$items, this.$loadMore = wd(".js-load-more", e), this.$totalVisiblePosts = wd("#total_visible_posts", e), this.$totalPosts = wd("#total_posts", e), this.totalItems = this.$items.length, this.$filterButtons = Md(".js-category-filter-button"), this.$sortButtons = Md(".js-sort-button"), this.filterActive = !1, this.filterType = "category", this.bindEvents(), this.setVisibleItems(!1), this.checkLoadMoreVisibility(), this.updateTotalMessage(), setTimeout((function () {
                        n.clientFilter = wd(".js-filter-client", e).instance, n.phaseFilter = wd(".js-filter-phase", e).instance
                    }), 200)
                }), [{
                    key: "bindEvents",
                    value: function () {
                        this._clickFilter = this.clickFilter.bind(this), lc.on("click", this.$filterButtons, this._clickFilter), this._clickSort = this.clickSort.bind(this), lc.on("click", this.$sortButtons, this._clickSort), this._onLoadMoreClick = this.onLoadMoreClick.bind(this), lc.on("click", this.$loadMore, this._onLoadMoreClick)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.$loadMore, this._onLoadMoreClick), lc.off("click", this.$filterButtons, this._clickFilter), lc.off("click", this.$sortButtons, this._clickSort)
                    }
                }, {
                    key: "clickSort",
                    value: function (t) {
                        var e = this,
                            n = t.currentTarget.dataset.cat,
                            i = $items.map((function (t) {
                                return {
                                    id: t.id,
                                    date: t.dataset.date,
                                    name: t.dataset.lowercaseName
                                }
                            }));
                        ("name" == n ? i.sort((function (t, e) {
                            return t.name > e.name ? 1 : -1
                        })) : i.sort((function (t, e) {
                            return t.date > e.date ? 1 : -1
                        }))).forEach((function (t) {
                            var n = wd("#".concat(t.id));
                            e.$itemsContainer.append(n)
                        }))
                    }
                }, {
                    key: "clickFilter",
                    value: function (t) {
                        if (this.hideAllItems(), t.currentTarget.dataset.cat) {
                            var e = "-1" != t.currentTarget.dataset.cat && t.currentTarget.dataset.cat;
                            this.filterType = "category", this.filter(e), this.phaseFilter.reset()
                        } else {
                            var n = "-1" != t.currentTarget.dataset.phase && t.currentTarget.dataset.phase;
                            this.filterType = "phase", this.filter(n), this.clientFilter.reset()
                        }
                    }
                }, {
                    key: "onLoadMoreClick",
                    value: function (t) {
                        this.setVisibleItems(this.filterActive), this.checkLoadMoreVisibility(this.filterType), this.updateTotalMessage()
                    }
                }, {
                    key: "filter",
                    value: function (t) {
                        this.setVisibleItems(t), this.filterActive = t, this.checkLoadMoreVisibility(), this.updateTotalMessage()
                    }
                }, {
                    key: "hideAllItems",
                    value: function () {
                        for (var t = 0; t < this.$items.length; t++) this.$items[t].classList.add("hidden")
                    }
                }, {
                    key: "setVisibleItems",
                    value: function (t) {
                        for (var e = this.itemsPerPage, n = 0; n < this.$items.length; n++) {
                            var i = this.$items[n];
                            if (!(t && i.dataset["".concat(this.filterType, "Id")] != t || Sd(i))) {
                                if (!e) break;
                                i.classList.remove("hidden"), e--
                            }
                        }
                    }
                }, {
                    key: "getTotalFilteredPosts",
                    value: function () {
                        var t = this.filterActive ? "[data-".concat(this.filterType, '-id="').concat(this.filterActive, '"]') : "";
                        return Md(".js-post-item".concat(t), this.el).length
                    }
                }, {
                    key: "getTotalVisiblePosts",
                    value: function () {
                        var t = 0;
                        return this.$items.forEach((function (e) {
                            t += Sd(e) ? 1 : 0
                        })), t
                    }
                }, {
                    key: "updateTotalMessage",
                    value: function () {
                        var t = this.getTotalVisiblePosts();
                        this.$totalVisiblePosts && (this.$totalVisiblePosts.innerHTML = t), this.$totalPosts && (this.$totalPosts.innerHTML = this.totalFilteredPosts)
                    }
                }, {
                    key: "checkLoadMoreVisibility",
                    value: function () {
                        this.totalFilteredPosts = this.getTotalFilteredPosts();
                        var t = this.getTotalVisiblePosts();
                        this.totalFilteredPosts == t ? this.$loadMore.parentElement.classList.add("hidden") : this.$loadMore.parentElement.classList.remove("hidden")
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function Ed(t) {
            return Ed = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Ed(t)
        }

        function Dd(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Ad(i.key), i)
            }
        }

        function Cd(t, e, n) {
            return (e = Ad(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Ad(t) {
            var e = function (t, e) {
                if ("object" != Ed(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Ed(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Ed(e) ? e : e + ""
        }
        var Pd = hc,
            Ld = dc,
            Rd = fc,
            kd = (yc.bounds, yc.device),
            Od = function () {
                return function (t, e, n) {
                    return e && Dd(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Cd(this, "shuffle", (function () {
                        n.idxLast = n.idxCurrent, n.idxCurrent = Ki.utils.wrap(0, n.cache.length, n.idxCurrent + 1);
                        var t = n.cache[n.idxLast],
                            e = n.cache[n.idxCurrent];
                        t.item.style.display = "none", t.item.style.visibility = "hidden", e.item.style.display = "flex", e.item.style.visibility = "visible"
                    })), Cd(this, "toggle", (function (t) {
                        var e = t.clientX,
                            i = t.clientY;
                        n.x = e, n.y = i - Ld(n.el).top;
                        var r = n.cache.length;
                        n.idxLast = Ki.utils.wrap(0, r, n.idxLast + 1), n.idxCurrent = Ki.utils.wrap(0, r, n.idxCurrent + 1), n.z += 1, n.animate()
                    })), Cd(this, "resize", (function () {
                        !kd.isSmall && n.cache.forEach((function (t) {
                            var e = t.item;
                            Ki.set(e, {
                                maxWidth: "".concat(Rd(37.5, 55), "%")
                            })
                        }))
                    })), this.el = e, this.items = Pd(".js-review", this.el), this.idxLast = -1, this.idxCurrent = kd.isSmall ? 0 : 2, this.z = 3, this.cache = this.items.map((function (t, e) {
                        var n = Ki.timeline({
                            paused: !0,
                            defaults: {
                                duration: .75,
                                ease: "expo"
                            }
                        });
                        return e > 2 && !kd.isSmall && n.set(t, {
                            autoAlpha: 0
                        }).progress(1).progress(0), {
                            item: t,
                            tl: n
                        }
                    })), requestAnimationFrame((function () {
                        n.resize(), n.bindEvents()
                    }))
                }), [{
                    key: "bindEvents",
                    value: function () {
                        kd.isSmall ? lc.on("click", this.el, this.shuffle) : lc.on("click", this.el, this.toggle), lc.on("resize-reset", this.el, this.resize)
                    }
                }, {
                    key: "animate",
                    value: function () {
                        var t = this.cache[this.idxLast],
                            e = this.cache[this.idxCurrent];
                        t.tl.clear().to(t.item, {
                            scale: .75,
                            autoAlpha: 0
                        }).restart(), e.tl.clear().fromTo(e.item, {
                            scale: 1.25,
                            autoAlpha: 0
                        }, {
                            scale: 1,
                            autoAlpha: 1
                        }).restart(), !kd.isSmall && e.tl.set(e.item, {
                            zIndex: this.z,
                            xPercent: -50,
                            yPercent: -50,
                            left: this.x,
                            top: this.y,
                            bottom: "auto"
                        }, 0), e.tl.restart()
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        kd.isSmall ? lc.off("click", this.el, this.shuffle) : lc.off("click", this.el, this.toggle), lc.off("resize-reset", this.el, this.resize)
                    }
                }])
            }();

        function Id(t) {
            return Id = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Id(t)
        }

        function Fd(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, zd(i.key), i)
            }
        }

        function Nd(t, e, n) {
            return (e = zd(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function zd(t) {
            var e = function (t, e) {
                if ("object" != Id(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Id(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Id(e) ? e : e + ""
        }
        var Ud = cc,
            Bd = hc,
            jd = dc,
            Hd = yc.bounds,
            Vd = yc.flags,
            Gd = yc.device;
        Ki.registerPlugin(ia);
        var Wd = function () {
            return function (t, e, n) {
                return e && Fd(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t
            }((function t(e) {
                var n = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), Nd(this, "scroll", (function (t) {
                    t.y;
                    var e = t.dY;
                    Vd.locked && n.animated && (n.t -= e, n.t = Ki.utils.clamp(0, n.max, n.t))
                })), Nd(this, "tick", (function () {
                    n.c = kc()(n.c, n.t, .125), n.tl && n.tl.progress(n.c / n.max), n.progress = Ki.utils.clamp(0, 1, n.c / n.max), Vd.locked && (0 === n.t && n.fired && n.stopAnimation(), n.progress >= .995 && n.fired && (n.fired = !1, BC.redirect(n.to, "next")))
                })), Nd(this, "resize", (function () {
                    n.el.removeAttribute("data-lenis-prevent"), n.max = jd(n.el).height + 2 * Hd.wh, n.offset = jd(n.el).top;
                    var t = jd(n.$content).bottom - n.offset;
                    Gd.isMobile ? n.$line.forEach((function (t) {
                        return Ki.set(t.parentNode, {
                            autoAlpha: 0
                        })
                    })) : Ki.set(n.$line, {
                        scaleX: 0
                    }), n.tl && n.tl.kill(), n.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: 1,
                            ease: "none"
                        }
                    }).fromTo(n.$prox, {
                        y: -t
                    }, {
                        y: 0,
                        duration: 1
                    }, 0).fromTo(n.$masks, {
                        y: Ki.utils.wrap([t, .5 * -t])
                    }, {
                        y: 0,
                        duration: 1
                    }, 0), Gd.isMobile ? n.$line.forEach((function (t) {
                        return Ki.set(t.parentNode, {
                            autoAlpha: 0
                        })
                    })) : n.tl.to(n.$line, {
                        scaleX: 1
                    }, 0)
                })), Nd(this, "click", (function () {
                    n.fired || (n.fired = !0, n.unbindEvents(), Ki.to(n.tl, {
                        progress: 1,
                        duration: 1,
                        ease: "power3.inOut",
                        onComplete: function () {
                            BC.redirect(n.to, "next")
                        }
                    }))
                })), this.el = e, this.$line = Bd(".js-line", this.el), this.$stick = Ud(".js-stick", this.el), this.$masks = Bd(".js-image-mask", this.el), this.$content = Ud(".js-content", this.el), this.$prox = Ud(".js-content-prox", this.el), this.$labels = Bd(".js-next-label", this.el), this.$flipSwitcher = Ud(".js-switcher-tabs"), this.$flipContainer = Ud(".js-flip-btn", this.$flipSwitcher), this.to = Ud("a", this.el).href || window.location.origin, this.t = 0, this.c = 0, this.max = 0, this.progress = 0, this.fired = !1, this.animated = !1, this.on = !1, this.resize(), this.bindEvents(), this.tl && this.tl.kill()
            }), [{
                key: "bindEvents",
                value: function () {
                    this.init(), Gd.isMobile ? lc.on("click", this.el, this.click) : (lc.on("tick", this.tick), lc.on("scroller", this.scroll)), lc.on("resize-reset", this.resize)
                }
            }, {
                key: "unbindEvents",
                value: function () {
                    Gd.isMobile ? lc.off("click", this.el, this.click) : (lc.off("scroller", this.scroll), lc.off("tick", this.tick)), lc.off("scroll-resetter", this.resize), ia.getAll().forEach((function (t) {
                        return t.kill()
                    }))
                }
            }, {
                key: "unmount",
                value: function () {
                    this.tl && this.tl.kill(), this.unbindEvents()
                }
            }, {
                key: "init",
                value: function () {
                    var t = this;
                    ia.create({
                        trigger: this.el,
                        start: "top bottom",
                        end: function () {
                            return "+=".concat(t.max)
                        },
                        onUpdate: function (e) {
                            e.progress >= .3 && !t.fired && !t.animated && t.startAnimation();
                            var n = e.progress / e.end;
                            t.t = n * t.max
                        }
                    })
                }
            }, {
                key: "startAnimation",
                value: function () {
                    var t = this;
                    Vd.locked = !0, this.fired = !0, this.animated = !0, this.el.setAttribute("data-lenis-prevent", ""), Ki.to(this.$flipSwitcher, {
                        alpha: 0,
                        onComplete: function () {
                            t.$flipContainer.style.pointerEvents = "none"
                        }
                    }), this.tl.play()
                }
            }, {
                key: "stopAnimation",
                value: function () {
                    var t = this;
                    Vd.locked = !1, this.fired = !1, this.animated = !1, this.el.removeAttribute("data-lenis-prevent"), Ki.to(this.$flipSwitcher, {
                        alpha: 1,
                        onComplete: function () {
                            t.$flipContainer.style.pointerEvents = "auto"
                        }
                    }), this.tl.pause()
                }
            }])
        }();

        function $d(t) {
            return $d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, $d(t)
        }

        function Xd(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Yd(i.key), i)
            }
        }

        function qd(t, e, n) {
            return (e = Yd(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Yd(t) {
            var e = function (t, e) {
                if ("object" != $d(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != $d(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == $d(e) ? e : e + ""
        }
        var Kd = cc,
            Jd = hc,
            Zd = yc.dom,
            Qd = yc.flags,
            tf = function () {
                return function (t, e, n) {
                    return e && Xd(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), qd(this, "scroll", (function (t) {
                        var e = t.y;
                        e > 100 && !n.active ? (n.active = !0, n.out()) : e <= 100 && n.active && (n.active = !1, n.in())
                    })), qd(this, "out", (function () {
                        Qd.headDisabled || (Zd.body.classList.add("is-head-active"), n.tl.clear().to(n.links, {
                            yPercent: -100,
                            alpha: 0,
                            stagger: -.035
                        }, 0).to(n.cta, {
                            xPercent: -100
                        }, 0).to(n.toggle, {
                            autoAlpha: 1
                        }, .25).restart())
                    })), qd(this, "in", (function () {
                        Qd.headDisabled || (Zd.body.classList.remove("is-head-active"), n.tl.clear().to(n.toggle, {
                            autoAlpha: 0,
                            duration: .5
                        }).to(n.cta, {
                            xPercent: 0,
                            duration: 1
                        }, 0).to(n.links, {
                            yPercent: 0,
                            alpha: 1,
                            duration: 1,
                            stagger: .035,
                            ease: "expo"
                        }, 0).restart())
                    })), this.el = e, this.linksWrap = Kd(".js-sh-main-links", this.el), this.links = Jd(".js-sh-main-link", this.el), this.cta = Kd(".js-sh-cta", this.el), this.toggle = Kd(".js-sh-toggle", this.el), this.active = !1, this.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: .75,
                            ease: "snappy"
                        }
                    }), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("scroll", this.scroll), lc.on("scroll-reset", this.in), lc.on("scroll-top", this.in)
                    }
                }])
            }();

        function ef(t) {
            return ef = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ef(t)
        }

        function nf(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, sf(i.key), i)
            }
        }

        function rf(t, e, n) {
            return (e = sf(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function sf(t) {
            var e = function (t, e) {
                if ("object" != ef(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != ef(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == ef(e) ? e : e + ""
        }
        var of = cc, af = dc, lf = yc.bounds, uf = yc.flags, cf = function () {
            return function (t, e, n) {
                return e && nf(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t
            }((function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : of(".js-if-menu");
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), rf(this, "toggle", (function () {
                    e.active ? e.close() : e.open()
                })), rf(this, "scroll", (function (t) {
                    var n = t.dY;
                    e.target -= n
                })), rf(this, "tick", (function () {
                    e.current = kc()(e.current, e.target, .1);
                    var t = Ki.utils.wrap(0, e.max, e.current - e.offset);
                    e.ySet(-t)
                })), rf(this, "open", (function () {
                    e.current = e.target = 0, e.otl && e.otl.progress(0), e.resize(), requestAnimationFrame((function () {
                        uf.infinite = uf.locked = e.active = !0, e.tl.clear().set(e.el, {
                            autoAlpha: 1
                        }).to([e.el, e.content], {
                            yPercent: 0
                        }).fromTo(e, {
                            offset: lf.wh
                        }, {
                            offset: 0,
                            duration: 1.5,
                            ease: "expo"
                        }, 0).restart(), e.bindEvents(), lc.emit("lenis:stop")
                    }))
                })), rf(this, "close", (function () {
                    uf.infinite = uf.locked = e.active = e.hasOffset = !1, e.unbindEvents(), e.tl.clear().to([e.el, e.content], {
                        yPercent: Ki.utils.wrap([-100, 100])
                    }).set(e.el, {
                        autoAlpha: 0
                    }).restart(), lc.emit("lenis:start")
                })), rf(this, "resize", (function () {
                    e.max = af(e.item).height / 2, e.otl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            ease: "none"
                        }
                    }).to(e.itemParent, {
                        y: -af(e.itemParent).top
                    })
                })), this.el = n, this.content = of(".js-if-menu-content", this.el), this.btnOpen = of(".js-if-menu-open"), this.btnClose = of(".js-if-menu-close", this.el), this.item = of(".js-if-menu-item", this.el), this.itemParent = this.item.parentNode, this.active = !1, this.hasOffset = !1, this.target = 0, this.current = 0, this.progress = 0, this.max = 0, this.tl = Ki.timeline({
                    paused: !0,
                    defaults: {
                        duration: 1,
                        ease: "snappy"
                    }
                }).set([this.el, this.content], {
                    yPercent: Ki.utils.wrap([-100, 100])
                }).progress(1), this.ySet = Ki.quickSetter(this.item, "y", "px"), requestAnimationFrame((function () {
                    lc.on("click", e.btnOpen, e.open), lc.on("click", e.btnClose, e.close)
                }))
            }), [{
                key: "bindEvents",
                value: function () {
                    lc.on("scroller", this.scroll), lc.on("tick", this.tick), lc.on("resize", this.resize), lc.on("infinite-close", this.close)
                }
            }, {
                key: "unbindEvents",
                value: function () {
                    lc.off("scroller", this.scroll), lc.off("tick", this.tick), lc.off("resize", this.resize), lc.off("infinite-close", this.close)
                }
            }])
        }();

        function hf(t) {
            return hf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, hf(t)
        }

        function df(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, pf(i.key), i)
            }
        }

        function ff(t, e, n) {
            return (e = pf(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function pf(t) {
            var e = function (t, e) {
                if ("object" != hf(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != hf(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == hf(e) ? e : e + ""
        }
        var mf = cc,
            gf = hc,
            vf = dc,
            yf = yc.bounds,
            bf = yc.flags,
            _f = function () {
                return function (t, e, n) {
                    return e && df(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mf(".js-if-popup-ea");
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), ff(this, "open", (function () {
                        e.current = e.target = 0, e.resize(), bf.locked = e.active = !0, requestAnimationFrame((function () {
                            e.tl.clear().set(e.el, {
                                autoAlpha: 1
                            }).to([e.el, e.content], {
                                yPercent: 0
                            }).fromTo(e, {
                                offset: yf.wh
                            }, {
                                offset: 0,
                                duration: 1.5,
                                ease: "expo"
                            }, 0).restart(), e.bindEvents()
                        }))
                    })), ff(this, "close", (function () {
                        bf.locked = e.active = e.hasOffset = !1, e.tl.clear().to([e.el, e.content], {
                            yPercent: Ki.utils.wrap([-100, 100])
                        }).set(e.el, {
                            autoAlpha: 0
                        }).restart()
                    })), ff(this, "resize", (function () {
                        e.max = vf(e.item).height / 2
                    })), this.el = n, this.content = mf(".js-if-popup-ea-content", this.el), this.btnOpen = gf(".js-if-popup-ea-open"), this.btnClose = mf(".js-if-popup-ea-close", this.el), this.item = mf(".js-if-popup-ea-item", this.el), this.itemParent = this.item.parentNode, this.active = !1, this.hasOffset = !1, this.target = 0, this.current = 0, this.progress = 0, this.max = 0, this.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: 1,
                            ease: "snappy"
                        }
                    }).set([this.el, this.content], {
                        yPercent: Ki.utils.wrap([-100, 100])
                    }).progress(1), requestAnimationFrame((function () {
                        lc.on("click", e.btnOpen, e.open), lc.on("click", e.btnClose, e.close)
                    }))
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("resize", this.resize)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("resize", this.resize), lc.off("click", this.btnOpen, this.open), lc.off("click", this.btnClose, this.close)
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents(), this.tl && this.tl.kill()
                    }
                }])
            }();

        function xf(t) {
            return xf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, xf(t)
        }

        function wf(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Mf(i.key), i)
            }
        }

        function Mf(t) {
            var e = function (t, e) {
                if ("object" != xf(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != xf(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == xf(e) ? e : e + ""
        }
        var Sf = cc,
            Tf = hc,
            Ef = function () {
                return function (t, e, n) {
                    return e && wf(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t() {
                    var e = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                        function (t, e, n) {
                            (e = Mf(e)) in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n
                        }(this, "scrollTo", (function (t) {
                            return t.preventDefault(), t.stopPropagation(), t.stopImmediatePropagation(), window.location.hash = "", history.replaceState(null, null, " "), window.scrollTo(0, Sf(t.target.hash).offsetTop), !1
                        })), this.anchorLinks = Tf(".internal-anchor"), requestAnimationFrame((function () {
                            lc.on("click", e.anchorLinks, e.scrollTo)
                        }))
                }), [{
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.anchorLinks, this.scrollTo)
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function Df(t) {
            return Df = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Df(t)
        }

        function Cf(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Pf(i.key), i)
            }
        }

        function Af(t, e, n) {
            return (e = Pf(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Pf(t) {
            var e = function (t, e) {
                if ("object" != Df(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Df(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Df(e) ? e : e + ""
        }
        var Lf = cc,
            Rf = hc,
            kf = yc.dom,
            Of = (yc.flags, function () {
                return function (t, e, n) {
                    return e && Cf(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lf(".js-mdd");
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Af(this, "open", (function (t) {
                        var n = t.currentTarget;
                        e.dc && e.dc.kill();
                        var i = n.dataset.content,
                            r = Lf(".".concat(i));
                        n.classList.add("is-active"), kf.body.classList.add("is-dark"), e.active = !0, e.tl[i] && e.tl[i].clear().set(e.el, {
                            autoAlpha: 1
                        }).to([e.el, r], {
                            yPercent: 0
                        }).restart()
                    })), Af(this, "close", (function () {
                        e.active && (e.dc = Ki.delayedCall(.1, (function () {
                            for (var t in e.toggle.forEach((function (t) {
                                t.classList.remove("is-active")
                            })), kf.body.classList.remove("is-dark"), e.active = !1, e.tl)
                                if (Object.hasOwnProperty.call(e.tl, t)) {
                                    var n = Lf(".".concat(t));
                                    e.tl[t].clear().to([e.el, n], {
                                        yPercent: Ki.utils.wrap([-100, 100])
                                    }).set(e.el, {
                                        autoAlpha: 0
                                    }).restart()
                                }
                        })))
                    })), this.el = n, this.content = Rf(".js-mdd-content", this.el), this.toggle = Rf(".js-mdd-toggle"), this.tl = {}, this.content.forEach((function (t) {
                        e.tl[t.dataset.content] = Ki.timeline({
                            paused: !0,
                            defaults: {
                                duration: 1,
                                ease: "snappy"
                            }
                        }).set([e.el, t], {
                            yPercent: Ki.utils.wrap([-100, 100])
                        }).progress(1)
                    })), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        this._open = this.open.bind(this), this._close = this.close.bind(this), lc.on("mouseenter", this.toggle, this._open), lc.on("mouseleave", this.toggle, this._close), lc.on("mouseenter", this.el, this._open), lc.on("mouseleave", this.el, this._close), lc.on("transition-out", this._close)
                    }
                }])
            }());

        function If(t) {
            return If = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, If(t)
        }

        function Ff(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, zf(i.key), i)
            }
        }

        function Nf(t, e, n) {
            return (e = zf(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function zf(t) {
            var e = function (t, e) {
                if ("object" != If(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != If(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == If(e) ? e : e + ""
        }
        var Uf = cc,
            Bf = hc,
            jf = dc,
            Hf = yc.dom,
            Vf = function () {
                return function (t, e, n) {
                    return e && Ff(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Uf(".js-sliding-tabs");
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Nf(this, "resize", (function () {
                        var t = jf(e.$mask),
                            n = t.left,
                            i = t.right,
                            r = t.width;
                        e.max = r, e.cache = e.$items.map((function (t) {
                            var e = jf(t);
                            return {
                                left: e.left - n,
                                right: i - e.right,
                                item: t
                            }
                        })), e.setActive()
                    })), Nf(this, "enable", (function () {
                        Hf.switch.classList.contains("invisible") && e.setActive()
                    })), Nf(this, "animate", (function (t) {
                        var n = t.currentTarget,
                            i = e.cache.find((function (t) {
                                return t.item === n
                            })),
                            r = i.item,
                            s = i.left,
                            o = i.right;
                        e.state.idxLast = e.state.idxCurrent, e.state.idxCurrent = e.$items.indexOf(r);
                        var a = e.state.idxLast > e.state.idxCurrent ? [.75, 1] : [1, .75];
                        e.tl.clear().to(e.state, {
                            left: s,
                            duration: a[0]
                        }).to(e.state, {
                            right: o,
                            duration: a[1]
                        }, 0).restart()
                    })), this.el = n, this.$mask = Uf(".js-tabs-mask", this.el), this.$items = Bf(".js-item", this.el), this.state = {
                        left: 0,
                        right: 0,
                        idxLast: -1,
                        idxCurrent: 0
                    }, this.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: .75,
                            ease: "snappy"
                        },
                        onUpdate: function () {
                            return Ki.set(e.$mask, {
                                clipPath: "inset(0 ".concat(e.state.right, "px 0 ").concat(e.state.left, "px round 3.1rem)")
                            })
                        }
                    }), this.resize(), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("resize-reset", this.resize), lc.on("click", this.$items, this.animate), lc.on("switch-enable", this.enable)
                    }
                }, {
                    key: "setActive",
                    value: function () {
                        if (this.state.idxCurrent = this.$items.indexOf(this.$items.find((function (t) {
                            return t.href == window.location.href
                        }))), -1 != this.state.idxCurrent) {
                            var t = this.cache[this.state.idxCurrent];
                            if (t) {
                                Hf.switch.classList.remove("invisible");
                                var e = t.left,
                                    n = t.right;
                                this.tl.clear().to(this.state, {
                                    left: e,
                                    right: n,
                                    duration: .1
                                }).restart()
                            }
                        }
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        var t = this;
                        lc.off("resize-reset", this.resize), lc.off("click", this.$items, this.animate), this.cache.forEach((function (e) {
                            var n = e.item;
                            return lc.off("click", n, t.redirect)
                        }))
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function Gf(t) {
            return Gf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Gf(t)
        }

        function Wf(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Xf(i.key), i)
            }
        }

        function $f(t, e, n) {
            return (e = Xf(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Xf(t) {
            var e = function (t, e) {
                if ("object" != Gf(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Gf(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Gf(e) ? e : e + ""
        }
        var qf = cc,
            Yf = hc,
            Kf = dc,
            Jf = yc.bounds,
            Zf = (yc.flags, function () {
                return function (t, e, n) {
                    return e && Wf(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), $f(this, "down", (function (t) {
                        var e = t.x,
                            i = t.y,
                            r = t.target;
                        (r === n.el || n.el.contains(r)) && (n.dragging = !0, n.cancelX = e, n.cancelY = i, n.on = n.tx + e * n.speed)
                    })), $f(this, "move", (function (t) {
                        var e = t.x,
                            i = t.y,
                            r = t.e;
                        n.dragging && (Math.abs(e - n.cancelX) > Math.abs(i - n.cancelY) && r.cancelable && (r.preventDefault(), r.stopPropagation()), n.tx = n.on - e * n.speed)
                    })), $f(this, "up", (function () {
                        n.dragging && (n.dragging = !1)
                    })), $f(this, "tick", (function () {
                        n.active && (n.tx += 1, n.cx = kc()(n.cx, n.tx, n.ease), !n.resizing && n.transformSlides())
                    })), $f(this, "resize", (function () {
                        n.resizing = !0, n.setCache(), n.transformSlides(), n.resizing = !1
                    })), this.el = e, this.$container = qf(".js-slides", e), this.$slides = Yf(".js-slide", e), this.total = this.$slides.length - 1, this.tx = 0, this.cx = 0, this.max = 0, this.cancelX = 0, this.cancelY = 0, this.on = 0, this.ease = .1, this.speed = 2, this.dragging = !1, this.resizing = !1, this.active = !1, ia.create({
                        trigger: this.el,
                        onToggle: function (t) {
                            return n.active = t.isActive
                        }
                    }), requestAnimationFrame((function () {
                        n.mount()
                    }))
                }), [{
                    key: "setCache",
                    value: function () {
                        var t = this;
                        this.cache = this.$slides.map((function (e, n) {
                            e.style.transform = "translate3d(0, 0, 0)";
                            var i = Kf(e),
                                r = i.left,
                                s = i.right,
                                o = i.width,
                                a = r - Jf.ww,
                                l = s;
                            return n === t.total && (t.max = s), {
                                slide: e,
                                left: r,
                                right: s,
                                width: o,
                                start: a,
                                end: l,
                                out: !0
                            }
                        }))
                    }
                }, {
                    key: "visible",
                    value: function (t, e) {
                        var n = t.start,
                            i = t.end;
                        return e > n && e < i
                    }
                }, {
                    key: "transformSlides",
                    value: function () {
                        var t = this;
                        this.cache.forEach((function (e) {
                            var n = e.right,
                                i = e.slide,
                                r = (e.tl, Ki.utils.wrap(-(t.max - n), n, t.cx));
                            t.visible(e, r) || t.resizing ? (e.out && (e.out = !1), t.transform(i, -r)) : e.out || (e.out = !0, t.transform(i, -r))
                        }))
                    }
                }, {
                    key: "transform",
                    value: function (t, e) {
                        t.style.transform = "translate3d(".concat(e, "px, 0, 0)")
                    }
                }, {
                    key: "bindEvents",
                    value: function () {
                        lc.on("mousedown", this.down), lc.on("mouseup", this.up), lc.on("mousemove", this.move), lc.on("resize", this.resize), lc.on("tick", this.tick)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("mousedown", this.down), lc.off("mouseup", this.up), lc.off("mousemove", this.move), lc.off("resize", this.resize), lc.off("tick", this.tick)
                    }
                }, {
                    key: "mount",
                    value: function () {
                        this.resize(), this.bindEvents()
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }());

        function Qf(t) {
            return Qf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Qf(t)
        }

        function tp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, np(i.key), i)
            }
        }

        function ep(t, e, n) {
            return (e = np(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function np(t) {
            var e = function (t, e) {
                if ("object" != Qf(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Qf(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Qf(e) ? e : e + ""
        }
        var ip = cc,
            rp = hc,
            sp = dc,
            op = function () {
                return function (t, e, n) {
                    return e && tp(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), ep(this, "resize", (function () {
                        n.fromBounds = sp(n.el);
                        var t = sp(n.ref),
                            e = t.width / n.fromBounds.width,
                            i = -(n.fromBounds.left - t.left - (t.width - n.fromBounds.width) / 2);
                        n.tl && n.tl.kill(), n.tl = Ki.timeline({
                            defaults: {
                                ease: "none"
                            },
                            scrollTrigger: {
                                trigger: n.trigFirst,
                                start: "top bottom",
                                end: "center center",
                                scrub: !0
                            }
                        }).fromTo(n.el, {
                            scale: 1,
                            x: 0
                        }, {
                            scale: e,
                            x: i
                        }).to(n, {
                            m: .00175
                        }), n.stBall && n.stBall.kill(), n.stBall = ia.create({
                            trigger: n.trigFirst,
                            start: "top center",
                            end: "bottom center",
                            onToggle: function (t) {
                                t.isActive ? n.ball.classList.add("is-active") : n.ball.classList.remove("is-active")
                            }
                        }), n.cache = n.triggers.map((function (t, e) {
                            var i = n.balls[e],
                                r = ip(".js-orb-label", i),
                                s = sp(r),
                                o = sp(i).width / 2,
                                a = Ki.utils.mapRange(-o, o, -s.width, 0),
                                l = Ki.utils.mapRange(-o, o, -s.height, 0),
                                u = 90 * e;
                            return n.sts[e] && n.sts[e].kill(), n.sts[e] = ia.create({
                                trigger: t,
                                start: "top center",
                                end: "bottom center",
                                onToggle: function (t) {
                                    t.isActive ? i.classList.add("is-active") : i.classList.remove("is-active")
                                }
                            }), {
                                ball: i,
                                label: r,
                                xMap: a,
                                yMap: l,
                                angle: u,
                                radius: o
                            }
                        }))
                    })), ep(this, "tick", (function () {
                        var t = n.fromBounds.width / 2;
                        n.cache.forEach((function (e, i) {
                            e.angle = Ki.utils.wrap(0, 360, e.angle + n.m);
                            var r = Math.cos(e.angle) * t,
                                s = Math.sin(e.angle) * t,
                                o = Math.cos(e.angle) * e.radius,
                                a = Math.sin(e.angle) * e.radius;
                            e.ball.style.transform = "translate3d(".concat(r, "px, ").concat(s, "px, 0)"), e.label.style.transform = "translate3d(".concat(o + e.xMap(o), "px, ").concat(a + e.yMap(a), "px, 0)")
                        }))
                    })), this.el = e, this.trigFirst = ip(".js-orb-trig-first"), this.triggers = rp(".js-orb-trig"), this.ref = ip(".js-orb-ref"), this.balls = rp(".js-orb-ball"), this.ball = ip(".js-orb-ball-big"), this.angle = 90, this.x = 0, this.y = 0, this.m = .005, this.sts = [], requestAnimationFrame((function () {
                        n.mount()
                    }))
                }), [{
                    key: "mount",
                    value: function () {
                        this.resize(), this.bindEvents()
                    }
                }, {
                    key: "bindEvents",
                    value: function () {
                        lc.on("tick", this.tick)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("tick", this.tick)
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function ap(t) {
            return ap = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ap(t)
        }

        function lp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, up(i.key), i)
            }
        }

        function up(t) {
            var e = function (t, e) {
                if ("object" != ap(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != ap(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == ap(e) ? e : e + ""
        }
        var cp = cc,
            hp = dc,
            dp = yc.dom,
            fp = yc.device,
            pp = function () {
                return function (t, e, n) {
                    return e && lp(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                        function (t, e, n) {
                            (e = up(e)) in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n
                        }(this, "resize", (function () {
                            if (!fp.isSmall) {
                                n.initial = hp(n.el), n.state1.rect = hp(n.$state1), n.state2.rect = hp(n.$state2), n.end = hp(n.$end);
                                var t = n.initial,
                                    e = t.left,
                                    i = t.right,
                                    r = t.height,
                                    s = n.state1,
                                    o = s.rect,
                                    a = s.clip,
                                    l = n.state2,
                                    u = l.rect,
                                    c = l.clip;
                                a.left = o.left - e, a.right = i - o.right, a.bottom = r - o.height, a.top = 0;
                                var h = n.end.bottom - u.bottom;
                                c.left = u.left - e, c.right = i - u.right, c.bottom = h, c.top = r - u.height - h, n.tl && n.tl.kill(), n.tl = Ki.timeline({
                                    scrollTrigger: {
                                        trigger: dp.body,
                                        endTrigger: n.$end,
                                        start: "top top",
                                        end: "top top",
                                        scrub: !0
                                    },
                                    defaults: {
                                        ease: "none",
                                        duration: .5,
                                        force3D: !0
                                    }
                                }).fromTo(n.el, {
                                    clipPath: "inset(".concat(a.top, "px ").concat(a.right, "px ").concat(a.bottom, "px ").concat(a.left, "px)")
                                }, {
                                    clipPath: "inset(0px 0px 0px 0px)"
                                }, 0).to(n.el, {
                                    y: "6rem",
                                    duration: .25
                                }, 0).to(n.el, {
                                    y: 0,
                                    duration: .25
                                }, .25).to(n.$caption, {
                                    yPercent: -100,
                                    ease: "power1.inOut",
                                    duration: .25
                                }, .5).set(n.$caption, {
                                    alpha: 0
                                }, .75).to(n.el, {
                                    clipPath: "inset(".concat(c.top, "px ").concat(c.right, "px ").concat(c.bottom, "px ").concat(c.left, "px)")
                                }, .75).to(n.el, {
                                    y: "13.5rem"
                                }, .75)
                            }
                        })), this.$parent = e, this.el = cp(".js-hh"), this.$state1 = cp(".js-hh-state-1"), this.$state2 = cp(".js-hh-state-2"), this.$end = cp(".js-hh-end"), this.$caption = cp(".js-hh-caption"), this.$offset = cp(".js-hh-offset-ref"), this.state1 = {
                            rect: null,
                            clip: {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            }
                        }, this.state2 = {
                            rect: null,
                            clip: {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            }
                        }, this.resize(), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("resize-reset", this.resize)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("resize-reset", this.resize)
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents(), this.tl && this.tl.kill()
                    }
                }])
            }();

        function mp(t) {
            return mp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, mp(t)
        }

        function gp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, vp(i.key), i)
            }
        }

        function vp(t) {
            var e = function (t, e) {
                if ("object" != mp(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != mp(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == mp(e) ? e : e + ""
        }
        var yp = hc,
            bp = yc.device,
            _p = function () {
                return function (t, e, n) {
                    return e && gp(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t() {
                    var e = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                        function (t, e, n) {
                            (e = vp(e)) in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n
                        }(this, "resize", (function () {
                            bp.isSmall || (e.tl && e.tl.kill(), e.tl = Ki.timeline({
                                scrollTrigger: {
                                    trigger: e.footer,
                                    start: "top bottom",
                                    end: "bottom bottom",
                                    scrub: !0
                                },
                                defaults: {
                                    ease: "none",
                                    force3D: !0
                                }
                            }).fromTo(e.footerInner, {
                                yPercent: -35
                            }, {
                                yPercent: 0
                            }, 0))
                        })), this.footer = yp(".js-sf"), this.footerInner = yp(".js-sf-i"), this.resize(), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("resize-reset", this.resize)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("resize-reset", this.resize)
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents(), this.tl && this.tl.kill()
                    }
                }])
            }();

        function xp(t) {
            return xp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, xp(t)
        }

        function wp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Sp(i.key), i)
            }
        }

        function Mp(t, e, n) {
            return (e = Sp(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function Sp(t) {
            var e = function (t, e) {
                if ("object" != xp(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != xp(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == xp(e) ? e : e + ""
        }
        var Tp = cc,
            Ep = hc,
            Dp = yc.dom,
            Cp = yc.flags,
            Ap = function () {
                return function (t, e, n) {
                    return e && wp(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Tp(".js-mm");
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Mp(this, "toggle", (function () {
                        Cp.menu ? e.close() : e.open()
                    })), Mp(this, "instant", (function () {
                        e.tl.pause().progress(0), e.ddtl.clear().set(e.$dd, {
                            height: 0
                        }).set(e.$dditems, {
                            yPercent: 100
                        }).set(e.$ddicons, {
                            display: Ki.utils.wrap(["block", "none"])
                        }).restart(), e.$toggle.textContent = "Menu", Dp.body.classList.remove("overflow-hidden"), e.ddactive = !1, Cp.menu = !1
                    })), Mp(this, "close", (function () {
                        Cp.menu = !1, e.$toggle.textContent = "Menu", Dp.body.classList.remove("overflow-hidden"), e.tl.clear().to([e.el, e.$mask], {
                            yPercent: Ki.utils.wrap([-100, 100])
                        }), e.ddactive && (e.ddactive = !1, e.tl.to(e.$dd, {
                            height: 0,
                            duration: .5,
                            ease: "power2.inOut"
                        }, 0).to(e.$dditems, {
                            yPercent: 100,
                            duration: .5,
                            ease: "power2.inOut"
                        }, 0).set(e.$ddicons, {
                            display: Ki.utils.wrap(["block", "none"])
                        }, 0)), e.tl.set(e.el, {
                            autoAlpha: 0
                        }).restart()
                    })), Mp(this, "open", (function () {
                        Cp.menu = !0, e.$toggle.textContent = "Close", Dp.body.classList.add("overflow-hidden"), e.tl.clear().set(e.el, {
                            autoAlpha: 1
                        }).fromTo([e.el, e.$mask], {
                            yPercent: Ki.utils.wrap([-100, 100])
                        }, {
                            yPercent: 0
                        }).fromTo(e.$borders, {
                            scaleX: 0
                        }, {
                            scaleX: 1,
                            duration: 1.25,
                            stagger: .075,
                            ease: "expo"
                        }, .25).fromTo(e.$items, {
                            yPercent: 100
                        }, {
                            yPercent: 0,
                            duration: 1.25,
                            stagger: .075,
                            ease: "expo"
                        }, .25).restart()
                    })), Mp(this, "dd", (function () {
                        e.ddactive ? (e.ddactive = !1, e.ddtl.clear().set(e.$dd, {
                            height: 0
                        }).set(e.$ddicons, {
                            display: Ki.utils.wrap(["block", "none"])
                        }).set(e.$dditems, {
                            yPercent: 100
                        }).restart()) : (e.ddactive = !0, e.ddtl.clear().set(e.$dd, {
                            height: "auto"
                        }).set(e.$ddicons, {
                            display: Ki.utils.wrap(["none", "block"])
                        }).to(e.$dditems, {
                            yPercent: 0,
                            duration: 1.25,
                            stagger: .075,
                            ease: "expo"
                        }, 0).restart())
                    })), this.el = n, this.$mask = Tp(".js-mm-mask", this.el), this.$toggle = Tp(".js-mm-toggle"), this.$items = Ep(".js-mm-link", this.el), this.$borders = Ep(".js-mm-border", this.el), this.$ddtoggle = Tp(".js-mm-dd-toggle", this.el), this.$dd = Tp(".js-mm-dd", this.el), this.$dditems = Ep(".js-mm-link-sub", this.el), this.$ddicons = Ep(".js-mm-sub-icon", this.el), this.ddactive = !1, this.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: 1,
                            ease: "snappy"
                        }
                    }), this.ddtl = Ki.timeline().set(this.$dd, {
                        height: 0
                    }).set(this.$dditems, {
                        yPercent: 100
                    }), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("click", this.$toggle, this.toggle), lc.on("click", this.$ddtoggle, this.dd), lc.on("menu-close-instant", this.instant)
                    }
                }])
            }();

        function Pp(t) {
            return Pp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Pp(t)
        }

        function Lp(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, kp(i.key), i)
            }
        }

        function Rp(t, e, n) {
            return e && Lp(t.prototype, e), n && Lp(t, n), Object.defineProperty(t, "prototype", {
                writable: !1
            }), t
        }

        function kp(t) {
            var e = function (t, e) {
                if ("object" != Pp(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Pp(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Pp(e) ? e : e + ""
        }
        var Op = cc,
            Ip = hc,
            Fp = yc.dom,
            Np = Rp((function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = Ip(".js-t-title-line"),
                    i = Op(".js-t-lines");
                if (this.tl = Ki.timeline({
                    paused: !0,
                    defaults: {
                        duration: 1.5,
                        ease: "expo"
                    },
                    onComplete: function () {
                        e.tl.kill()
                    }
                }).to(Fp.mask, {
                    autoAlpha: 0,
                    duration: .5,
                    ease: "power1"
                }, .25), n.length && this.tl.from(n, {
                    yPercent: 100,
                    duration: 1.5,
                    stagger: .2,
                    ease: "expo"
                }, .75), i) {
                    var r = new (Zc())(i, {
                        type: "lines"
                    }),
                        s = new (Zc())(r.lines, {
                            type: "lines"
                        });
                    this.tl.set(r.lines, {
                        overflow: "hidden"
                    }, 0).from(s.lines, {
                        yPercent: 100,
                        duration: 1.25,
                        stagger: .1,
                        ease: "expo"
                    }, 1)
                }
            }));

        function zp(t) {
            return zp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, zp(t)
        }

        function Up(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, jp(i.key), i)
            }
        }

        function Bp(t, e, n) {
            return (e = jp(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function jp(t) {
            var e = function (t, e) {
                if ("object" != zp(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != zp(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == zp(e) ? e : e + ""
        }
        var Hp = cc,
            Vp = hc,
            Gp = (yc.dom, yc.flags, function () {
                return function (t, e, n) {
                    return e && Up(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Bp(this, "resize", (function () {
                        n.tl && n.tl.kill(), n.tl = Ki.timeline({
                            paused: !0,
                            defaults: {
                                ease: "none",
                                duration: .5
                            }
                        }), n.split && n.split.revert(), n.o && n.o.revert(), requestAnimationFrame((function () {
                            n.o = new (Zc())(n.$prox, {
                                type: "lines"
                            }), n.split = new (Zc())(n.o.lines, {
                                type: "lines"
                            }), n.tl.set(n.o.lines, {
                                overflow: "hidden"
                            }, 0).from(n.o.lines, {
                                xPercent: -100,
                                stagger: .5
                            }).from(n.split.lines, {
                                xPercent: 100,
                                stagger: .5
                            }, 0).progress(1).progress(0), n.ptl = Ki.timeline({
                                paused: !0
                            }).to(n.tl, {
                                progress: 1,
                                duration: 19,
                                ease: "none"
                            })
                        }))
                    })), Bp(this, "click", (function () {
                        n.tl.progress() >= .95 ? (n.active = !0, n.ptl.restart(), n.$audio.currentTime = 0, n.$audio.play(), n.$labels.forEach((function (t) {
                            return t.textContent = "Mute"
                        }))) : n.active ? (n.active = !1, n.ptl.pause(), n.$audio.pause(), n.$labels.forEach((function (t) {
                            return t.textContent = "Play"
                        }))) : (n.active = !0, n.ptl.play(), n.$audio.play(), n.$labels.forEach((function (t) {
                            return t.textContent = "Mute"
                        })))
                    })), this.el = e, this.$prox = Hp(".js-audio-prox", this.el), this.$audio = Hp(".js-audio", this.el), this.$labels = Vp(".js-audio-label", this.el), Ki.delayedCall(.25, (function () {
                        n.resize(), n.bindEvents()
                    }))
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("click", this.el, this.click), lc.on("resize-reset", this.resize)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.el, this.click), lc.off("resize-reset", this.resize)
                    }
                }, {
                    key: "umount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }());

        function Wp(t) {
            return Wp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, Wp(t)
        }

        function $p(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, qp(i.key), i)
            }
        }

        function Xp(t, e, n) {
            return (e = qp(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function qp(t) {
            var e = function (t, e) {
                if ("object" != Wp(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != Wp(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == Wp(e) ? e : e + ""
        }
        var Yp = cc,
            Kp = hc,
            Jp = fc,
            Zp = yc.bounds,
            Qp = (yc.flags, function () {
                return function (t, e, n) {
                    return e && $p(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Xp(this, "open", (function () {
                        n.tl.clear().to(n.$mask, {
                            autoAlpha: 1
                        }).restart(), n.add()
                    })), Xp(this, "close", (function () {
                        n.tl.clear().to(n.$mask, {
                            autoAlpha: 0
                        }).restart(), n.timeout && n.timeout.kill()
                    })), this.el = e, this.$toggle = Yp(".js-cta-toggle", this.el), this.$mask = Yp(".js-cta-mask", this.el.parentNode), this.$items = Kp(".js-cta-item", this.$mask), this.cache = this.$items.map((function (t) {
                        return {
                            loaded: !1,
                            item: t,
                            src: t.dataset.image,
                            tl: Ki.timeline({
                                paused: !0,
                                defaults: {
                                    duration: .5,
                                    ease: "power1"
                                }
                            })
                        }
                    })), this.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: .5,
                            ease: "power1"
                        }
                    }), this.current = 0, this.d = .65, this.z = this.$items.length, this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("mouseenter", this.$toggle, this.open), lc.on("mouseleave", this.$toggle, this.close)
                    }
                }, {
                    key: "add",
                    value: function () {
                        var t = this;
                        this.timeout && this.timeout.kill(), this.timeout = Ki.delayedCall(this.d, (function () {
                            t.current = Ki.utils.wrap(0, t.$items.length, t.current + 1);
                            var e = t.cache[t.current];
                            if (t.z++, e.tl.clear().set(e.item, {
                                alpha: 1,
                                zIndex: t.z
                            }).set(e.item, {
                                x: Jp(0, Zp.ww),
                                y: Jp(0, Zp.wh)
                            }).set(e.item, {
                                alpha: 0
                            }, 4 * t.d), e.loaded) e.tl.restart(), t.add();
                            else {
                                var n = new Image;
                                n.src = e.src, n.decode().then((function () {
                                    e.loaded = !0, e.item.appendChild(n), e.tl.restart(), t.add()
                                }))
                            }
                        }))
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        lc.off("mouseenter", this.$toggle, this.open), lc.off("mouseleave", this.$toggle, this.close)
                    }
                }])
            }());

        function tm(t) {
            return tm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, tm(t)
        }

        function em(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, im(i.key), i)
            }
        }

        function nm(t, e, n) {
            return (e = im(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function im(t) {
            var e = function (t, e) {
                if ("object" != tm(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != tm(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == tm(e) ? e : e + ""
        }
        var rm = cc,
            sm = dc,
            om = (yc.bounds, yc.flags, function () {
                return function (t, e, n) {
                    return e && em(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), nm(this, "move", (function (t) {
                        var e = t.x,
                            i = t.y;
                        if (n.active) {
                            var r = n.bounds,
                                s = r.left,
                                o = r.top,
                                a = n.boundsTarget,
                                l = a.width,
                                u = a.height;
                            n.tx = e - (s + l - l / 2), n.ty = i - (o + u - u / 2)
                        }
                    })), nm(this, "tick", (function (t) {
                        var e = t.y;
                        n.active && (n.scroll = e, n.cx = kc()(n.cx, n.tx, .15), n.cy = kc()(n.cy, n.ty + n.scroll, .15), n.$mouse.style.transform = "translate3d(".concat(n.cx, "px, ").concat(n.cy, "px, 0)"))
                    })), nm(this, "enter", (function () {
                        n.active = !0, requestAnimationFrame((function () {
                            n.cx = n.tx, n.cy = n.ty + n.scroll, n.mtl.clear().to(n.$mouse, {
                                alpha: 1,
                                scale: 1
                            }).restart()
                        })), n.shuffle()
                    })), nm(this, "leave", (function () {
                        n.timeout && n.timeout.kill(), n.cache && Ki.set(n.cache[n.current].item, {
                            alpha: 0
                        }), n.mtl.clear().to(n.$mouse, {
                            alpha: 0,
                            scale: 0,
                            onComplete: function () {
                                n.active = !1
                            }
                        }).restart()
                    })), nm(this, "resize", (function () {
                        n.bounds = sm(n.el), n.boundsTarget = sm(n.$mouse)
                    })), this.el = e, this.$container = rm("[data-srcs]", this.el), this.$mouse = rm("[data-mouse]", this.el);
                    var i = null !== this.$container && this.$container.dataset.srcs;
                    i && "[]" !== i ? (this.urls = JSON.parse(i), this.cache = this.urls.map((function (t) {
                        return {
                            loaded: !1,
                            src: t,
                            tl: Ki.timeline({
                                paused: !0
                            }),
                            item: null
                        }
                    }))) : this.noUrls = !0, this.mtl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: .5,
                            ease: "expo"
                        }
                    }), this.tx = 0, this.ty = 0, this.cx = 0, this.cy = 0, this.scroll = 0, this.current = 0, this.d = .3, this.resize(), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("mouseenter", this.el, this.enter), lc.on("mouseleave", this.el, this.leave), lc.on("tick", this.tick), lc.on("mousemove", this.move), lc.on("resize-reset", this.resize)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("mouseenter", this.el, this.enter), lc.off("mouseleave", this.el, this.leave), lc.off("tick", this.tick), lc.off("mousemove", this.move), lc.off("resize-reset", this.resize)
                    }
                }, {
                    key: "shuffle",
                    value: function () {
                        var t = this;
                        !this.noUrls && this.cache && this.active && (this.timeout && this.timeout.kill(), this.timeout = Ki.delayedCall(this.d, (function () {
                            t.last = t.current, t.current = Ki.utils.wrap(0, t.cache.length, t.current + 1);
                            var e = t.cache[t.last],
                                n = t.cache[t.current];
                            if (n.loaded) n.tl.clear().set([n.item, e.item], {
                                alpha: Ki.utils.wrap([1, 0])
                            }).restart(), t.shuffle();
                            else {
                                var i = new Image,
                                    r = n.src.srcset;
                                i.srcset = r, i.sizes = "(min-width: 768px) 50vw, 100vw", i.decode().then((function () {
                                    n.loaded = !0, n.item = i, t.$container.appendChild(i), n.tl.clear().set([n.item, e.item], {
                                        alpha: Ki.utils.wrap([1, 0])
                                    }).restart(), t.shuffle()
                                })).catch((function () {
                                    n.loaded = !0, n.item = i, t.$container.appendChild(i), n.tl.clear().set([n.item, e.item], {
                                        alpha: Ki.utils.wrap([1, 0])
                                    }).restart(), t.shuffle()
                                }))
                            }
                        })))
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents(), this.mtl.kill(), this.cache && this.cache.forEach((function (t) {
                            return t.tl.kill()
                        }))
                    }
                }])
            }());

        function am(t) {
            return am = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, am(t)
        }

        function lm(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, cm(i.key), i)
            }
        }

        function um(t, e, n) {
            return (e = cm(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function cm(t) {
            var e = function (t, e) {
                if ("object" != am(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != am(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == am(e) ? e : e + ""
        }
        var hm = cc,
            dm = hc,
            fm = function () {
                return function (t, e, n) {
                    return e && lm(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), um(this, "toggle", (function () {
                        n.active ? n.close() : n.open()
                    })), um(this, "open", (function () {
                        n.active || (n.active = !0, n.el.classList.add("is-active"), n.tl.clear().to(n.$content, {
                            height: "auto"
                        }).restart())
                    })), um(this, "up", (function (t) {
                        var e = t.target;
                        n.active && (e.closest(".js-fc") || n.close())
                    })), um(this, "close", (function () {
                        n.active && (n.active = !1, n.el.classList.remove("is-active"), n.tl.clear().to(n.$content, {
                            height: "8rem"
                        }).restart())
                    })), um(this, "click", (function (t) {
                        var e = t.currentTarget;
                        n.currentCat = e.dataset.cat, n.$current.innerHTML = e.innerHTML, n.$btns.forEach((function (t) {
                            t === e ? t.classList.add("is-active") : t.classList.remove("is-active")
                        })), n.close(), n.filter()
                    })), um(this, "reset", (function () {
                        var t = n.el.querySelector("button.js-fc-button.all-items-reset");
                        n.currentCat = -1, n.$current.innerHTML = t.innerHTML, n.$btns.forEach((function (e) {
                            e === t ? e.classList.add("is-active") : e.classList.remove("is-active")
                        }))
                    })), this.el = e, this.el.instance = this, this.$content = hm(".js-fc-content", this.el), this.$current = hm(".js-fc-active", this.el), this.$btns = dm(".js-fc-button", this.el), this.$toggle = hm(".js-fc-toggle", this.el), this.$items = dm("[data-categories]"), this.tl = Ki.timeline({
                        paused: !0,
                        defaults: {
                            duration: .5,
                            ease: "snappy"
                        }
                    }), this.cache = this.$items.map((function (t) {
                        return {
                            item: t,
                            cats: t.dataset.categories
                        }
                    })), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("click", this.$toggle, this.toggle), lc.on("mouseup", this.up), lc.on("click", this.$btns, this.click)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("click", this.$toggle, this.toggle), lc.off("mouseup", this.up), lc.off("click", this.$btns, this.click)
                    }
                }, {
                    key: "filter",
                    value: function () {
                        var t = this;
                        this.cache.forEach((function (e) {
                            -1 !== e.cats.indexOf(t.currentCat) ? e.item.classList.remove("hidden") : e.item.classList.add("hidden")
                        }))
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();
        const pm = "146",
            mm = 0,
            gm = 1,
            vm = 2,
            ym = 1,
            bm = 2,
            _m = 3,
            xm = 0,
            wm = 1,
            Mm = 2,
            Sm = 0,
            Tm = 1,
            Em = 2,
            Dm = 3,
            Cm = 4,
            Am = 5,
            Pm = 100,
            Lm = 101,
            Rm = 102,
            km = 103,
            Om = 104,
            Im = 200,
            Fm = 201,
            Nm = 202,
            zm = 203,
            Um = 204,
            Bm = 205,
            jm = 206,
            Hm = 207,
            Vm = 208,
            Gm = 209,
            Wm = 210,
            $m = 0,
            Xm = 1,
            qm = 2,
            Ym = 3,
            Km = 4,
            Jm = 5,
            Zm = 6,
            Qm = 7,
            tg = 0,
            eg = 1,
            ng = 2,
            ig = 0,
            rg = 1,
            sg = 2,
            og = 3,
            ag = 4,
            lg = 5,
            ug = 301,
            cg = 302,
            hg = 303,
            dg = 304,
            fg = 306,
            pg = 1e3,
            mg = 1001,
            gg = 1002,
            vg = 1003,
            yg = 1004,
            bg = 1005,
            _g = 1006,
            xg = 1007,
            wg = 1008,
            Mg = 1009,
            Sg = 1010,
            Tg = 1011,
            Eg = 1012,
            Dg = 1013,
            Cg = 1014,
            Ag = 1015,
            Pg = 1016,
            Lg = 1017,
            Rg = 1018,
            kg = 1020,
            Og = 1021,
            Ig = 1022,
            Fg = 1023,
            Ng = 1024,
            zg = 1025,
            Ug = 1026,
            Bg = 1027,
            jg = 1028,
            Hg = 1029,
            Vg = 1030,
            Gg = 1031,
            Wg = 1033,
            $g = 33776,
            Xg = 33777,
            qg = 33778,
            Yg = 33779,
            Kg = 35840,
            Jg = 35841,
            Zg = 35842,
            Qg = 35843,
            tv = 36196,
            ev = 37492,
            nv = 37496,
            iv = 37808,
            rv = 37809,
            sv = 37810,
            ov = 37811,
            av = 37812,
            lv = 37813,
            uv = 37814,
            cv = 37815,
            hv = 37816,
            dv = 37817,
            fv = 37818,
            pv = 37819,
            mv = 37820,
            gv = 37821,
            vv = 36492,
            yv = 2300,
            bv = 2301,
            _v = 2302,
            xv = 3e3,
            wv = 3001,
            Mv = 3201,
            Sv = 0,
            Tv = 1,
            Ev = "srgb",
            Dv = "srgb-linear",
            Cv = 7680,
            Av = 35044,
            Pv = "300 es",
            Lv = 1035;
        class Rv {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const kv = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let Ov = 1234567;
        const Iv = Math.PI / 180,
            Fv = 180 / Math.PI;

        function Nv() {
            const t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (kv[255 & t] + kv[t >> 8 & 255] + kv[t >> 16 & 255] + kv[t >> 24 & 255] + "-" + kv[255 & e] + kv[e >> 8 & 255] + "-" + kv[e >> 16 & 15 | 64] + kv[e >> 24 & 255] + "-" + kv[63 & n | 128] + kv[n >> 8 & 255] + "-" + kv[n >> 16 & 255] + kv[n >> 24 & 255] + kv[255 & i] + kv[i >> 8 & 255] + kv[i >> 16 & 255] + kv[i >> 24 & 255]).toLowerCase()
        }

        function zv(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function Uv(t, e) {
            return (t % e + e) % e
        }

        function Bv(t, e, n) {
            return (1 - n) * t + n * e
        }

        function jv(t) {
            return !(t & t - 1) && 0 !== t
        }

        function Hv(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }

        function Vv(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }

        function Gv(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint16Array:
                    return t / 65535;
                case Uint8Array:
                    return t / 255;
                case Int16Array:
                    return Math.max(t / 32767, -1);
                case Int8Array:
                    return Math.max(t / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        function Wv(t, e) {
            switch (e.constructor) {
                case Float32Array:
                    return t;
                case Uint16Array:
                    return Math.round(65535 * t);
                case Uint8Array:
                    return Math.round(255 * t);
                case Int16Array:
                    return Math.round(32767 * t);
                case Int8Array:
                    return Math.round(127 * t);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        var $v = Object.freeze({
            __proto__: null,
            DEG2RAD: Iv,
            RAD2DEG: Fv,
            generateUUID: Nv,
            clamp: zv,
            euclideanModulo: Uv,
            mapLinear: function (t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            inverseLerp: function (t, e, n) {
                return t !== e ? (n - t) / (e - t) : 0
            },
            lerp: Bv,
            damp: function (t, e, n, i) {
                return Bv(t, e, 1 - Math.exp(-n * i))
            },
            pingpong: function (t, e = 1) {
                return e - Math.abs(Uv(t, 2 * e) - e)
            },
            smoothstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function (t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function (t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function (t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function (t) {
                void 0 !== t && (Ov = t);
                let e = Ov += 1831565813;
                return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
            },
            degToRad: function (t) {
                return t * Iv
            },
            radToDeg: function (t) {
                return t * Fv
            },
            isPowerOfTwo: jv,
            ceilPowerOfTwo: Hv,
            floorPowerOfTwo: Vv,
            setQuaternionFromProperEuler: function (t, e, n, i, r) {
                const s = Math.cos,
                    o = Math.sin,
                    a = s(n / 2),
                    l = o(n / 2),
                    u = s((e + i) / 2),
                    c = o((e + i) / 2),
                    h = s((e - i) / 2),
                    d = o((e - i) / 2),
                    f = s((i - e) / 2),
                    p = o((i - e) / 2);
                switch (r) {
                    case "XYX":
                        t.set(a * c, l * h, l * d, a * u);
                        break;
                    case "YZY":
                        t.set(l * d, a * c, l * h, a * u);
                        break;
                    case "ZXZ":
                        t.set(l * h, l * d, a * c, a * u);
                        break;
                    case "XZX":
                        t.set(a * c, l * p, l * f, a * u);
                        break;
                    case "YXY":
                        t.set(l * f, a * c, l * p, a * u);
                        break;
                    case "ZYZ":
                        t.set(l * p, l * f, a * c, a * u);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: Wv,
            denormalize: Gv
        });
        class Xv {
            constructor(t = 0, e = 0) {
                Xv.prototype.isVector2 = !0, this.x = t, this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this
            }
            rotateAround(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = this.x - t.x,
                    s = this.y - t.y;
                return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            } *[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        class qv {
            constructor() {
                qv.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
            }
            set(t, e, n, i, r, s, o, a, l) {
                const u = this.elements;
                return u[0] = t, u[1] = i, u[2] = o, u[3] = e, u[4] = r, u[5] = a, u[6] = n, u[7] = s, u[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[3],
                    a = n[6],
                    l = n[1],
                    u = n[4],
                    c = n[7],
                    h = n[2],
                    d = n[5],
                    f = n[8],
                    p = i[0],
                    m = i[3],
                    g = i[6],
                    v = i[1],
                    y = i[4],
                    b = i[7],
                    _ = i[2],
                    x = i[5],
                    w = i[8];
                return r[0] = s * p + o * v + a * _, r[3] = s * m + o * y + a * x, r[6] = s * g + o * b + a * w, r[1] = l * p + u * v + c * _, r[4] = l * m + u * y + c * x, r[7] = l * g + u * b + c * w, r[2] = h * p + d * v + f * _, r[5] = h * m + d * y + f * x, r[8] = h * g + d * b + f * w, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    l = t[7],
                    u = t[8];
                return e * s * u - e * o * l - n * r * u + n * o * a + i * r * l - i * s * a
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    l = t[7],
                    u = t[8],
                    c = u * s - o * l,
                    h = o * a - u * r,
                    d = l * r - s * a,
                    f = e * c + n * h + i * d;
                if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const p = 1 / f;
                return t[0] = c * p, t[1] = (i * l - u * n) * p, t[2] = (o * n - i * s) * p, t[3] = h * p, t[4] = (u * e - i * a) * p, t[5] = (i * r - o * e) * p, t[6] = d * p, t[7] = (n * a - l * e) * p, t[8] = (s * e - n * r) * p, this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }
            setUvTransform(t, e, n, i, r, s, o) {
                const a = Math.cos(r),
                    l = Math.sin(r);
                return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1), this
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
            }
            rotate(t) {
                const e = Math.cos(t),
                    n = Math.sin(t),
                    i = this.elements,
                    r = i[0],
                    s = i[3],
                    o = i[6],
                    a = i[1],
                    l = i[4],
                    u = i[7];
                return i[0] = e * r + n * a, i[3] = e * s + n * l, i[6] = e * o + n * u, i[1] = -n * r + e * a, i[4] = -n * s + e * l, i[7] = -n * o + e * u, this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }

        function Yv(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] >= 65535) return !0;
            return !1
        }

        function Kv(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }

        function Jv(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function Zv(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
        const Qv = {
            [Ev]: {
                [Dv]: Jv
            },
            [Dv]: {
                [Ev]: Zv
            }
        },
            ty = {
                legacyMode: !0,
                get workingColorSpace() {
                    return Dv
                },
                set workingColorSpace(t) {
                    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                },
                convert: function (t, e, n) {
                    if (this.legacyMode || e === n || !e || !n) return t;
                    if (Qv[e] && void 0 !== Qv[e][n]) {
                        const i = Qv[e][n];
                        return t.r = i(t.r), t.g = i(t.g), t.b = i(t.b), t
                    }
                    throw new Error("Unsupported color space conversion.")
                },
                fromWorkingColorSpace: function (t, e) {
                    return this.convert(t, this.workingColorSpace, e)
                },
                toWorkingColorSpace: function (t, e) {
                    return this.convert(t, e, this.workingColorSpace)
                }
            },
            ey = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            ny = {
                r: 0,
                g: 0,
                b: 0
            },
            iy = {
                h: 0,
                s: 0,
                l: 0
            },
            ry = {
                h: 0,
                s: 0,
                l: 0
            };

        function sy(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }

        function oy(t, e) {
            return e.r = t.r, e.g = t.g, e.b = t.b, e
        }
        class ay {
            constructor(t, e, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }
            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }
            setHex(t, e = Ev) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, ty.toWorkingColorSpace(this, e), this
            }
            setRGB(t, e, n, i = Dv) {
                return this.r = t, this.g = e, this.b = n, ty.toWorkingColorSpace(this, i), this
            }
            setHSL(t, e, n, i = Dv) {
                if (t = Uv(t, 1), e = zv(e, 0, 1), n = zv(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                        r = 2 * n - i;
                    this.r = sy(r, i, t + 1 / 3), this.g = sy(r, i, t), this.b = sy(r, i, t - 1 / 3)
                }
                return ty.toWorkingColorSpace(this, i), this
            }
            setStyle(t, e = Ev) {
                function n(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let i;
                if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const r = i[1],
                        s = i[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, ty.toWorkingColorSpace(this, e), n(t[4]), this;
                            if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, ty.toWorkingColorSpace(this, e), n(t[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                const i = parseFloat(t[1]) / 360,
                                    r = parseFloat(t[2]) / 100,
                                    s = parseFloat(t[3]) / 100;
                                return n(t[4]), this.setHSL(i, r, s, e)
                            }
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = i[1],
                        n = t.length;
                    if (3 === n) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, ty.toWorkingColorSpace(this, e), this;
                    if (6 === n) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, ty.toWorkingColorSpace(this, e), this
                }
                return t && t.length > 0 ? this.setColorName(t, e) : this
            }
            setColorName(t, e = Ev) {
                const n = ey[t.toLowerCase()];
                return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }
            copySRGBToLinear(t) {
                return this.r = Jv(t.r), this.g = Jv(t.g), this.b = Jv(t.b), this
            }
            copyLinearToSRGB(t) {
                return this.r = Zv(t.r), this.g = Zv(t.g), this.b = Zv(t.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex(t = Ev) {
                return ty.fromWorkingColorSpace(oy(this, ny), t), zv(255 * ny.r, 0, 255) << 16 ^ zv(255 * ny.g, 0, 255) << 8 ^ zv(255 * ny.b, 0, 255)
            }
            getHexString(t = Ev) {
                return ("000000" + this.getHex(t).toString(16)).slice(-6)
            }
            getHSL(t, e = Dv) {
                ty.fromWorkingColorSpace(oy(this, ny), e);
                const n = ny.r,
                    i = ny.g,
                    r = ny.b,
                    s = Math.max(n, i, r),
                    o = Math.min(n, i, r);
                let a, l;
                const u = (o + s) / 2;
                if (o === s) a = 0, l = 0;
                else {
                    const t = s - o;
                    switch (l = u <= .5 ? t / (s + o) : t / (2 - s - o), s) {
                        case n:
                            a = (i - r) / t + (i < r ? 6 : 0);
                            break;
                        case i:
                            a = (r - n) / t + 2;
                            break;
                        case r:
                            a = (n - i) / t + 4
                    }
                    a /= 6
                }
                return t.h = a, t.s = l, t.l = u, t
            }
            getRGB(t, e = Dv) {
                return ty.fromWorkingColorSpace(oy(this, ny), e), t.r = ny.r, t.g = ny.g, t.b = ny.b, t
            }
            getStyle(t = Ev) {
                return ty.fromWorkingColorSpace(oy(this, ny), t), t !== Ev ? `color(${t} ${ny.r} ${ny.g} ${ny.b})` : `rgb(${255 * ny.r | 0},${255 * ny.g | 0},${255 * ny.b | 0})`
            }
            offsetHSL(t, e, n) {
                return this.getHSL(iy), iy.h += t, iy.s += e, iy.l += n, this.setHSL(iy.h, iy.s, iy.l), this
            }
            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }
            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }
            addScalar(t) {
                return this.r += t, this.g += t, this.b += t, this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }
            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }
            multiplyScalar(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
            }
            lerpHSL(t, e) {
                this.getHSL(iy), t.getHSL(ry);
                const n = Bv(iy.h, ry.h, e),
                    i = Bv(iy.s, ry.s, e),
                    r = Bv(iy.l, ry.l, e);
                return this.setHSL(n, i, r), this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
            }
            toJSON() {
                return this.getHex()
            } *[Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }
        let ly;
        ay.NAMES = ey;
        class uy {
            static getDataURL(t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                let e;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    void 0 === ly && (ly = Kv("canvas")), ly.width = t.width, ly.height = t.height;
                    const n = ly.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = ly
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = Kv("canvas");
                    e.width = t.width, e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const i = n.getImageData(0, 0, t.width, t.height),
                        r = i.data;
                    for (let t = 0; t < r.length; t++) r[t] = 255 * Jv(r[t] / 255);
                    return n.putImageData(i, 0, 0), e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Jv(e[t] / 255)) : e[t] = Jv(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
            }
        }
        class cy {
            constructor(t = null) {
                this.isSource = !0, this.uuid = Nv(), this.data = t, this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                const n = {
                    uuid: this.uuid,
                    url: ""
                },
                    i = this.data;
                if (null !== i) {
                    let t;
                    if (Array.isArray(i)) {
                        t = [];
                        for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(hy(i[e].image)) : t.push(hy(i[e]))
                    } else t = hy(i);
                    n.url = t
                }
                return e || (t.images[this.uuid] = n), n
            }
        }

        function hy(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? uy.getDataURL(t) : t.data ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        let dy = 0;
        class fy extends Rv {
            constructor(t = fy.DEFAULT_IMAGE, e = fy.DEFAULT_MAPPING, n = mg, i = mg, r = _g, s = wg, o = Fg, a = Mg, l = 1, u = xv) {
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                    value: dy++
                }), this.uuid = Nv(), this.name = "", this.source = new cy(t), this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new Xv(0, 0), this.repeat = new Xv(1, 1), this.center = new Xv(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new qv, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(t) {
                this.source.data = t
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(t).uuid,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case pg:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case mg:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case gg:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case pg:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case mg:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case gg:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
            set needsUpdate(t) {
                !0 === t && (this.version++, this.source.needsUpdate = !0)
            }
        }
        fy.DEFAULT_IMAGE = null, fy.DEFAULT_MAPPING = 300;
        class py {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                py.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t, this.y = e, this.z = n, this.w = i, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setW(t) {
                return this.w = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    s = t.elements;
                return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const s = .01,
                    o = .1,
                    a = t.elements,
                    l = a[0],
                    u = a[4],
                    c = a[8],
                    h = a[1],
                    d = a[5],
                    f = a[9],
                    p = a[2],
                    m = a[6],
                    g = a[10];
                if (Math.abs(u - h) < s && Math.abs(c - p) < s && Math.abs(f - m) < s) {
                    if (Math.abs(u + h) < o && Math.abs(c + p) < o && Math.abs(f + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (l + 1) / 2,
                        a = (d + 1) / 2,
                        v = (g + 1) / 2,
                        y = (u + h) / 4,
                        b = (c + p) / 4,
                        _ = (f + m) / 4;
                    return t > a && t > v ? t < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = y / n, r = b / n) : a > v ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = y / i, r = _ / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = b / r, i = _ / r), this.set(n, i, r, e), this
                }
                let v = Math.sqrt((m - f) * (m - f) + (c - p) * (c - p) + (h - u) * (h - u));
                return Math.abs(v) < .001 && (v = 1), this.x = (m - f) / v, this.y = (c - p) / v, this.z = (h - u) / v, this.w = Math.acos((l + d + g - 1) / 2), this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            } *[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        class my extends Rv {
            constructor(t = 1, e = 1, n = {}) {
                super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new py(0, 0, t, e), this.scissorTest = !1, this.viewport = new py(0, 0, t, e);
                const i = {
                    width: t,
                    height: e,
                    depth: 1
                };
                this.texture = new fy(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : _g, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0
            }
            setSize(t, e, n = 1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
                const e = Object.assign({}, t.texture.image);
                return this.texture.source = new cy(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class gy extends fy {
            constructor(t = null, e = 1, n = 1, i = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = vg, this.minFilter = vg, this.wrapR = mg, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class vy extends fy {
            constructor(t = null, e = 1, n = 1, i = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = vg, this.minFilter = vg, this.wrapR = mg, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class yy {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i
            }
            static slerpFlat(t, e, n, i, r, s, o) {
                let a = n[i + 0],
                    l = n[i + 1],
                    u = n[i + 2],
                    c = n[i + 3];
                const h = r[s + 0],
                    d = r[s + 1],
                    f = r[s + 2],
                    p = r[s + 3];
                if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = u, void (t[e + 3] = c);
                if (1 === o) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = f, void (t[e + 3] = p);
                if (c !== p || a !== h || l !== d || u !== f) {
                    let t = 1 - o;
                    const e = a * h + l * d + u * f + c * p,
                        n = e >= 0 ? 1 : -1,
                        i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i),
                            s = Math.atan2(r, e * n);
                        t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                    }
                    const r = o * n;
                    if (a = a * t + h * r, l = l * t + d * r, u = u * t + f * r, c = c * t + p * r, t === 1 - o) {
                        const t = 1 / Math.sqrt(a * a + l * l + u * u + c * c);
                        a *= t, l *= t, u *= t, c *= t
                    }
                }
                t[e] = a, t[e + 1] = l, t[e + 2] = u, t[e + 3] = c
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                const o = n[i],
                    a = n[i + 1],
                    l = n[i + 2],
                    u = n[i + 3],
                    c = r[s],
                    h = r[s + 1],
                    d = r[s + 2],
                    f = r[s + 3];
                return t[e] = o * f + u * c + a * d - l * h, t[e + 1] = a * f + u * h + l * c - o * d, t[e + 2] = l * f + u * d + o * h - a * c, t[e + 3] = u * f - o * c - a * h - l * d, t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t, this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }
            setFromEuler(t, e) {
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    s = t._order,
                    o = Math.cos,
                    a = Math.sin,
                    l = o(n / 2),
                    u = o(i / 2),
                    c = o(r / 2),
                    h = a(n / 2),
                    d = a(i / 2),
                    f = a(r / 2);
                switch (s) {
                    case "XYZ":
                        this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                        break;
                    case "YXZ":
                        this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                        break;
                    case "ZXY":
                        this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                        break;
                    case "ZYX":
                        this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                        break;
                    case "YZX":
                        this._x = h * u * c + l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c - h * d * f;
                        break;
                    case "XZY":
                        this._x = h * u * c - l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c + h * d * f;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !1 !== e && this._onChangeCallback(), this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2,
                    i = Math.sin(n);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(t) {
                const e = t.elements,
                    n = e[0],
                    i = e[4],
                    r = e[8],
                    s = e[1],
                    o = e[5],
                    a = e[9],
                    l = e[2],
                    u = e[6],
                    c = e[10],
                    h = n + o + c;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t, this._x = (u - a) * t, this._y = (r - l) * t, this._z = (s - i) * t
                } else if (n > o && n > c) {
                    const t = 2 * Math.sqrt(1 + n - o - c);
                    this._w = (u - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
                } else if (o > c) {
                    const t = 2 * Math.sqrt(1 + o - n - c);
                    this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + u) / t
                } else {
                    const t = 2 * Math.sqrt(1 + c - n - o);
                    this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + u) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(zv(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n) return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }
            multiply(t) {
                return this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x,
                    i = t._y,
                    r = t._z,
                    s = t._w,
                    o = e._x,
                    a = e._y,
                    l = e._z,
                    u = e._w;
                return this._x = n * u + s * o + i * l - r * a, this._y = i * u + s * a + r * o - n * l, this._z = r * u + s * l + n * a - i * o, this._w = s * u - n * o - i * a - r * l, this._onChangeCallback(), this
            }
            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x,
                    i = this._y,
                    r = this._z,
                    s = this._w;
                let o = s * t._w + n * t._x + i * t._y + r * t._z;
                if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                const a = 1 - o * o;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const l = Math.sqrt(a),
                    u = Math.atan2(l, o),
                    c = Math.sin((1 - e) * u) / l,
                    h = Math.sin(e * u) / l;
                return this._w = s * c + this._w * h, this._x = n * c + this._x * h, this._y = i * c + this._y * h, this._z = r * c + this._z * h, this._onChangeCallback(), this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = Math.random(),
                    e = Math.sqrt(1 - t),
                    n = Math.sqrt(t),
                    i = 2 * Math.PI * Math.random(),
                    r = 2 * Math.PI * Math.random();
                return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() { } *[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }
        class by {
            constructor(t = 0, e = 0, n = 0) {
                by.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }
            add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this
            }
            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }
            sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
            }
            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }
            applyEuler(t) {
                return this.applyQuaternion(xy.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(xy.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements,
                    s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
            }
            applyQuaternion(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.x,
                    s = t.y,
                    o = t.z,
                    a = t.w,
                    l = a * e + s * i - o * n,
                    u = a * n + o * e - r * i,
                    c = a * i + r * n - s * e,
                    h = -r * e - s * n - o * i;
                return this.x = l * a + h * -r + u * -o - c * -s, this.y = u * a + h * -s + c * -r - l * -o, this.z = c * a + h * -o + l * -s - u * -r, this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x,
                    n = this.y,
                    i = this.z,
                    r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }
            cross(t) {
                return this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x,
                    i = t.y,
                    r = t.z,
                    s = e.x,
                    o = e.y,
                    a = e.z;
                return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return _y.copy(this).projectOnVector(t), this.sub(_y)
            }
            reflect(t) {
                return this.sub(_y.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(zv(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y,
                    i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = i, this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            setFromEuler(t) {
                return this.x = t._x, this.y = t._y, this.z = t._z, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const t = 2 * (Math.random() - .5),
                    e = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - t ** 2);
                return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
            } *[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        const _y = new by,
            xy = new yy;
        class wy {
            constructor(t = new by(1 / 0, 1 / 0, 1 / 0), e = new by(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromArray(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    o = -1 / 0;
                for (let a = 0, l = t.length; a < l; a += 3) {
                    const l = t[a],
                        u = t[a + 1],
                        c = t[a + 2];
                    l < e && (e = l), u < n && (n = u), c < i && (i = c), l > r && (r = l), u > s && (s = u), c > o && (o = c)
                }
                return this.min.set(e, n, i), this.max.set(r, s, o), this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    i = 1 / 0,
                    r = -1 / 0,
                    s = -1 / 0,
                    o = -1 / 0;
                for (let a = 0, l = t.count; a < l; a++) {
                    const l = t.getX(a),
                        u = t.getY(a),
                        c = t.getZ(a);
                    l < e && (e = l), u < n && (n = u), c < i && (i = c), l > r && (r = l), u > s && (s = u), c > o && (o = c)
                }
                return this.min.set(e, n, i), this.max.set(r, s, o), this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = Sy.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            setFromObject(t, e = !1) {
                return this.makeEmpty(), this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            expandByObject(t, e = !1) {
                t.updateWorldMatrix(!1, !1);
                const n = t.geometry;
                if (void 0 !== n)
                    if (e && null != n.attributes && void 0 !== n.attributes.position) {
                        const e = n.attributes.position;
                        for (let n = 0, i = e.count; n < i; n++) Sy.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(Sy)
                    } else null === n.boundingBox && n.computeBoundingBox(), Ty.copy(n.boundingBox), Ty.applyMatrix4(t.matrixWorld), this.union(Ty);
                const i = t.children;
                for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, Sy), Sy.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(Ry), ky.subVectors(this.max, Ry), Ey.subVectors(t.a, Ry), Dy.subVectors(t.b, Ry), Cy.subVectors(t.c, Ry), Ay.subVectors(Dy, Ey), Py.subVectors(Cy, Dy), Ly.subVectors(Ey, Cy);
                let e = [0, -Ay.z, Ay.y, 0, -Py.z, Py.y, 0, -Ly.z, Ly.y, Ay.z, 0, -Ay.x, Py.z, 0, -Py.x, Ly.z, 0, -Ly.x, -Ay.y, Ay.x, 0, -Py.y, Py.x, 0, -Ly.y, Ly.x, 0];
                return !!Fy(e, Ey, Dy, Cy, ky) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Fy(e, Ey, Dy, Cy, ky) && (Oy.crossVectors(Ay, Py), e = [Oy.x, Oy.y, Oy.z], Fy(e, Ey, Dy, Cy, ky)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return Sy.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return this.getCenter(t.center), t.radius = .5 * this.getSize(Sy).length(), t
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (My[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), My[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), My[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), My[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), My[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), My[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), My[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), My[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(My)), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        const My = [new by, new by, new by, new by, new by, new by, new by, new by],
            Sy = new by,
            Ty = new wy,
            Ey = new by,
            Dy = new by,
            Cy = new by,
            Ay = new by,
            Py = new by,
            Ly = new by,
            Ry = new by,
            ky = new by,
            Oy = new by,
            Iy = new by;

        function Fy(t, e, n, i, r) {
            for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                Iy.fromArray(t, s);
                const o = r.x * Math.abs(Iy.x) + r.y * Math.abs(Iy.y) + r.z * Math.abs(Iy.z),
                    a = e.dot(Iy),
                    l = n.dot(Iy),
                    u = i.dot(Iy);
                if (Math.max(-Math.max(a, l, u), Math.min(a, l, u)) > o) return !1
            }
            return !0
        }
        const Ny = new wy,
            zy = new by,
            Uy = new by;
        class By {
            constructor(t = new by, e = -1) {
                this.center = t, this.radius = e
            }
            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : Ny.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i), this
            }
            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }
            translate(t) {
                return this.center.add(t), this
            }
            expandByPoint(t) {
                if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                zy.subVectors(t, this.center);
                const e = zy.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e),
                        n = .5 * (t - this.radius);
                    this.center.addScaledVector(zy, n / t), this.radius += n
                }
                return this
            }
            union(t) {
                return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (Uy.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(zy.copy(t.center).add(Uy)), this.expandByPoint(zy.copy(t.center).sub(Uy))), this)
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const jy = new by,
            Hy = new by,
            Vy = new by,
            Gy = new by,
            Wy = new by,
            $y = new by,
            Xy = new by;
        class qy {
            constructor(t = new by, e = new by(0, 0, -1)) {
                this.origin = t, this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }
            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }
            at(t, e) {
                return e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }
            recast(t) {
                return this.origin.copy(this.at(t, jy)), this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = jy.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (jy.copy(this.direction).multiplyScalar(e).add(this.origin), jy.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                Hy.copy(t).add(e).multiplyScalar(.5), Vy.copy(e).sub(t).normalize(), Gy.copy(this.origin).sub(Hy);
                const r = .5 * t.distanceTo(e),
                    s = -this.direction.dot(Vy),
                    o = Gy.dot(this.direction),
                    a = -Gy.dot(Vy),
                    l = Gy.lengthSq(),
                    u = Math.abs(1 - s * s);
                let c, h, d, f;
                if (u > 0)
                    if (c = s * a - o, h = s * o - a, f = r * u, c >= 0)
                        if (h >= -f)
                            if (h <= f) {
                                const t = 1 / u;
                                c *= t, h *= t, d = c * (c + s * h + 2 * o) + h * (s * c + h + 2 * a) + l
                            } else h = r, c = Math.max(0, -(s * h + o)), d = -c * c + h * (h + 2 * a) + l;
                        else h = -r, c = Math.max(0, -(s * h + o)), d = -c * c + h * (h + 2 * a) + l;
                    else h <= -f ? (c = Math.max(0, -(-s * r + o)), h = c > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -c * c + h * (h + 2 * a) + l) : h <= f ? (c = 0, h = Math.min(Math.max(-r, -a), r), d = h * (h + 2 * a) + l) : (c = Math.max(0, -(s * r + o)), h = c > 0 ? r : Math.min(Math.max(-r, -a), r), d = -c * c + h * (h + 2 * a) + l);
                else h = s > 0 ? -r : r, c = Math.max(0, -(s * h + o)), d = -c * c + h * (h + 2 * a) + l;
                return n && n.copy(this.direction).multiplyScalar(c).add(this.origin), i && i.copy(Vy).multiplyScalar(h).add(Hy), d
            }
            intersectSphere(t, e) {
                jy.subVectors(t.center, this.origin);
                const n = jy.dot(this.direction),
                    i = jy.dot(jy) - n * n,
                    r = t.radius * t.radius;
                if (i > r) return null;
                const s = Math.sqrt(r - i),
                    o = n - s,
                    a = n + s;
                return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, s, o, a;
                const l = 1 / this.direction.x,
                    u = 1 / this.direction.y,
                    c = 1 / this.direction.z,
                    h = this.origin;
                return l >= 0 ? (n = (t.min.x - h.x) * l, i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l, i = (t.min.x - h.x) * l), u >= 0 ? (r = (t.min.y - h.y) * u, s = (t.max.y - h.y) * u) : (r = (t.max.y - h.y) * u, s = (t.min.y - h.y) * u), n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r), (s < i || isNaN(i)) && (i = s), c >= 0 ? (o = (t.min.z - h.z) * c, a = (t.max.z - h.z) * c) : (o = (t.max.z - h.z) * c, a = (t.min.z - h.z) * c), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, jy)
            }
            intersectTriangle(t, e, n, i, r) {
                Wy.subVectors(e, t), $y.subVectors(n, t), Xy.crossVectors(Wy, $y);
                let s, o = this.direction.dot(Xy);
                if (o > 0) {
                    if (i) return null;
                    s = 1
                } else {
                    if (!(o < 0)) return null;
                    s = -1, o = -o
                }
                Gy.subVectors(this.origin, t);
                const a = s * this.direction.dot($y.crossVectors(Gy, $y));
                if (a < 0) return null;
                const l = s * this.direction.dot(Wy.cross(Gy));
                if (l < 0) return null;
                if (a + l > o) return null;
                const u = -s * Gy.dot(Xy);
                return u < 0 ? null : this.at(u / o, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Yy {
            constructor() {
                Yy.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
            }
            set(t, e, n, i, r, s, o, a, l, u, c, h, d, f, p, m) {
                const g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = u, g[10] = c, g[14] = h, g[3] = d, g[7] = f, g[11] = p, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new Yy).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }
            copyPosition(t) {
                const e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(t) {
                const e = this.elements,
                    n = t.elements,
                    i = 1 / Ky.setFromMatrixColumn(t, 0).length(),
                    r = 1 / Ky.setFromMatrixColumn(t, 1).length(),
                    s = 1 / Ky.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromEuler(t) {
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z,
                    s = Math.cos(n),
                    o = Math.sin(n),
                    a = Math.cos(i),
                    l = Math.sin(i),
                    u = Math.cos(r),
                    c = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = s * u,
                        n = s * c,
                        i = o * u,
                        r = o * c;
                    e[0] = a * u, e[4] = -a * c, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a
                } else if ("YXZ" === t.order) {
                    const t = a * u,
                        n = a * c,
                        i = l * u,
                        r = l * c;
                    e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * c, e[5] = s * u, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                } else if ("ZXY" === t.order) {
                    const t = a * u,
                        n = a * c,
                        i = l * u,
                        r = l * c;
                    e[0] = t - r * o, e[4] = -s * c, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * u, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
                } else if ("ZYX" === t.order) {
                    const t = s * u,
                        n = s * c,
                        i = o * u,
                        r = o * c;
                    e[0] = a * u, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * c, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a
                } else if ("YZX" === t.order) {
                    const t = s * a,
                        n = s * l,
                        i = o * a,
                        r = o * l;
                    e[0] = a * u, e[4] = r - t * c, e[8] = i * c + n, e[1] = c, e[5] = s * u, e[9] = -o * u, e[2] = -l * u, e[6] = n * c + i, e[10] = t - r * c
                } else if ("XZY" === t.order) {
                    const t = s * a,
                        n = s * l,
                        i = o * a,
                        r = o * l;
                    e[0] = a * u, e[4] = -c, e[8] = l * u, e[1] = t * c + r, e[5] = s * u, e[9] = n * c - i, e[2] = i * c - n, e[6] = o * u, e[10] = r * c + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Zy, t, Qy)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return nb.subVectors(t, e), 0 === nb.lengthSq() && (nb.z = 1), nb.normalize(), tb.crossVectors(n, nb), 0 === tb.lengthSq() && (1 === Math.abs(n.z) ? nb.x += 1e-4 : nb.z += 1e-4, nb.normalize(), tb.crossVectors(n, nb)), tb.normalize(), eb.crossVectors(nb, tb), i[0] = tb.x, i[4] = eb.x, i[8] = nb.x, i[1] = tb.y, i[5] = eb.y, i[9] = nb.y, i[2] = tb.z, i[6] = eb.z, i[10] = nb.z, this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements,
                    i = e.elements,
                    r = this.elements,
                    s = n[0],
                    o = n[4],
                    a = n[8],
                    l = n[12],
                    u = n[1],
                    c = n[5],
                    h = n[9],
                    d = n[13],
                    f = n[2],
                    p = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    y = n[7],
                    b = n[11],
                    _ = n[15],
                    x = i[0],
                    w = i[4],
                    M = i[8],
                    S = i[12],
                    T = i[1],
                    E = i[5],
                    D = i[9],
                    C = i[13],
                    A = i[2],
                    P = i[6],
                    L = i[10],
                    R = i[14],
                    k = i[3],
                    O = i[7],
                    I = i[11],
                    F = i[15];
                return r[0] = s * x + o * T + a * A + l * k, r[4] = s * w + o * E + a * P + l * O, r[8] = s * M + o * D + a * L + l * I, r[12] = s * S + o * C + a * R + l * F, r[1] = u * x + c * T + h * A + d * k, r[5] = u * w + c * E + h * P + d * O, r[9] = u * M + c * D + h * L + d * I, r[13] = u * S + c * C + h * R + d * F, r[2] = f * x + p * T + m * A + g * k, r[6] = f * w + p * E + m * P + g * O, r[10] = f * M + p * D + m * L + g * I, r[14] = f * S + p * C + m * R + g * F, r[3] = v * x + y * T + b * A + _ * k, r[7] = v * w + y * E + b * P + _ * O, r[11] = v * M + y * D + b * L + _ * I, r[15] = v * S + y * C + b * R + _ * F, this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[4],
                    i = t[8],
                    r = t[12],
                    s = t[1],
                    o = t[5],
                    a = t[9],
                    l = t[13],
                    u = t[2],
                    c = t[6],
                    h = t[10],
                    d = t[14];
                return t[3] * (+r * a * c - i * l * c - r * o * h + n * l * h + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * h + r * s * h - i * s * d + i * l * u - r * a * u) + t[11] * (+e * l * c - e * o * d - r * s * c + n * s * d + r * o * u - n * l * u) + t[15] * (-i * o * u - e * a * c + e * o * h + i * s * c - n * s * h + n * a * u)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    l = t[7],
                    u = t[8],
                    c = t[9],
                    h = t[10],
                    d = t[11],
                    f = t[12],
                    p = t[13],
                    m = t[14],
                    g = t[15],
                    v = c * m * l - p * h * l + p * a * d - o * m * d - c * a * g + o * h * g,
                    y = f * h * l - u * m * l - f * a * d + s * m * d + u * a * g - s * h * g,
                    b = u * p * l - f * c * l + f * o * d - s * p * d - u * o * g + s * c * g,
                    _ = f * c * a - u * p * a - f * o * h + s * p * h + u * o * m - s * c * m,
                    x = e * v + n * y + i * b + r * _;
                if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const w = 1 / x;
                return t[0] = v * w, t[1] = (p * h * r - c * m * r - p * i * d + n * m * d + c * i * g - n * h * g) * w, t[2] = (o * m * r - p * a * r + p * i * l - n * m * l - o * i * g + n * a * g) * w, t[3] = (c * a * r - o * h * r - c * i * l + n * h * l + o * i * d - n * a * d) * w, t[4] = y * w, t[5] = (u * m * r - f * h * r + f * i * d - e * m * d - u * i * g + e * h * g) * w, t[6] = (f * a * r - s * m * r - f * i * l + e * m * l + s * i * g - e * a * g) * w, t[7] = (s * h * r - u * a * r + u * i * l - e * h * l - s * i * d + e * a * d) * w, t[8] = b * w, t[9] = (f * c * r - u * p * r - f * n * d + e * p * d + u * n * g - e * c * g) * w, t[10] = (s * p * r - f * o * r + f * n * l - e * p * l - s * n * g + e * o * g) * w, t[11] = (u * o * r - s * c * r - u * n * l + e * c * l + s * n * d - e * o * d) * w, t[12] = _ * w, t[13] = (u * p * i - f * c * i + f * n * h - e * p * h - u * n * m + e * c * m) * w, t[14] = (f * o * i - s * p * i - f * n * a + e * p * a + s * n * m - e * o * m) * w, t[15] = (s * c * i - u * o * i + u * n * a - e * c * a - s * n * h + e * o * h) * w, this
            }
            scale(t) {
                const e = this.elements,
                    n = t.x,
                    i = t.y,
                    r = t.z;
                return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
            }
            getMaxScaleOnAxis() {
                const t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            }
            makeRotationY(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(t) {
                const e = Math.cos(t),
                    n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e),
                    i = Math.sin(e),
                    r = 1 - n,
                    s = t.x,
                    o = t.y,
                    a = t.z,
                    l = r * s,
                    u = r * o;
                return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, u * o + n, u * a - i * s, 0, l * a - i * o, u * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(t, e, n, i, r, s) {
                return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this
            }
            compose(t, e, n) {
                const i = this.elements,
                    r = e._x,
                    s = e._y,
                    o = e._z,
                    a = e._w,
                    l = r + r,
                    u = s + s,
                    c = o + o,
                    h = r * l,
                    d = r * u,
                    f = r * c,
                    p = s * u,
                    m = s * c,
                    g = o * c,
                    v = a * l,
                    y = a * u,
                    b = a * c,
                    _ = n.x,
                    x = n.y,
                    w = n.z;
                return i[0] = (1 - (p + g)) * _, i[1] = (d + b) * _, i[2] = (f - y) * _, i[3] = 0, i[4] = (d - b) * x, i[5] = (1 - (h + g)) * x, i[6] = (m + v) * x, i[7] = 0, i[8] = (f + y) * w, i[9] = (m - v) * w, i[10] = (1 - (h + p)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = Ky.set(i[0], i[1], i[2]).length();
                const s = Ky.set(i[4], i[5], i[6]).length(),
                    o = Ky.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Jy.copy(this);
                const a = 1 / r,
                    l = 1 / s,
                    u = 1 / o;
                return Jy.elements[0] *= a, Jy.elements[1] *= a, Jy.elements[2] *= a, Jy.elements[4] *= l, Jy.elements[5] *= l, Jy.elements[6] *= l, Jy.elements[8] *= u, Jy.elements[9] *= u, Jy.elements[10] *= u, e.setFromRotationMatrix(Jy), n.x = r, n.y = s, n.z = o, this
            }
            makePerspective(t, e, n, i, r, s) {
                const o = this.elements,
                    a = 2 * r / (e - t),
                    l = 2 * r / (n - i),
                    u = (e + t) / (e - t),
                    c = (n + i) / (n - i),
                    h = -(s + r) / (s - r),
                    d = -2 * s * r / (s - r);
                return o[0] = a, o[4] = 0, o[8] = u, o[12] = 0, o[1] = 0, o[5] = l, o[9] = c, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
            }
            makeOrthographic(t, e, n, i, r, s) {
                const o = this.elements,
                    a = 1 / (e - t),
                    l = 1 / (n - i),
                    u = 1 / (s - r),
                    c = (e + t) * a,
                    h = (n + i) * l,
                    d = (s + r) * u;
                return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -c, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * u, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }
        const Ky = new by,
            Jy = new Yy,
            Zy = new by(0, 0, 0),
            Qy = new by(1, 1, 1),
            tb = new by,
            eb = new by,
            nb = new by,
            ib = new Yy,
            rb = new yy;
        class sb {
            constructor(t = 0, e = 0, n = 0, i = sb.DefaultOrder) {
                this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t, this._onChangeCallback()
            }
            set(t, e, n, i = this._order) {
                return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(t, e = this._order, n = !0) {
                const i = t.elements,
                    r = i[0],
                    s = i[4],
                    o = i[8],
                    a = i[1],
                    l = i[5],
                    u = i[9],
                    c = i[2],
                    h = i[6],
                    d = i[10];
                switch (e) {
                    case "XYZ":
                        this._y = Math.asin(zv(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-zv(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-c, r), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(zv(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-zv(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(zv(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(o, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-zv(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-u, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(t, e, n) {
                return ib.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ib, e, n)
            }
            setFromVector3(t, e = this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return rb.setFromEuler(this), this.setFromQuaternion(rb, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() { } *[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
            toVector3() {
                console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
            }
        }
        sb.DefaultOrder = "XYZ", sb.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class ob {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t >>> 0
            }
            enable(t) {
                this.mask |= 1 << t
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t
            }
            disable(t) {
                this.mask &= ~(1 << t)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return !!(this.mask & t.mask)
            }
            isEnabled(t) {
                return !!(this.mask & 1 << t)
            }
        }
        let ab = 0;
        const lb = new by,
            ub = new yy,
            cb = new Yy,
            hb = new by,
            db = new by,
            fb = new by,
            pb = new yy,
            mb = new by(1, 0, 0),
            gb = new by(0, 1, 0),
            vb = new by(0, 0, 1),
            yb = {
                type: "added"
            },
            bb = {
                type: "removed"
            };
        class _b extends Rv {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                    value: ab++
                }), this.uuid = Nv(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _b.DefaultUp.clone();
                const t = new by,
                    e = new sb,
                    n = new yy,
                    i = new by(1, 1, 1);
                e._onChange((function () {
                    n.setFromEuler(e, !1)
                })), n._onChange((function () {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Yy
                    },
                    normalMatrix: {
                        value: new qv
                    }
                }), this.matrix = new Yy, this.matrixWorld = new Yy, this.matrixAutoUpdate = _b.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = _b.DefaultMatrixWorldAutoUpdate, this.layers = new ob, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeRender() { }
            onAfterRender() { }
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t), this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return ub.setFromAxisAngle(t, e), this.quaternion.multiply(ub), this
            }
            rotateOnWorldAxis(t, e) {
                return ub.setFromAxisAngle(t, e), this.quaternion.premultiply(ub), this
            }
            rotateX(t) {
                return this.rotateOnAxis(mb, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(gb, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(vb, t)
            }
            translateOnAxis(t, e) {
                return lb.copy(t).applyQuaternion(this.quaternion), this.position.add(lb.multiplyScalar(e)), this
            }
            translateX(t) {
                return this.translateOnAxis(mb, t)
            }
            translateY(t) {
                return this.translateOnAxis(gb, t)
            }
            translateZ(t) {
                return this.translateOnAxis(vb, t)
            }
            localToWorld(t) {
                return t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return t.applyMatrix4(cb.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? hb.copy(t) : hb.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), db.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? cb.lookAt(db, hb, this.up) : cb.lookAt(hb, db, this.up), this.quaternion.setFromRotationMatrix(cb), i && (cb.extractRotation(i.matrixWorld), ub.setFromRotationMatrix(cb), this.quaternion.premultiply(ub.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(yb)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(bb)), this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this), this
            }
            clear() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null, e.dispatchEvent(bb)
                }
                return this.children.length = 0, this
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1), cb.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), cb.multiply(t.parent.matrixWorld)), t.applyMatrix4(cb), this.add(t), t.updateWorldMatrix(!1, !0), this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i) return i
                }
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(db, t, fb), t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(db, pb, t), t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() { }
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    !0 !== i.matrixWorldAutoUpdate && !0 !== t || i.updateMatrixWorld(t)
                }
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t,
                    n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};

                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            } else r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = s(t.geometries),
                        i = s(t.materials),
                        r = s(t.textures),
                        o = s(t.images),
                        a = s(t.shapes),
                        l = s(t.skeletons),
                        u = s(t.animations),
                        c = s(t.nodes);
                    e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), u.length > 0 && (n.animations = u), c.length > 0 && (n.nodes = c)
                }
                return n.object = i, n;

                function s(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e = !0) {
                if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        _b.DefaultUp = new by(0, 1, 0), _b.DefaultMatrixAutoUpdate = !0, _b.DefaultMatrixWorldAutoUpdate = !0;
        const xb = new by,
            wb = new by,
            Mb = new by,
            Sb = new by,
            Tb = new by,
            Eb = new by,
            Db = new by,
            Cb = new by,
            Ab = new by,
            Pb = new by;
        class Lb {
            constructor(t = new by, e = new by, n = new by) {
                this.a = t, this.b = e, this.c = n
            }
            static getNormal(t, e, n, i) {
                i.subVectors(n, e), xb.subVectors(t, e), i.cross(xb);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                xb.subVectors(i, e), wb.subVectors(n, e), Mb.subVectors(t, e);
                const s = xb.dot(xb),
                    o = xb.dot(wb),
                    a = xb.dot(Mb),
                    l = wb.dot(wb),
                    u = wb.dot(Mb),
                    c = s * l - o * o;
                if (0 === c) return r.set(-2, -1, -1);
                const h = 1 / c,
                    d = (l * a - o * u) * h,
                    f = (s * u - o * a) * h;
                return r.set(1 - d - f, f, d)
            }
            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, Sb), Sb.x >= 0 && Sb.y >= 0 && Sb.x + Sb.y <= 1
            }
            static getUV(t, e, n, i, r, s, o, a) {
                return this.getBarycoord(t, e, n, i, Sb), a.set(0, 0), a.addScaledVector(r, Sb.x), a.addScaledVector(s, Sb.y), a.addScaledVector(o, Sb.z), a
            }
            static isFrontFacing(t, e, n, i) {
                return xb.subVectors(n, e), wb.subVectors(t, e), xb.cross(wb).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            }
            setFromAttributeAndIndices(t, e, n, i) {
                return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }
            getArea() {
                return xb.subVectors(this.c, this.b), wb.subVectors(this.a, this.b), .5 * xb.cross(wb).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return Lb.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return Lb.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return Lb.getUV(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return Lb.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return Lb.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a,
                    i = this.b,
                    r = this.c;
                let s, o;
                Tb.subVectors(i, n), Eb.subVectors(r, n), Cb.subVectors(t, n);
                const a = Tb.dot(Cb),
                    l = Eb.dot(Cb);
                if (a <= 0 && l <= 0) return e.copy(n);
                Ab.subVectors(t, i);
                const u = Tb.dot(Ab),
                    c = Eb.dot(Ab);
                if (u >= 0 && c <= u) return e.copy(i);
                const h = a * c - u * l;
                if (h <= 0 && a >= 0 && u <= 0) return s = a / (a - u), e.copy(n).addScaledVector(Tb, s);
                Pb.subVectors(t, r);
                const d = Tb.dot(Pb),
                    f = Eb.dot(Pb);
                if (f >= 0 && d <= f) return e.copy(r);
                const p = d * l - a * f;
                if (p <= 0 && l >= 0 && f <= 0) return o = l / (l - f), e.copy(n).addScaledVector(Eb, o);
                const m = u * f - d * c;
                if (m <= 0 && c - u >= 0 && d - f >= 0) return Db.subVectors(r, i), o = (c - u) / (c - u + (d - f)), e.copy(i).addScaledVector(Db, o);
                const g = 1 / (m + p + h);
                return s = p * g, o = h * g, e.copy(n).addScaledVector(Tb, s).addScaledVector(Eb, o)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let Rb = 0;
        class kb extends Rv {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                    value: Rb++
                }), this.uuid = Nv(), this.name = "", this.type = "Material", this.blending = Tm, this.side = xm, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = Um, this.blendDst = Bm, this.blendEquation = Pm, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Ym, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Cv, this.stencilZFail = Cv, this.stencilZPass = Cv, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
            }
            onBuild() { }
            onBeforeRender() { }
            onBeforeCompile() { }
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        const i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Tm && (n.blending = this.blending), this.side !== xm && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                    const e = i(t.textures),
                        r = i(t.images);
                    e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        class Ob extends kb {
            constructor(t) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ay(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tg, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
            }
        }
        const Ib = new by,
            Fb = new Xv;
        class Nb {
            constructor(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = Av, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }
            onUploadCallback() { }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t, this
            }
            copy(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
            }
            copyAt(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t), this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) Fb.fromBufferAttribute(this, e), Fb.applyMatrix3(t), this.setXY(e, Fb.x, Fb.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++) Ib.fromBufferAttribute(this, e), Ib.applyMatrix3(t), this.setXYZ(e, Ib.x, Ib.y, Ib.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++) Ib.fromBufferAttribute(this, e), Ib.applyMatrix4(t), this.setXYZ(e, Ib.x, Ib.y, Ib.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) Ib.fromBufferAttribute(this, e), Ib.applyNormalMatrix(t), this.setXYZ(e, Ib.x, Ib.y, Ib.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) Ib.fromBufferAttribute(this, e), Ib.transformDirection(t), this.setXYZ(e, Ib.x, Ib.y, Ib.z);
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            getX(t) {
                let e = this.array[t * this.itemSize];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            setX(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.array[t * this.itemSize] = e, this
            }
            getY(t) {
                let e = this.array[t * this.itemSize + 1];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            setY(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.array[t * this.itemSize + 1] = e, this
            }
            getZ(t) {
                let e = this.array[t * this.itemSize + 2];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            setZ(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.array[t * this.itemSize + 2] = e, this
            }
            getW(t) {
                let e = this.array[t * this.itemSize + 3];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            setW(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.array[t * this.itemSize + 3] = e, this
            }
            setXY(t, e, n) {
                return t *= this.itemSize, this.normalized && (e = Wv(e, this.array), n = Wv(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
            }
            setXYZ(t, e, n, i) {
                return t *= this.itemSize, this.normalized && (e = Wv(e, this.array), n = Wv(n, this.array), i = Wv(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
            }
            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize, this.normalized && (e = Wv(e, this.array), n = Wv(n, this.array), i = Wv(i, this.array), r = Wv(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name), this.usage !== Av && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
            }
            copyColorsArray() {
                console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
            }
            copyVector2sArray() {
                console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
            }
            copyVector3sArray() {
                console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
            }
            copyVector4sArray() {
                console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
            }
        }
        class zb extends Nb {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class Ub extends Nb {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        class Bb extends Nb {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let jb = 0;
        const Hb = new Yy,
            Vb = new _b,
            Gb = new by,
            Wb = new wy,
            $b = new wy,
            Xb = new by;
        class qb extends Rv {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                    value: jb++
                }), this.uuid = Nv(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new (Yv(t) ? Ub : zb)(t, 1) : this.index = t, this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e, this
            }
            deleteAttribute(t) {
                return delete this.attributes[t], this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n = 0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new qv).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(t) {
                return Hb.makeRotationFromQuaternion(t), this.applyMatrix4(Hb), this
            }
            rotateX(t) {
                return Hb.makeRotationX(t), this.applyMatrix4(Hb), this
            }
            rotateY(t) {
                return Hb.makeRotationY(t), this.applyMatrix4(Hb), this
            }
            rotateZ(t) {
                return Hb.makeRotationZ(t), this.applyMatrix4(Hb), this
            }
            translate(t, e, n) {
                return Hb.makeTranslation(t, e, n), this.applyMatrix4(Hb), this
            }
            scale(t, e, n) {
                return Hb.makeScale(t, e, n), this.applyMatrix4(Hb), this
            }
            lookAt(t) {
                return Vb.lookAt(t), Vb.updateMatrix(), this.applyMatrix4(Vb.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Gb).negate(), this.translate(Gb.x, Gb.y, Gb.z), this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Bb(e, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new wy);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new by(-1 / 0, -1 / 0, -1 / 0), new by(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Wb.setFromBufferAttribute(n), this.morphTargetsRelative ? (Xb.addVectors(this.boundingBox.min, Wb.min), this.boundingBox.expandByPoint(Xb), Xb.addVectors(this.boundingBox.max, Wb.max), this.boundingBox.expandByPoint(Xb)) : (this.boundingBox.expandByPoint(Wb.min), this.boundingBox.expandByPoint(Wb.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new By);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new by, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (Wb.setFromBufferAttribute(t), e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            $b.setFromBufferAttribute(n), this.morphTargetsRelative ? (Xb.addVectors(Wb.min, $b.min), Wb.expandByPoint(Xb), Xb.addVectors(Wb.max, $b.max), Wb.expandByPoint(Xb)) : (Wb.expandByPoint($b.min), Wb.expandByPoint($b.max))
                        }
                    Wb.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++) Xb.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Xb));
                    if (e)
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r],
                                o = this.morphTargetsRelative;
                            for (let e = 0, r = s.count; e < r; e++) Xb.fromBufferAttribute(s, e), o && (Gb.fromBufferAttribute(t, e), Xb.add(Gb)), i = Math.max(i, n.distanceToSquared(Xb))
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index,
                    e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array,
                    i = e.position.array,
                    r = e.normal.array,
                    s = e.uv.array,
                    o = i.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Nb(new Float32Array(4 * o), 4));
                const a = this.getAttribute("tangent").array,
                    l = [],
                    u = [];
                for (let t = 0; t < o; t++) l[t] = new by, u[t] = new by;
                const c = new by,
                    h = new by,
                    d = new by,
                    f = new Xv,
                    p = new Xv,
                    m = new Xv,
                    g = new by,
                    v = new by;

                function y(t, e, n) {
                    c.fromArray(i, 3 * t), h.fromArray(i, 3 * e), d.fromArray(i, 3 * n), f.fromArray(s, 2 * t), p.fromArray(s, 2 * e), m.fromArray(s, 2 * n), h.sub(c), d.sub(c), p.sub(f), m.sub(f);
                    const r = 1 / (p.x * m.y - m.x * p.y);
                    isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -p.y).multiplyScalar(r), v.copy(d).multiplyScalar(p.x).addScaledVector(h, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), u[t].add(v), u[e].add(v), u[n].add(v))
                }
                let b = this.groups;
                0 === b.length && (b = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = b.length; t < e; ++t) {
                    const e = b[t],
                        i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
                }
                const _ = new by,
                    x = new by,
                    w = new by,
                    M = new by;

                function S(t) {
                    w.fromArray(r, 3 * t), M.copy(w);
                    const e = l[t];
                    _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), x.crossVectors(M, e);
                    const n = x.dot(u[t]) < 0 ? -1 : 1;
                    a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
                }
                for (let t = 0, e = b.length; t < e; ++t) {
                    const e = b[t],
                        i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Nb(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                    const i = new by,
                        r = new by,
                        s = new by,
                        o = new by,
                        a = new by,
                        l = new by,
                        u = new by,
                        c = new by;
                    if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                            const d = t.getX(h + 0),
                                f = t.getX(h + 1),
                                p = t.getX(h + 2);
                            i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, f), s.fromBufferAttribute(e, p), u.subVectors(s, r), c.subVectors(i, r), u.cross(c), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, f), l.fromBufferAttribute(n, p), o.add(u), a.add(u), l.add(u), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(p, l.x, l.y, l.z)
                        } else
                        for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), u.subVectors(s, r), c.subVectors(i, r), u.cross(c), n.setXYZ(t + 0, u.x, u.y, u.z), n.setXYZ(t + 1, u.x, u.y, u.z), n.setXYZ(t + 2, u.x, u.y, u.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            merge() {
                return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++) Xb.fromBufferAttribute(t, e), Xb.normalize(), t.setXYZ(e, Xb.x, Xb.y, Xb.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array,
                        i = t.itemSize,
                        r = t.normalized,
                        s = new n.constructor(e.length * i);
                    let o = 0,
                        a = 0;
                    for (let r = 0, l = e.length; r < l; r++) {
                        o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                        for (let t = 0; t < i; t++) s[a++] = n[o++]
                    }
                    return new Nb(s, i, r)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new qb,
                    n = this.index.array,
                    i = this.attributes;
                for (const r in i) {
                    const s = t(i[r], n);
                    e.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = [],
                        o = r[i];
                    for (let e = 0, i = o.length; e < i; e++) {
                        const i = t(o[e], n);
                        s.push(i)
                    }
                    e.morphAttributes[i] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e];
                    t.data.attributes[e] = i.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e],
                        s = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        s.push(i.toJSON(t.data))
                    }
                    s.length > 0 && (i[e] = s, r = !0)
                }
                r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const o = this.boundingSphere;
                return null !== o && (t.data.boundingSphere = {
                    center: o.center.toArray(),
                    radius: o.radius
                }), t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = [],
                        i = r[t];
                    for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const o = t.boundingBox;
                null !== o && (this.boundingBox = o.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Yb = new Yy,
            Kb = new qy,
            Jb = new By,
            Zb = new by,
            Qb = new by,
            t_ = new by,
            e_ = new by,
            n_ = new by,
            i_ = new by,
            r_ = new by,
            s_ = new by,
            o_ = new by,
            a_ = new Xv,
            l_ = new Xv,
            u_ = new Xv,
            c_ = new by,
            h_ = new by;
        class d_ extends _b {
            constructor(t = new qb, e = new Ob) {
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.material,
                    r = this.matrixWorld;
                if (void 0 === i) return;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Jb.copy(n.boundingSphere), Jb.applyMatrix4(r), !1 === t.ray.intersectsSphere(Jb)) return;
                if (Yb.copy(r).invert(), Kb.copy(t.ray).applyMatrix4(Yb), null !== n.boundingBox && !1 === Kb.intersectsBox(n.boundingBox)) return;
                let s;
                const o = n.index,
                    a = n.attributes.position,
                    l = n.morphAttributes.position,
                    u = n.morphTargetsRelative,
                    c = n.attributes.uv,
                    h = n.attributes.uv2,
                    d = n.groups,
                    f = n.drawRange;
                if (null !== o)
                    if (Array.isArray(i))
                        for (let n = 0, r = d.length; n < r; n++) {
                            const r = d[n],
                                p = i[r.materialIndex];
                            for (let n = Math.max(r.start, f.start), i = Math.min(o.count, Math.min(r.start + r.count, f.start + f.count)); n < i; n += 3) {
                                const i = o.getX(n),
                                    d = o.getX(n + 1),
                                    f = o.getX(n + 2);
                                s = f_(this, p, t, Kb, a, l, u, c, h, i, d, f), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                            }
                        } else
                        for (let n = Math.max(0, f.start), r = Math.min(o.count, f.start + f.count); n < r; n += 3) {
                            const r = o.getX(n),
                                d = o.getX(n + 1),
                                f = o.getX(n + 2);
                            s = f_(this, i, t, Kb, a, l, u, c, h, r, d, f), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                        } else if (void 0 !== a)
                    if (Array.isArray(i))
                        for (let n = 0, r = d.length; n < r; n++) {
                            const r = d[n],
                                o = i[r.materialIndex];
                            for (let n = Math.max(r.start, f.start), i = Math.min(a.count, Math.min(r.start + r.count, f.start + f.count)); n < i; n += 3) s = f_(this, o, t, Kb, a, l, u, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                        } else
                        for (let n = Math.max(0, f.start), r = Math.min(a.count, f.start + f.count); n < r; n += 3) s = f_(this, i, t, Kb, a, l, u, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
            }
        }

        function f_(t, e, n, i, r, s, o, a, l, u, c, h) {
            Zb.fromBufferAttribute(r, u), Qb.fromBufferAttribute(r, c), t_.fromBufferAttribute(r, h);
            const d = t.morphTargetInfluences;
            if (s && d) {
                r_.set(0, 0, 0), s_.set(0, 0, 0), o_.set(0, 0, 0);
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = d[t],
                        n = s[t];
                    0 !== e && (e_.fromBufferAttribute(n, u), n_.fromBufferAttribute(n, c), i_.fromBufferAttribute(n, h), o ? (r_.addScaledVector(e_, e), s_.addScaledVector(n_, e), o_.addScaledVector(i_, e)) : (r_.addScaledVector(e_.sub(Zb), e), s_.addScaledVector(n_.sub(Qb), e), o_.addScaledVector(i_.sub(t_), e)))
                }
                Zb.add(r_), Qb.add(s_), t_.add(o_)
            }
            t.isSkinnedMesh && (t.boneTransform(u, Zb), t.boneTransform(c, Qb), t.boneTransform(h, t_));
            const f = function (t, e, n, i, r, s, o, a) {
                let l;
                if (l = e.side === wm ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, e.side !== Mm, a), null === l) return null;
                h_.copy(a), h_.applyMatrix4(t.matrixWorld);
                const u = n.ray.origin.distanceTo(h_);
                return u < n.near || u > n.far ? null : {
                    distance: u,
                    point: h_.clone(),
                    object: t
                }
            }(t, e, n, i, Zb, Qb, t_, c_);
            if (f) {
                a && (a_.fromBufferAttribute(a, u), l_.fromBufferAttribute(a, c), u_.fromBufferAttribute(a, h), f.uv = Lb.getUV(c_, Zb, Qb, t_, a_, l_, u_, new Xv)), l && (a_.fromBufferAttribute(l, u), l_.fromBufferAttribute(l, c), u_.fromBufferAttribute(l, h), f.uv2 = Lb.getUV(c_, Zb, Qb, t_, a_, l_, u_, new Xv));
                const t = {
                    a: u,
                    b: c,
                    c: h,
                    normal: new by,
                    materialIndex: 0
                };
                Lb.getNormal(Zb, Qb, t_, t.normal), f.face = t
            }
            return f
        }
        class p_ extends qb {
            constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const o = this;
                i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                const a = [],
                    l = [],
                    u = [],
                    c = [];
                let h = 0,
                    d = 0;

                function f(t, e, n, i, r, s, f, p, m, g, v) {
                    const y = s / m,
                        b = f / g,
                        _ = s / 2,
                        x = f / 2,
                        w = p / 2,
                        M = m + 1,
                        S = g + 1;
                    let T = 0,
                        E = 0;
                    const D = new by;
                    for (let s = 0; s < S; s++) {
                        const o = s * b - x;
                        for (let a = 0; a < M; a++) {
                            const h = a * y - _;
                            D[t] = h * i, D[e] = o * r, D[n] = w, l.push(D.x, D.y, D.z), D[t] = 0, D[e] = 0, D[n] = p > 0 ? 1 : -1, u.push(D.x, D.y, D.z), c.push(a / m), c.push(1 - s / g), T += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = h + e + M * t,
                                i = h + e + M * (t + 1),
                                r = h + (e + 1) + M * (t + 1),
                                s = h + (e + 1) + M * t;
                            a.push(n, i, s), a.push(i, r, s), E += 6
                        }
                    o.addGroup(d, E, v), d += E, h += T
                }
                f("z", "y", "x", -1, -1, n, e, t, s, r, 0), f("z", "y", "x", 1, -1, n, e, -t, s, r, 1), f("x", "z", "y", 1, 1, t, n, e, i, s, 2), f("x", "z", "y", 1, -1, t, n, -e, i, s, 3), f("x", "y", "z", 1, -1, t, e, n, i, r, 4), f("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Bb(l, 3)), this.setAttribute("normal", new Bb(u, 3)), this.setAttribute("uv", new Bb(c, 2))
            }
            static fromJSON(t) {
                return new p_(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
            }
        }

        function m_(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }

        function g_(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = m_(t[n]);
                for (const t in i) e[t] = i[t]
            }
            return e
        }
        const v_ = {
            clone: m_,
            merge: g_
        };
        class y_ extends kb {
            constructor(t) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = m_(t.uniforms), this.uniformsGroups = function (t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                    return e
                }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }
        }
        class b_ extends _b {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Yy, this.projectionMatrix = new Yy, this.projectionMatrixInverse = new Yy
            }
            copy(t, e) {
                return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class __ extends b_ {
            constructor(t = 50, e = 1, n = .1, i = 2e3) {
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Fv * Math.atan(e), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * Iv * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * Fv * Math.atan(Math.tan(.5 * Iv * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, i, r, s) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * Iv * this.fov) / this.zoom,
                    n = 2 * e,
                    i = this.aspect * n,
                    r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = s.fullWidth,
                        o = s.fullHeight;
                    r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                }
                const o = this.filmOffset;
                0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }
        const x_ = 90;
        class w_ extends _b {
            constructor(t, e, n) {
                super(), this.type = "CubeCamera", this.renderTarget = n;
                const i = new __(x_, 1, t, e);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new by(1, 0, 0)), this.add(i);
                const r = new __(x_, 1, t, e);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new by(-1, 0, 0)), this.add(r);
                const s = new __(x_, 1, t, e);
                s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new by(0, 1, 0)), this.add(s);
                const o = new __(x_, 1, t, e);
                o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new by(0, -1, 0)), this.add(o);
                const a = new __(x_, 1, t, e);
                a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new by(0, 0, 1)), this.add(a);
                const l = new __(x_, 1, t, e);
                l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new by(0, 0, -1)), this.add(l)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget,
                    [i, r, s, o, a, l] = this.children,
                    u = t.getRenderTarget(),
                    c = t.toneMapping,
                    h = t.xr.enabled;
                t.toneMapping = ig, t.xr.enabled = !1;
                const d = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = d, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(u), t.toneMapping = c, t.xr.enabled = h, n.texture.needsPMREMUpdate = !0
            }
        }
        class M_ extends fy {
            constructor(t, e, n, i, r, s, o, a, l, u) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : ug, n, i, r, s, o, a, l, u), this.isCubeTexture = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        class S_ extends my {
            constructor(t = 1, e = {}) {
                super(t, t, e), this.isWebGLCubeRenderTarget = !0;
                const n = {
                    width: t,
                    height: t,
                    depth: 1
                },
                    i = [n, n, n, n, n, n];
                this.texture = new M_(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : _g
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                    tEquirect: {
                        value: null
                    }
                },
                    i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                    s = new p_(5, 5, 5),
                    o = new y_({
                        name: "CubemapFromEquirect",
                        uniforms: m_(n),
                        vertexShader: i,
                        fragmentShader: r,
                        side: wm,
                        blending: Sm
                    });
                o.uniforms.tEquirect.value = e;
                const a = new d_(s, o),
                    l = e.minFilter;
                return e.minFilter === wg && (e.minFilter = _g), new w_(1, 10, this).update(t, a), e.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        const T_ = new by,
            E_ = new by,
            D_ = new qv;
        class C_ {
            constructor(t = new by(1, 0, 0), e = 0) {
                this.isPlane = !0, this.normal = t, this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n), this.constant = i, this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = T_.subVectors(n, e).cross(E_.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t), this
            }
            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                const n = t.delta(T_),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || D_.getNormalMatrix(t),
                    i = this.coplanarPoint(T_).applyMatrix4(t),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const A_ = new By,
            P_ = new by;
        class L_ {
            constructor(t = new C_, e = new C_, n = new C_, i = new C_, r = new C_, s = new C_) {
                this.planes = [t, e, n, i, r, s]
            }
            set(t, e, n, i, r, s) {
                const o = this.planes;
                return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes,
                    n = t.elements,
                    i = n[0],
                    r = n[1],
                    s = n[2],
                    o = n[3],
                    a = n[4],
                    l = n[5],
                    u = n[6],
                    c = n[7],
                    h = n[8],
                    d = n[9],
                    f = n[10],
                    p = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    y = n[15];
                return e[0].setComponents(o - i, c - a, p - h, y - m).normalize(), e[1].setComponents(o + i, c + a, p + h, y + m).normalize(), e[2].setComponents(o + r, c + l, p + d, y + g).normalize(), e[3].setComponents(o - r, c - l, p - d, y - g).normalize(), e[4].setComponents(o - s, c - u, p - f, y - v).normalize(), e[5].setComponents(o + s, c + u, p + f, y + v).normalize(), this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), A_.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(A_)
            }
            intersectsSprite(t) {
                return A_.center.set(0, 0, 0), A_.radius = .7071067811865476, A_.applyMatrix4(t.matrixWorld), this.intersectsSphere(A_)
            }
            intersectsSphere(t) {
                const e = this.planes,
                    n = t.center,
                    i = -t.radius;
                for (let t = 0; t < 6; t++)
                    if (e[t].distanceToPoint(n) < i) return !1;
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (P_.x = i.normal.x > 0 ? t.max.x : t.min.x, P_.y = i.normal.y > 0 ? t.max.y : t.min.y, P_.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(P_) < 0) return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function R_() {
            let t = null,
                e = !1,
                n = null,
                i = null;

            function r(e, s) {
                n(e, s), i = t.requestAnimationFrame(r)
            }
            return {
                start: function () {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                },
                stop: function () {
                    t.cancelAnimationFrame(i), e = !1
                },
                setAnimationLoop: function (t) {
                    n = t
                },
                setContext: function (e) {
                    t = e
                }
            }
        }

        function k_(t, e) {
            const n = e.isWebGL2,
                i = new WeakMap;
            return {
                get: function (t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                },
                remove: function (e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer), i.delete(e))
                },
                update: function (e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void ((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = i.get(e);
                    void 0 === s ? i.set(e, function (e, i) {
                        const r = e.array,
                            s = e.usage,
                            o = t.createBuffer();
                        let a;
                        if (t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback(), r instanceof Float32Array) a = 5126;
                        else if (r instanceof Uint16Array)
                            if (e.isFloat16BufferAttribute) {
                                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                a = 5131
                            } else a = 5123;
                        else if (r instanceof Int16Array) a = 5122;
                        else if (r instanceof Uint32Array) a = 5125;
                        else if (r instanceof Int32Array) a = 5124;
                        else if (r instanceof Int8Array) a = 5120;
                        else if (r instanceof Uint8Array) a = 5121;
                        else {
                            if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                            a = 5121
                        }
                        return {
                            buffer: o,
                            type: a,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : s.version < e.version && (function (e, i, r) {
                        const s = i.array,
                            o = i.updateRange;
                        t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                    }(s.buffer, e, r), s.version = e.version)
                }
            }
        }
        class O_ extends qb {
            constructor(t = 1, e = 1, n = 1, i = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2,
                    s = e / 2,
                    o = Math.floor(n),
                    a = Math.floor(i),
                    l = o + 1,
                    u = a + 1,
                    c = t / o,
                    h = e / a,
                    d = [],
                    f = [],
                    p = [],
                    m = [];
                for (let t = 0; t < u; t++) {
                    const e = t * h - s;
                    for (let n = 0; n < l; n++) {
                        const i = n * c - r;
                        f.push(i, -e, 0), p.push(0, 0, 1), m.push(n / o), m.push(1 - t / a)
                    }
                }
                for (let t = 0; t < a; t++)
                    for (let e = 0; e < o; e++) {
                        const n = e + l * t,
                            i = e + l * (t + 1),
                            r = e + 1 + l * (t + 1),
                            s = e + 1 + l * t;
                        d.push(n, i, s), d.push(i, r, s)
                    }
                this.setIndex(d), this.setAttribute("position", new Bb(f, 3)), this.setAttribute("normal", new Bb(p, 3)), this.setAttribute("uv", new Bb(m, 2))
            }
            static fromJSON(t) {
                return new O_(t.width, t.height, t.widthSegments, t.heightSegments)
            }
        }
        const I_ = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
        },
            F_ = {
                common: {
                    diffuse: {
                        value: new ay(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new qv
                    },
                    uv2Transform: {
                        value: new qv
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new Xv(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new ay(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new ay(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new qv
                    }
                },
                sprite: {
                    diffuse: {
                        value: new ay(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Xv(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new qv
                    }
                }
            },
            N_ = {
                basic: {
                    uniforms: g_([F_.common, F_.specularmap, F_.envmap, F_.aomap, F_.lightmap, F_.fog]),
                    vertexShader: I_.meshbasic_vert,
                    fragmentShader: I_.meshbasic_frag
                },
                lambert: {
                    uniforms: g_([F_.common, F_.specularmap, F_.envmap, F_.aomap, F_.lightmap, F_.emissivemap, F_.bumpmap, F_.normalmap, F_.displacementmap, F_.fog, F_.lights, {
                        emissive: {
                            value: new ay(0)
                        }
                    }]),
                    vertexShader: I_.meshlambert_vert,
                    fragmentShader: I_.meshlambert_frag
                },
                phong: {
                    uniforms: g_([F_.common, F_.specularmap, F_.envmap, F_.aomap, F_.lightmap, F_.emissivemap, F_.bumpmap, F_.normalmap, F_.displacementmap, F_.fog, F_.lights, {
                        emissive: {
                            value: new ay(0)
                        },
                        specular: {
                            value: new ay(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: I_.meshphong_vert,
                    fragmentShader: I_.meshphong_frag
                },
                standard: {
                    uniforms: g_([F_.common, F_.envmap, F_.aomap, F_.lightmap, F_.emissivemap, F_.bumpmap, F_.normalmap, F_.displacementmap, F_.roughnessmap, F_.metalnessmap, F_.fog, F_.lights, {
                        emissive: {
                            value: new ay(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: I_.meshphysical_vert,
                    fragmentShader: I_.meshphysical_frag
                },
                toon: {
                    uniforms: g_([F_.common, F_.aomap, F_.lightmap, F_.emissivemap, F_.bumpmap, F_.normalmap, F_.displacementmap, F_.gradientmap, F_.fog, F_.lights, {
                        emissive: {
                            value: new ay(0)
                        }
                    }]),
                    vertexShader: I_.meshtoon_vert,
                    fragmentShader: I_.meshtoon_frag
                },
                matcap: {
                    uniforms: g_([F_.common, F_.bumpmap, F_.normalmap, F_.displacementmap, F_.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: I_.meshmatcap_vert,
                    fragmentShader: I_.meshmatcap_frag
                },
                points: {
                    uniforms: g_([F_.points, F_.fog]),
                    vertexShader: I_.points_vert,
                    fragmentShader: I_.points_frag
                },
                dashed: {
                    uniforms: g_([F_.common, F_.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: I_.linedashed_vert,
                    fragmentShader: I_.linedashed_frag
                },
                depth: {
                    uniforms: g_([F_.common, F_.displacementmap]),
                    vertexShader: I_.depth_vert,
                    fragmentShader: I_.depth_frag
                },
                normal: {
                    uniforms: g_([F_.common, F_.bumpmap, F_.normalmap, F_.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: I_.meshnormal_vert,
                    fragmentShader: I_.meshnormal_frag
                },
                sprite: {
                    uniforms: g_([F_.sprite, F_.fog]),
                    vertexShader: I_.sprite_vert,
                    fragmentShader: I_.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new qv
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: I_.background_vert,
                    fragmentShader: I_.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        }
                    },
                    vertexShader: I_.backgroundCube_vert,
                    fragmentShader: I_.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: I_.cube_vert,
                    fragmentShader: I_.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: I_.equirect_vert,
                    fragmentShader: I_.equirect_frag
                },
                distanceRGBA: {
                    uniforms: g_([F_.common, F_.displacementmap, {
                        referencePosition: {
                            value: new by
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: I_.distanceRGBA_vert,
                    fragmentShader: I_.distanceRGBA_frag
                },
                shadow: {
                    uniforms: g_([F_.lights, F_.fog, {
                        color: {
                            value: new ay(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: I_.shadow_vert,
                    fragmentShader: I_.shadow_frag
                }
            };

        function z_(t, e, n, i, r, s, o) {
            const a = new ay(0);
            let l, u, c = !0 === s ? 0 : 1,
                h = null,
                d = 0,
                f = null;

            function p(t, e) {
                i.buffers.color.setClear(t.r, t.g, t.b, e, o)
            }
            return {
                getClearColor: function () {
                    return a
                },
                setClearColor: function (t, e = 1) {
                    a.set(t), c = e, p(a, c)
                },
                getClearAlpha: function () {
                    return c
                },
                setClearAlpha: function (t) {
                    c = t, p(a, c)
                },
                render: function (i, s) {
                    let o = !1,
                        m = !0 === s.isScene ? s.background : null;
                    m && m.isTexture && (m = (s.backgroundBlurriness > 0 ? n : e).get(m));
                    const g = t.xr,
                        v = g.getSession && g.getSession();
                    v && "additive" === v.environmentBlendMode && (m = null), null === m ? p(a, c) : m && m.isColor && (p(m, 1), o = !0), (t.autoClear || o) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.mapping === fg) ? (void 0 === u && (u = new d_(new p_(1, 1, 1), new y_({
                        name: "BackgroundCubeMaterial",
                        uniforms: m_(N_.backgroundCube.uniforms),
                        vertexShader: N_.backgroundCube.vertexShader,
                        fragmentShader: N_.backgroundCube.fragmentShader,
                        side: wm,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(u.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), r.update(u)), u.material.uniforms.envMap.value = m, u.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = s.backgroundBlurriness, h === m && d === m.version && f === t.toneMapping || (u.material.needsUpdate = !0, h = m, d = m.version, f = t.toneMapping), u.layers.enableAll(), i.unshift(u, u.geometry, u.material, 0, 0, null)) : m && m.isTexture && (void 0 === l && (l = new d_(new O_(2, 2), new y_({
                        name: "BackgroundMaterial",
                        uniforms: m_(N_.background.uniforms),
                        vertexShader: N_.background.vertexShader,
                        fragmentShader: N_.background.fragmentShader,
                        side: xm,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), r.update(l)), l.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), l.material.uniforms.uvTransform.value.copy(m.matrix), h === m && d === m.version && f === t.toneMapping || (l.material.needsUpdate = !0, h = m, d = m.version, f = t.toneMapping), l.layers.enableAll(), i.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }

        function U_(t, e, n, i) {
            const r = t.getParameter(34921),
                s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                o = i.isWebGL2 || null !== s,
                a = {},
                l = f(null);
            let u = l,
                c = !1;

            function h(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }

            function d(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }

            function f(t) {
                const e = [],
                    n = [],
                    i = [];
                for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function p() {
                const t = u.newAttributes;
                for (let e = 0, n = t.length; e < n; e++) t[e] = 0
            }

            function m(t) {
                g(t, 0)
            }

            function g(n, r) {
                const s = u.newAttributes,
                    o = u.enabledAttributes,
                    a = u.attributeDivisors;
                s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r)
            }

            function v() {
                const e = u.newAttributes,
                    n = u.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
            }

            function y(e, n, r, s, o, a) {
                !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a)
            }

            function b() {
                _(), c = !0, u !== l && (u = l, h(u.object))
            }

            function _() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: function (r, l, d, b, _) {
                    let x = !1;
                    if (o) {
                        const e = function (e, n, r) {
                            const o = !0 === r.wireframe;
                            let l = a[e.id];
                            void 0 === l && (l = {}, a[e.id] = l);
                            let u = l[n.id];
                            void 0 === u && (u = {}, l[n.id] = u);
                            let c = u[o];
                            return void 0 === c && (c = f(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), u[o] = c), c
                        }(b, d, l);
                        u !== e && (u = e, h(u.object)), x = function (t, e, n, i) {
                            const r = u.attributes,
                                s = e.attributes;
                            let o = 0;
                            const a = n.getAttributes();
                            for (const e in a)
                                if (a[e].location >= 0) {
                                    const n = r[e];
                                    let i = s[e];
                                    if (void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (i = t.instanceColor)), void 0 === n) return !0;
                                    if (n.attribute !== i) return !0;
                                    if (i && n.data !== i.data) return !0;
                                    o++
                                } return u.attributesNum !== o || u.index !== i
                        }(r, b, d, _), x && function (t, e, n, i) {
                            const r = {},
                                s = e.attributes;
                            let o = 0;
                            const a = n.getAttributes();
                            for (const e in a)
                                if (a[e].location >= 0) {
                                    let n = s[e];
                                    void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                                    const i = {};
                                    i.attribute = n, n && n.data && (i.data = n.data), r[e] = i, o++
                                } u.attributes = r, u.attributesNum = o, u.index = i
                        }(r, b, d, _)
                    } else {
                        const t = !0 === l.wireframe;
                        u.geometry === b.id && u.program === d.id && u.wireframe === t || (u.geometry = b.id, u.program = d.id, u.wireframe = t, x = !0)
                    }
                    null !== _ && n.update(_, 34963), (x || c) && (c = !1, function (r, s, o, a) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        p();
                        const l = a.attributes,
                            u = o.getAttributes(),
                            c = s.defaultAttributeValues;
                        for (const e in u) {
                            const i = u[e];
                            if (i.location >= 0) {
                                let s = l[e];
                                if (void 0 === s && ("instanceMatrix" === e && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
                                    const e = s.normalized,
                                        o = s.itemSize,
                                        l = n.get(s);
                                    if (void 0 === l) continue;
                                    const u = l.buffer,
                                        c = l.type,
                                        h = l.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data,
                                            l = n.stride,
                                            d = s.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < i.locationSize; t++) g(i.location + t, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < i.locationSize; t++) m(i.location + t);
                                        t.bindBuffer(34962, u);
                                        for (let t = 0; t < i.locationSize; t++) y(i.location + t, o / i.locationSize, c, e, l * h, (d + o / i.locationSize * t) * h)
                                    } else {
                                        if (s.isInstancedBufferAttribute) {
                                            for (let t = 0; t < i.locationSize; t++) g(i.location + t, s.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)
                                        } else
                                            for (let t = 0; t < i.locationSize; t++) m(i.location + t);
                                        t.bindBuffer(34962, u);
                                        for (let t = 0; t < i.locationSize; t++) y(i.location + t, o / i.locationSize, c, e, o * h, o / i.locationSize * t * h)
                                    }
                                } else if (void 0 !== c) {
                                    const n = c[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(i.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(i.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(i.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(i.location, n)
                                    }
                                }
                            }
                        }
                        v()
                    }(r, l, d, b), null !== _ && t.bindBuffer(34963, n.get(_).buffer))
                },
                reset: b,
                resetDefaultState: _,
                dispose: function () {
                    b();
                    for (const t in a) {
                        const e = a[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) d(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete a[t]
                    }
                },
                releaseStatesOfGeometry: function (t) {
                    if (void 0 === a[t.id]) return;
                    const e = a[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) d(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete a[t.id]
                },
                releaseStatesOfProgram: function (t) {
                    for (const e in a) {
                        const n = a[e];
                        if (void 0 === n[t.id]) continue;
                        const i = n[t.id];
                        for (const t in i) d(i[t].object), delete i[t];
                        delete n[t.id]
                    }
                },
                initAttributes: p,
                enableAttribute: m,
                disableUnusedAttributes: v
            }
        }

        function B_(t, e, n, i) {
            const r = i.isWebGL2;
            let s;
            this.setMode = function (t) {
                s = t
            }, this.render = function (e, i) {
                t.drawArrays(s, e, i), n.update(i, s, 1)
            }, this.renderInstances = function (i, o, a) {
                if (0 === a) return;
                let l, u;
                if (r) l = t, u = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[u](s, i, o, a), n.update(o, s, a)
            }
        }

        function j_(t, e, n) {
            let i;

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let o = void 0 !== n.precision ? n.precision : "highp";
            const a = r(o);
            a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
            const l = s || e.has("WEBGL_draw_buffers"),
                u = !0 === n.logarithmicDepthBuffer,
                c = t.getParameter(34930),
                h = t.getParameter(35660),
                d = t.getParameter(3379),
                f = t.getParameter(34076),
                p = t.getParameter(34921),
                m = t.getParameter(36347),
                g = t.getParameter(36348),
                v = t.getParameter(36349),
                y = h > 0,
                b = s || e.has("OES_texture_float");
            return {
                isWebGL2: s,
                drawBuffers: l,
                getMaxAnisotropy: function () {
                    if (void 0 !== i) return i;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: u,
                maxTextures: c,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: f,
                maxAttributes: p,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: b,
                floatVertexTextures: y && b,
                maxSamples: s ? t.getParameter(36183) : 0
            }
        }

        function H_(t) {
            const e = this;
            let n = null,
                i = 0,
                r = !1,
                s = !1;
            const o = new C_,
                a = new qv,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function u() {
                l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
            }

            function c(t, n, i, r) {
                const s = null !== t ? t.length : 0;
                let u = null;
                if (0 !== s) {
                    if (u = l.value, !0 !== r || null === u) {
                        const e = i + 4 * s,
                            r = n.matrixWorldInverse;
                        a.getNormalMatrix(r), (null === u || u.length < e) && (u = new Float32Array(e));
                        for (let e = 0, n = i; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(u, n), u[n + 3] = o.constant
                    }
                    l.value = u, l.needsUpdate = !0
                }
                return e.numPlanes = s, e.numIntersection = 0, u
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, s) {
                const o = 0 !== t.length || e || 0 !== i || r;
                return r = e, n = c(t, s, 0), i = t.length, o
            }, this.beginShadows = function () {
                s = !0, c(null)
            }, this.endShadows = function () {
                s = !1, u()
            }, this.setState = function (e, o, a) {
                const h = e.clippingPlanes,
                    d = e.clipIntersection,
                    f = e.clipShadows,
                    p = t.get(e);
                if (!r || null === h || 0 === h.length || s && !f) s ? c(null) : u();
                else {
                    const t = s ? 0 : i,
                        e = 4 * t;
                    let r = p.clippingState || null;
                    l.value = r, r = c(h, o, e, a);
                    for (let t = 0; t !== e; ++t) r[t] = n[t];
                    p.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function V_(t) {
            let e = new WeakMap;

            function n(t, e) {
                return e === hg ? t.mapping = ug : e === dg && (t.mapping = cg), t
            }

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }
            return {
                get: function (r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                        const s = r.mapping;
                        if (s === hg || s === dg) {
                            if (e.has(r)) return n(e.get(r).texture, r.mapping);
                            {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const o = new S_(s.height / 2);
                                    return o.fromEquirectangularTexture(t, r), e.set(r, o), r.addEventListener("dispose", i), n(o.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function () {
                    e = new WeakMap
                }
            }
        }
        N_.physical = {
            uniforms: g_([N_.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new Xv(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new ay(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new Xv
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new ay(0)
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularColor: {
                    value: new ay(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                }
            }]),
            vertexShader: I_.meshphysical_vert,
            fragmentShader: I_.meshphysical_frag
        };
        class G_ extends b_ {
            constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            }
            setViewOffset(t, e, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                let r = n - t,
                    s = n + t,
                    o = i + e,
                    a = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }
        const W_ = [.125, .215, .35, .446, .526, .582],
            $_ = new G_,
            X_ = new ay;
        let q_ = null;
        const Y_ = (1 + Math.sqrt(5)) / 2,
            K_ = 1 / Y_,
            J_ = [new by(1, 1, 1), new by(-1, 1, 1), new by(1, 1, -1), new by(-1, 1, -1), new by(0, Y_, K_), new by(0, Y_, -K_), new by(K_, 0, Y_), new by(-K_, 0, Y_), new by(Y_, K_, 0), new by(-Y_, K_, 0)];
        class Z_ {
            constructor(t) {
                this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e = 0, n = .1, i = 100) {
                q_ = this._renderer.getRenderTarget(), this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0, this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
            }
            fromEquirectangular(t, e = null) {
                return this._fromTexture(t, e)
            }
            fromCubemap(t, e = null) {
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = nx(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = ex(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(t) {
                this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget(q_), t.scissorTest = !1, tx(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                t.mapping === ug || t.mapping === cg ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), q_ = this._renderer.getRenderTarget();
                const n = e || this._allocateTargets();
                return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const t = 3 * Math.max(this._cubeSize, 112),
                    e = 4 * this._cubeSize,
                    n = {
                        magFilter: _g,
                        minFilter: _g,
                        generateMipmaps: !1,
                        type: Pg,
                        format: Fg,
                        encoding: xv,
                        depthBuffer: !1
                    },
                    i = Q_(t, e, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Q_(t, e, n);
                    const {
                        _lodMax: i
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function (t) {
                        const e = [],
                            n = [],
                            i = [];
                        let r = t;
                        const s = t - 4 + 1 + W_.length;
                        for (let o = 0; o < s; o++) {
                            const s = Math.pow(2, r);
                            n.push(s);
                            let a = 1 / s;
                            o > t - 4 ? a = W_[o - t + 4 - 1] : 0 === o && (a = 0), i.push(a);
                            const l = 1 / (s - 2),
                                u = -l,
                                c = 1 + l,
                                h = [u, u, c, u, c, c, u, u, c, c, u, c],
                                d = 6,
                                f = 6,
                                p = 3,
                                m = 2,
                                g = 1,
                                v = new Float32Array(p * f * d),
                                y = new Float32Array(m * f * d),
                                b = new Float32Array(g * f * d);
                            for (let t = 0; t < d; t++) {
                                const e = t % 3 * 2 / 3 - 1,
                                    n = t > 2 ? 0 : -1,
                                    i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                v.set(i, p * f * t), y.set(h, m * f * t);
                                const r = [t, t, t, t, t, t];
                                b.set(r, g * f * t)
                            }
                            const _ = new qb;
                            _.setAttribute("position", new Nb(v, p)), _.setAttribute("uv", new Nb(y, m)), _.setAttribute("faceIndex", new Nb(b, g)), e.push(_), r > 4 && r--
                        }
                        return {
                            lodPlanes: e,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)), this._blurMaterial = function (t, e, n) {
                        const i = new Float32Array(20),
                            r = new by(0, 1, 0);
                        return new y_({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / e,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${t}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: i
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: r
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: Sm,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(i, t, e)
                }
                return i
            }
            _compileMaterial(t) {
                const e = new d_(this._lodPlanes[0], t);
                this._renderer.compile(e, $_)
            }
            _sceneToCubeUV(t, e, n, i) {
                const r = new __(90, 1, e, n),
                    s = [1, -1, 1, 1, 1, 1],
                    o = [1, 1, 1, -1, -1, -1],
                    a = this._renderer,
                    l = a.autoClear,
                    u = a.toneMapping;
                a.getClearColor(X_), a.toneMapping = ig, a.autoClear = !1;
                const c = new Ob({
                    name: "PMREM.Background",
                    side: wm,
                    depthWrite: !1,
                    depthTest: !1
                }),
                    h = new d_(new p_, c);
                let d = !1;
                const f = t.background;
                f ? f.isColor && (c.color.copy(f), t.background = null, d = !0) : (c.color.copy(X_), d = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 === n ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e]));
                    const l = this._cubeSize;
                    tx(i, n * l, e > 2 ? l : 0, l, l), a.setRenderTarget(i), d && a.render(h, r), a.render(t, r)
                }
                h.geometry.dispose(), h.material.dispose(), a.toneMapping = u, a.autoClear = l, t.background = f
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer,
                    i = t.mapping === ug || t.mapping === cg;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = nx()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = ex());
                const r = i ? this._cubemapMaterial : this._equirectMaterial,
                    s = new d_(this._lodPlanes[0], r);
                r.uniforms.envMap.value = t;
                const o = this._cubeSize;
                tx(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(s, $_)
            }
            _applyPMREM(t) {
                const e = this._renderer,
                    n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < this._lodPlanes.length; e++) {
                    const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                        i = J_[(e - 1) % J_.length];
                    this._blur(t, e - 1, e, n, i)
                }
                e.autoClear = n
            }
            _blur(t, e, n, i, r) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
            }
            _halfBlur(t, e, n, i, r, s, o) {
                const a = this._renderer,
                    l = this._blurMaterial;
                "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                const u = new d_(this._lodPlanes[i], l),
                    c = l.uniforms,
                    h = this._sizeLods[n] - 1,
                    d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                    f = r / d,
                    p = isFinite(r) ? 1 + Math.floor(3 * f) : 20;
                p > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let t = 0; t < 20; ++t) {
                    const e = t / f,
                        n = Math.exp(-e * e / 2);
                    m.push(n), 0 === t ? g += n : t < p && (g += 2 * n)
                }
                for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                c.envMap.value = t.texture, c.samples.value = p, c.weights.value = m, c.latitudinal.value = "latitudinal" === s, o && (c.poleAxis.value = o);
                const {
                    _lodMax: v
                } = this;
                c.dTheta.value = d, c.mipInt.value = v - n;
                const y = this._sizeLods[i];
                tx(e, 3 * y * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y), a.setRenderTarget(e), a.render(u, $_)
            }
        }

        function Q_(t, e, n) {
            const i = new my(t, e, n);
            return i.texture.mapping = fg, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
        }

        function tx(t, e, n, i, r) {
            t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
        }

        function ex() {
            return new y_({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: Sm,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function nx() {
            return new y_({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: Sm,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function ix(t) {
            let e = new WeakMap,
                n = null;

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }
            return {
                get: function (r) {
                    if (r && r.isTexture) {
                        const s = r.mapping,
                            o = s === hg || s === dg,
                            a = s === ug || s === cg;
                        if (o || a) {
                            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                r.needsPMREMUpdate = !1;
                                let i = e.get(r);
                                return null === n && (n = new Z_(t)), i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
                            }
                            if (e.has(r)) return e.get(r).texture;
                            {
                                const s = r.image;
                                if (o && s && s.height > 0 || a && s && function (t) {
                                    let e = 0;
                                    for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                    return 6 === e
                                }(s)) {
                                    null === n && (n = new Z_(t));
                                    const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                    return e.set(r, s), r.addEventListener("dispose", i), s.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function () {
                    e = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function rx(t) {
            const e = {};

            function n(n) {
                if (void 0 !== e[n]) return e[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return e[n] = i, i
            }
            return {
                has: function (t) {
                    return null !== n(t)
                },
                init: function (t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                },
                get: function (t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                }
            }
        }

        function sx(t, e, n, i) {
            const r = {},
                s = new WeakMap;

            function o(t) {
                const a = t.target;
                null !== a.index && e.remove(a.index);
                for (const t in a.attributes) e.remove(a.attributes[t]);
                a.removeEventListener("dispose", o), delete r[a.id];
                const l = s.get(a);
                l && (e.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
            }

            function a(t) {
                const n = [],
                    i = t.index,
                    r = t.attributes.position;
                let o = 0;
                if (null !== i) {
                    const t = i.array;
                    o = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0],
                            r = t[e + 1],
                            s = t[e + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    const t = r.array;
                    o = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0,
                            i = e + 1,
                            r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
                const a = new (Yv(n) ? Ub : zb)(n, 1);
                a.version = o;
                const l = s.get(t);
                l && e.remove(l), s.set(t, a)
            }
            return {
                get: function (t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", o), r[e.id] = !0, n.memory.geometries++), e
                },
                update: function (t) {
                    const n = t.attributes;
                    for (const t in n) e.update(n[t], 34962);
                    const i = t.morphAttributes;
                    for (const t in i) {
                        const n = i[t];
                        for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
                    }
                },
                getWireframeAttribute: function (t) {
                    const e = s.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && a(t)
                    } else a(t);
                    return s.get(t)
                }
            }
        }

        function ox(t, e, n, i) {
            const r = i.isWebGL2;
            let s, o, a;
            this.setMode = function (t) {
                s = t
            }, this.setIndex = function (t) {
                o = t.type, a = t.bytesPerElement
            }, this.render = function (e, i) {
                t.drawElements(s, i, o, e * a), n.update(i, s, 1)
            }, this.renderInstances = function (i, l, u) {
                if (0 === u) return;
                let c, h;
                if (r) c = t, h = "drawElementsInstanced";
                else if (c = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                c[h](s, l, o, i * a, u), n.update(l, s, u)
            }
        }

        function ax(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function () {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function (t, n, i) {
                    switch (e.calls++, n) {
                        case 4:
                            e.triangles += i * (t / 3);
                            break;
                        case 1:
                            e.lines += i * (t / 2);
                            break;
                        case 3:
                            e.lines += i * (t - 1);
                            break;
                        case 2:
                            e.lines += i * t;
                            break;
                        case 0:
                            e.points += i * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }

        function lx(t, e) {
            return t[0] - e[0]
        }

        function ux(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function cx(t, e, n) {
            const i = {},
                r = new Float32Array(8),
                s = new WeakMap,
                o = new py,
                a = [];
            for (let t = 0; t < 8; t++) a[t] = [t, 0];
            return {
                update: function (l, u, c, h) {
                    const d = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const f = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
                            p = void 0 !== f ? f.length : 0;
                        let m = s.get(u);
                        if (void 0 === m || m.count !== p) {
                            void 0 !== m && m.texture.dispose();
                            const y = void 0 !== u.morphAttributes.position,
                                b = void 0 !== u.morphAttributes.normal,
                                _ = void 0 !== u.morphAttributes.color,
                                x = u.morphAttributes.position || [],
                                w = u.morphAttributes.normal || [],
                                M = u.morphAttributes.color || [];
                            let S = 0;
                            !0 === y && (S = 1), !0 === b && (S = 2), !0 === _ && (S = 3);
                            let T = u.attributes.position.count * S,
                                E = 1;
                            T > e.maxTextureSize && (E = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
                            const D = new Float32Array(T * E * 4 * p),
                                C = new gy(D, T, E, p);
                            C.type = Ag, C.needsUpdate = !0;
                            const A = 4 * S;
                            for (let L = 0; L < p; L++) {
                                const R = x[L],
                                    k = w[L],
                                    O = M[L],
                                    I = T * E * 4 * L;
                                for (let F = 0; F < R.count; F++) {
                                    const N = F * A;
                                    !0 === y && (o.fromBufferAttribute(R, F), D[I + N + 0] = o.x, D[I + N + 1] = o.y, D[I + N + 2] = o.z, D[I + N + 3] = 0), !0 === b && (o.fromBufferAttribute(k, F), D[I + N + 4] = o.x, D[I + N + 5] = o.y, D[I + N + 6] = o.z, D[I + N + 7] = 0), !0 === _ && (o.fromBufferAttribute(O, F), D[I + N + 8] = o.x, D[I + N + 9] = o.y, D[I + N + 10] = o.z, D[I + N + 11] = 4 === O.itemSize ? o.w : 1)
                                }
                            }

                            function P() {
                                C.dispose(), s.delete(u), u.removeEventListener("dispose", P)
                            }
                            m = {
                                count: p,
                                texture: C,
                                size: new Xv(T, E)
                            }, s.set(u, m), u.addEventListener("dispose", P)
                        }
                        let g = 0;
                        for (let z = 0; z < d.length; z++) g += d[z];
                        const v = u.morphTargetsRelative ? 1 : 1 - g;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", v), h.getUniforms().setValue(t, "morphTargetInfluences", d), h.getUniforms().setValue(t, "morphTargetsTexture", m.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", m.size)
                    } else {
                        const U = void 0 === d ? 0 : d.length;
                        let B = i[u.id];
                        if (void 0 === B || B.length !== U) {
                            B = [];
                            for (let W = 0; W < U; W++) B[W] = [W, 0];
                            i[u.id] = B
                        }
                        for (let $ = 0; $ < U; $++) {
                            const X = B[$];
                            X[0] = $, X[1] = d[$]
                        }
                        B.sort(ux);
                        for (let q = 0; q < 8; q++) q < U && B[q][1] ? (a[q][0] = B[q][0], a[q][1] = B[q][1]) : (a[q][0] = Number.MAX_SAFE_INTEGER, a[q][1] = 0);
                        a.sort(lx);
                        const j = u.morphAttributes.position,
                            H = u.morphAttributes.normal;
                        let V = 0;
                        for (let Y = 0; Y < 8; Y++) {
                            const K = a[Y],
                                J = K[0],
                                Z = K[1];
                            J !== Number.MAX_SAFE_INTEGER && Z ? (j && u.getAttribute("morphTarget" + Y) !== j[J] && u.setAttribute("morphTarget" + Y, j[J]), H && u.getAttribute("morphNormal" + Y) !== H[J] && u.setAttribute("morphNormal" + Y, H[J]), r[Y] = Z, V += Z) : (j && !0 === u.hasAttribute("morphTarget" + Y) && u.deleteAttribute("morphTarget" + Y), H && !0 === u.hasAttribute("morphNormal" + Y) && u.deleteAttribute("morphNormal" + Y), r[Y] = 0)
                        }
                        const G = u.morphTargetsRelative ? 1 : 1 - V;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", G), h.getUniforms().setValue(t, "morphTargetInfluences", r)
                    }
                }
            }
        }

        function hx(t, e, n, i) {
            let r = new WeakMap;

            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function (t) {
                    const o = i.render.frame,
                        a = t.geometry,
                        l = e.get(t, a);
                    return r.get(l) !== o && (e.update(l), r.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                },
                dispose: function () {
                    r = new WeakMap
                }
            }
        }
        const dx = new fy,
            fx = new gy,
            px = new vy,
            mx = new M_,
            gx = [],
            vx = [],
            yx = new Float32Array(16),
            bx = new Float32Array(9),
            _x = new Float32Array(4);

        function xx(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0) return t;
            const r = e * n;
            let s = gx[r];
            if (void 0 === s && (s = new Float32Array(r), gx[r] = s), 0 !== e) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
            }
            return s
        }

        function wx(t, e) {
            if (t.length !== e.length) return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n]) return !1;
            return !0
        }

        function Mx(t, e) {
            for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
        }

        function Sx(t, e) {
            let n = vx[e];
            void 0 === n && (n = new Int32Array(e), vx[e] = n);
            for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
            return n
        }

        function Tx(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function Ex(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (wx(n, e)) return;
                t.uniform2fv(this.addr, e), Mx(n, e)
            }
        }

        function Dx(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (wx(n, e)) return;
                t.uniform3fv(this.addr, e), Mx(n, e)
            }
        }

        function Cx(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (wx(n, e)) return;
                t.uniform4fv(this.addr, e), Mx(n, e)
            }
        }

        function Ax(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (wx(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Mx(n, e)
            } else {
                if (wx(n, i)) return;
                _x.set(i), t.uniformMatrix2fv(this.addr, !1, _x), Mx(n, i)
            }
        }

        function Px(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (wx(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Mx(n, e)
            } else {
                if (wx(n, i)) return;
                bx.set(i), t.uniformMatrix3fv(this.addr, !1, bx), Mx(n, i)
            }
        }

        function Lx(t, e) {
            const n = this.cache,
                i = e.elements;
            if (void 0 === i) {
                if (wx(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Mx(n, e)
            } else {
                if (wx(n, i)) return;
                yx.set(i), t.uniformMatrix4fv(this.addr, !1, yx), Mx(n, i)
            }
        }

        function Rx(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function kx(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (wx(n, e)) return;
                t.uniform2iv(this.addr, e), Mx(n, e)
            }
        }

        function Ox(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (wx(n, e)) return;
                t.uniform3iv(this.addr, e), Mx(n, e)
            }
        }

        function Ix(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (wx(n, e)) return;
                t.uniform4iv(this.addr, e), Mx(n, e)
            }
        }

        function Fx(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function Nx(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (wx(n, e)) return;
                t.uniform2uiv(this.addr, e), Mx(n, e)
            }
        }

        function zx(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else {
                if (wx(n, e)) return;
                t.uniform3uiv(this.addr, e), Mx(n, e)
            }
        }

        function Ux(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (wx(n, e)) return;
                t.uniform4uiv(this.addr, e), Mx(n, e)
            }
        }

        function Bx(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(e || dx, r)
        }

        function jx(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || px, r)
        }

        function Hx(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || mx, r)
        }

        function Vx(t, e, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || fx, r)
        }

        function Gx(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function Wx(t, e) {
            const n = xx(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function $x(t, e) {
            const n = xx(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function Xx(t, e) {
            const n = xx(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function qx(t, e) {
            const n = xx(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function Yx(t, e) {
            const n = xx(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function Kx(t, e) {
            const n = xx(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function Jx(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Zx(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function Qx(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function tw(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function ew(t, e) {
            t.uniform1uiv(this.addr, e)
        }

        function nw(t, e) {
            t.uniform2uiv(this.addr, e)
        }

        function iw(t, e) {
            t.uniform3uiv(this.addr, e)
        }

        function rw(t, e) {
            t.uniform4uiv(this.addr, e)
        }

        function sw(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Sx(n, r);
            wx(i, s) || (t.uniform1iv(this.addr, s), Mx(i, s));
            for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || dx, s[t])
        }

        function ow(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Sx(n, r);
            wx(i, s) || (t.uniform1iv(this.addr, s), Mx(i, s));
            for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || px, s[t])
        }

        function aw(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Sx(n, r);
            wx(i, s) || (t.uniform1iv(this.addr, s), Mx(i, s));
            for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || mx, s[t])
        }

        function lw(t, e, n) {
            const i = this.cache,
                r = e.length,
                s = Sx(n, r);
            wx(i, s) || (t.uniform1iv(this.addr, s), Mx(i, s));
            for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || fx, s[t])
        }
        class uw {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return Tx;
                        case 35664:
                            return Ex;
                        case 35665:
                            return Dx;
                        case 35666:
                            return Cx;
                        case 35674:
                            return Ax;
                        case 35675:
                            return Px;
                        case 35676:
                            return Lx;
                        case 5124:
                        case 35670:
                            return Rx;
                        case 35667:
                        case 35671:
                            return kx;
                        case 35668:
                        case 35672:
                            return Ox;
                        case 35669:
                        case 35673:
                            return Ix;
                        case 5125:
                            return Fx;
                        case 36294:
                            return Nx;
                        case 36295:
                            return zx;
                        case 36296:
                            return Ux;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Bx;
                        case 35679:
                        case 36299:
                        case 36307:
                            return jx;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Hx;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Vx
                    }
                }(e.type)
            }
        }
        class cw {
            constructor(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return Gx;
                        case 35664:
                            return Wx;
                        case 35665:
                            return $x;
                        case 35666:
                            return Xx;
                        case 35674:
                            return qx;
                        case 35675:
                            return Yx;
                        case 35676:
                            return Kx;
                        case 5124:
                        case 35670:
                            return Jx;
                        case 35667:
                        case 35671:
                            return Zx;
                        case 35668:
                        case 35672:
                            return Qx;
                        case 35669:
                        case 35673:
                            return tw;
                        case 5125:
                            return ew;
                        case 36294:
                            return nw;
                        case 36295:
                            return iw;
                        case 36296:
                            return rw;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return sw;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ow;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return aw;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return lw
                    }
                }(e.type)
            }
        }
        class hw {
            constructor(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            setValue(t, e, n) {
                const i = this.seq;
                for (let r = 0, s = i.length; r !== s; ++r) {
                    const s = i[r];
                    s.setValue(t, e[s.id], n)
                }
            }
        }
        const dw = /(\w+)(\])?(\[|\.)?/g;

        function fw(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function pw(t, e, n) {
            const i = t.name,
                r = i.length;
            for (dw.lastIndex = 0; ;) {
                const s = dw.exec(i),
                    o = dw.lastIndex;
                let a = s[1];
                const l = "]" === s[2],
                    u = s[3];
                if (l && (a |= 0), void 0 === u || "[" === u && o + 2 === r) {
                    fw(n, void 0 === u ? new uw(a, t, e) : new cw(a, t, e));
                    break
                } {
                    let t = n.map[a];
                    void 0 === t && (t = new hw(a), fw(n, t)), n = t
                }
            }
        }
        class mw {
            constructor(t, e) {
                this.seq = [], this.map = {};
                const n = t.getProgramParameter(e, 35718);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i);
                    pw(n, t.getUniformLocation(e, n.name), this)
                }
            }
            setValue(t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }
            setOptional(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }
            static upload(t, e, n, i) {
                for (let r = 0, s = e.length; r !== s; ++r) {
                    const s = e[r],
                        o = n[s.id];
                    !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                }
            }
            static seqWithValue(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            }
        }

        function gw(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n), t.compileShader(i), i
        }
        let vw = 0;

        function yw(t, e, n) {
            const i = t.getShaderParameter(e, 35713),
                r = t.getShaderInfoLog(e).trim();
            if (i && "" === r) return "";
            const s = /ERROR: 0:(\d+)/.exec(r);
            if (s) {
                const i = parseInt(s[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function (t, e) {
                    const n = t.split("\n"),
                        i = [],
                        r = Math.max(e - 6, 0),
                        s = Math.min(e + 6, n.length);
                    for (let t = r; t < s; t++) {
                        const r = t + 1;
                        i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`)
                    }
                    return i.join("\n")
                }(t.getShaderSource(e), i)
            }
            return r
        }

        function bw(t, e) {
            const n = function (t) {
                switch (t) {
                    case xv:
                        return ["Linear", "( value )"];
                    case wv:
                        return ["sRGB", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                }
            }(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function _w(t, e) {
            let n;
            switch (e) {
                case rg:
                    n = "Linear";
                    break;
                case sg:
                    n = "Reinhard";
                    break;
                case og:
                    n = "OptimizedCineon";
                    break;
                case ag:
                    n = "ACESFilmic";
                    break;
                case lg:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function xw(t) {
            return "" !== t
        }

        function ww(t, e) {
            const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function Mw(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Sw = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Tw(t) {
            return t.replace(Sw, Ew)
        }

        function Ew(t, e) {
            const n = I_[e];
            if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
            return Tw(n)
        }
        const Dw = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Cw(t) {
            return t.replace(Dw, Aw)
        }

        function Aw(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }

        function Pw(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function Lw(t, e, n, i) {
            const r = t.getContext(),
                s = n.defines;
            let o = n.vertexShader,
                a = n.fragmentShader;
            const l = function (t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return t.shadowMapType === ym ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === bm ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === _m && (e = "SHADOWMAP_TYPE_VSM"), e
            }(n),
                u = function (t) {
                    let e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case ug:
                        case cg:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case fg:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(n),
                c = function (t) {
                    let e = "ENVMAP_MODE_REFLECTION";
                    return t.envMap && t.envMapMode === cg && (e = "ENVMAP_MODE_REFRACTION"), e
                }(n),
                h = function (t) {
                    let e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case tg:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case eg:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case ng:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                d = function (t) {
                    const e = t.envMapCubeUVHeight;
                    if (null === e) return null;
                    const n = Math.log2(e) - 2,
                        i = 1 / e;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }(n),
                f = n.isWebGL2 ? "" : function (t) {
                    return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xw).join("\n")
                }(n),
                p = function (t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        !1 !== i && e.push("#define " + n + " " + i)
                    }
                    return e.join("\n")
                }(s),
                m = r.createProgram();
            let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = [p].filter(xw).join("\n"), g.length > 0 && (g += "\n"), v = [f, p].filter(xw).join("\n"), v.length > 0 && (v += "\n")) : (g = [Pw(n), "#define SHADER_NAME " + n.shaderName, p, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(xw).join("\n"), v = [f, Pw(n), "#define SHADER_NAME " + n.shaderName, p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== ig ? "#define TONE_MAPPING" : "", n.toneMapping !== ig ? I_.tonemapping_pars_fragment : "", n.toneMapping !== ig ? _w("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", I_.encodings_pars_fragment, bw("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(xw).join("\n")), o = Tw(o), o = ww(o, n), o = Mw(o, n), a = Tw(a), a = ww(a, n), a = Mw(a, n), o = Cw(o), a = Cw(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === Pv ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Pv ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const b = y + v + a,
                _ = gw(r, 35633, y + g + o),
                x = gw(r, 35632, b);
            if (r.attachShader(m, _), r.attachShader(m, x), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
                const t = r.getProgramInfoLog(m).trim(),
                    e = r.getShaderInfoLog(_).trim(),
                    n = r.getShaderInfoLog(x).trim();
                let i = !0,
                    s = !0;
                if (!1 === r.getProgramParameter(m, 35714)) {
                    i = !1;
                    const e = yw(r, _, "vertex"),
                        n = yw(r, x, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
                s && (this.diagnostics = {
                    runnable: i,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: g
                    },
                    fragmentShader: {
                        log: n,
                        prefix: v
                    }
                })
            }
            let w, M;
            return r.deleteShader(_), r.deleteShader(x), this.getUniforms = function () {
                return void 0 === w && (w = new mw(r, m)), w
            }, this.getAttributes = function () {
                return void 0 === M && (M = function (t, e) {
                    const n = {},
                        i = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r),
                            s = i.name;
                        let o = 1;
                        35674 === i.type && (o = 2), 35675 === i.type && (o = 3), 35676 === i.type && (o = 4), n[s] = {
                            type: i.type,
                            location: t.getAttribLocation(e, s),
                            locationSize: o
                        }
                    }
                    return n
                }(r, m)), M
            }, this.destroy = function () {
                i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
            }, this.name = n.shaderName, this.id = vw++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = _, this.fragmentShader = x, this
        }
        let Rw = 0;
        class kw {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader,
                    n = t.fragmentShader,
                    i = this._getShaderStage(e),
                    r = this._getShaderStage(n),
                    s = this._getShaderCacheForMaterial(t);
                return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                return this.materialCache.delete(t), this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                let n = e.get(t);
                return void 0 === n && (n = new Set, e.set(t, n)), n
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                let n = e.get(t);
                return void 0 === n && (n = new Ow(t), e.set(t, n)), n
            }
        }
        class Ow {
            constructor(t) {
                this.id = Rw++, this.code = t, this.usedTimes = 0
            }
        }

        function Iw(t, e, n, i, r, s, o) {
            const a = new ob,
                l = new kw,
                u = [],
                c = r.isWebGL2,
                h = r.logarithmicDepthBuffer,
                d = r.vertexTextures;
            let f = r.precision;
            const p = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            return {
                getParameters: function (s, a, u, m, g) {
                    const v = m.fog,
                        y = g.geometry,
                        b = s.isMeshStandardMaterial ? m.environment : null,
                        _ = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b),
                        x = _ && _.mapping === fg ? _.image.height : null,
                        w = p[s.type];
                    null !== s.precision && (f = r.getMaxPrecision(s.precision), f !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", f, "instead."));
                    const M = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                        S = void 0 !== M ? M.length : 0;
                    let T, E, D, C, A = 0;
                    if (void 0 !== y.morphAttributes.position && (A = 1), void 0 !== y.morphAttributes.normal && (A = 2), void 0 !== y.morphAttributes.color && (A = 3), w) {
                        const t = N_[w];
                        T = t.vertexShader, E = t.fragmentShader
                    } else T = s.vertexShader, E = s.fragmentShader, l.update(s), D = l.getVertexShaderID(s), C = l.getFragmentShaderID(s);
                    const P = t.getRenderTarget(),
                        L = s.alphaTest > 0,
                        R = s.clearcoat > 0,
                        k = s.iridescence > 0;
                    return {
                        isWebGL2: c,
                        shaderID: w,
                        shaderName: s.type,
                        vertexShader: T,
                        fragmentShader: E,
                        defines: s.defines,
                        customVertexShaderID: D,
                        customFragmentShaderID: C,
                        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                        glslVersion: s.glslVersion,
                        precision: f,
                        instancing: !0 === g.isInstancedMesh,
                        instancingColor: !0 === g.isInstancedMesh && null !== g.instanceColor,
                        supportsVertexTextures: d,
                        outputEncoding: null === P ? t.outputEncoding : !0 === P.isXRRenderTarget ? P.texture.encoding : xv,
                        map: !!s.map,
                        matcap: !!s.matcap,
                        envMap: !!_,
                        envMapMode: _ && _.mapping,
                        envMapCubeUVHeight: x,
                        lightMap: !!s.lightMap,
                        aoMap: !!s.aoMap,
                        emissiveMap: !!s.emissiveMap,
                        bumpMap: !!s.bumpMap,
                        normalMap: !!s.normalMap,
                        objectSpaceNormalMap: s.normalMapType === Tv,
                        tangentSpaceNormalMap: s.normalMapType === Sv,
                        decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === wv,
                        clearcoat: R,
                        clearcoatMap: R && !!s.clearcoatMap,
                        clearcoatRoughnessMap: R && !!s.clearcoatRoughnessMap,
                        clearcoatNormalMap: R && !!s.clearcoatNormalMap,
                        iridescence: k,
                        iridescenceMap: k && !!s.iridescenceMap,
                        iridescenceThicknessMap: k && !!s.iridescenceThicknessMap,
                        displacementMap: !!s.displacementMap,
                        roughnessMap: !!s.roughnessMap,
                        metalnessMap: !!s.metalnessMap,
                        specularMap: !!s.specularMap,
                        specularIntensityMap: !!s.specularIntensityMap,
                        specularColorMap: !!s.specularColorMap,
                        opaque: !1 === s.transparent && s.blending === Tm,
                        alphaMap: !!s.alphaMap,
                        alphaTest: L,
                        gradientMap: !!s.gradientMap,
                        sheen: s.sheen > 0,
                        sheenColorMap: !!s.sheenColorMap,
                        sheenRoughnessMap: !!s.sheenRoughnessMap,
                        transmission: s.transmission > 0,
                        transmissionMap: !!s.transmissionMap,
                        thicknessMap: !!s.thicknessMap,
                        combine: s.combine,
                        vertexTangents: !!s.normalMap && !!y.attributes.tangent,
                        vertexColors: s.vertexColors,
                        vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                        vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                        uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                        fog: !!v,
                        useFog: !0 === s.fog,
                        fogExp2: v && v.isFogExp2,
                        flatShading: !!s.flatShading,
                        sizeAttenuation: s.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === g.isSkinnedMesh,
                        morphTargets: void 0 !== y.morphAttributes.position,
                        morphNormals: void 0 !== y.morphAttributes.normal,
                        morphColors: void 0 !== y.morphAttributes.color,
                        morphTargetsCount: S,
                        morphTextureStride: A,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numSpotLightMaps: a.spotLightMap.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
                        numClippingPlanes: o.numPlanes,
                        numClipIntersection: o.numIntersection,
                        dithering: s.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: s.toneMapped ? t.toneMapping : ig,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: s.premultipliedAlpha,
                        doubleSided: s.side === Mm,
                        flipSided: s.side === wm,
                        useDepthPacking: !!s.depthPacking,
                        depthPacking: s.depthPacking || 0,
                        index0AttributeName: s.index0AttributeName,
                        extensionDerivatives: s.extensions && s.extensions.derivatives,
                        extensionFragDepth: s.extensions && s.extensions.fragDepth,
                        extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                        extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: c || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: c || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: c || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: s.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function (e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    return !1 === e.isRawShaderMaterial && (function (t, e) {
                        t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
                    }(n, e), function (t, e) {
                        a.disableAll(), e.isWebGL2 && a.enable(0), e.supportsVertexTextures && a.enable(1), e.instancing && a.enable(2), e.instancingColor && a.enable(3), e.map && a.enable(4), e.matcap && a.enable(5), e.envMap && a.enable(6), e.lightMap && a.enable(7), e.aoMap && a.enable(8), e.emissiveMap && a.enable(9), e.bumpMap && a.enable(10), e.normalMap && a.enable(11), e.objectSpaceNormalMap && a.enable(12), e.tangentSpaceNormalMap && a.enable(13), e.clearcoat && a.enable(14), e.clearcoatMap && a.enable(15), e.clearcoatRoughnessMap && a.enable(16), e.clearcoatNormalMap && a.enable(17), e.iridescence && a.enable(18), e.iridescenceMap && a.enable(19), e.iridescenceThicknessMap && a.enable(20), e.displacementMap && a.enable(21), e.specularMap && a.enable(22), e.roughnessMap && a.enable(23), e.metalnessMap && a.enable(24), e.gradientMap && a.enable(25), e.alphaMap && a.enable(26), e.alphaTest && a.enable(27), e.vertexColors && a.enable(28), e.vertexAlphas && a.enable(29), e.vertexUvs && a.enable(30), e.vertexTangents && a.enable(31), e.uvsVertexOnly && a.enable(32), t.push(a.mask), a.disableAll(), e.fog && a.enable(0), e.useFog && a.enable(1), e.flatShading && a.enable(2), e.logarithmicDepthBuffer && a.enable(3), e.skinning && a.enable(4), e.morphTargets && a.enable(5), e.morphNormals && a.enable(6), e.morphColors && a.enable(7), e.premultipliedAlpha && a.enable(8), e.shadowMapEnabled && a.enable(9), e.physicallyCorrectLights && a.enable(10), e.doubleSided && a.enable(11), e.flipSided && a.enable(12), e.useDepthPacking && a.enable(13), e.dithering && a.enable(14), e.specularIntensityMap && a.enable(15), e.specularColorMap && a.enable(16), e.transmission && a.enable(17), e.transmissionMap && a.enable(18), e.thicknessMap && a.enable(19), e.sheen && a.enable(20), e.sheenColorMap && a.enable(21), e.sheenRoughnessMap && a.enable(22), e.decodeVideoTexture && a.enable(23), e.opaque && a.enable(24), t.push(a.mask)
                    }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join()
                },
                getUniforms: function (t) {
                    const e = p[t.type];
                    let n;
                    if (e) {
                        const t = N_[e];
                        n = v_.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                },
                acquireProgram: function (e, n) {
                    let i;
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        if (e.cacheKey === n) {
                            i = e, ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Lw(t, n, e, s), u.push(i)), i
                },
                releaseProgram: function (t) {
                    if (0 == --t.usedTimes) {
                        const e = u.indexOf(t);
                        u[e] = u[u.length - 1], u.pop(), t.destroy()
                    }
                },
                releaseShaderCache: function (t) {
                    l.remove(t)
                },
                programs: u,
                dispose: function () {
                    l.dispose()
                }
            }
        }

        function Fw() {
            let t = new WeakMap;
            return {
                get: function (e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                },
                remove: function (e) {
                    t.delete(e)
                },
                update: function (e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function Nw(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function zw(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Uw() {
            const t = [];
            let e = 0;
            const n = [],
                i = [],
                r = [];

            function s(n, i, r, s, o, a) {
                let l = t[e];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: o,
                    group: a
                }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = o, l.group = a), e++, l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function () {
                    e = 0, n.length = 0, i.length = 0, r.length = 0
                },
                push: function (t, e, o, a, l, u) {
                    const c = s(t, e, o, a, l, u);
                    o.transmission > 0 ? i.push(c) : !0 === o.transparent ? r.push(c) : n.push(c)
                },
                unshift: function (t, e, o, a, l, u) {
                    const c = s(t, e, o, a, l, u);
                    o.transmission > 0 ? i.unshift(c) : !0 === o.transparent ? r.unshift(c) : n.unshift(c)
                },
                finish: function () {
                    for (let n = e, i = t.length; n < i; n++) {
                        const e = t[n];
                        if (null === e.id) break;
                        e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                    }
                },
                sort: function (t, e) {
                    n.length > 1 && n.sort(t || Nw), i.length > 1 && i.sort(e || zw), r.length > 1 && r.sort(e || zw)
                }
            }
        }

        function Bw() {
            let t = new WeakMap;
            return {
                get: function (e, n) {
                    const i = t.get(e);
                    let r;
                    return void 0 === i ? (r = new Uw, t.set(e, [r])) : n >= i.length ? (r = new Uw, i.push(r)) : r = i[n], r
                },
                dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function jw() {
            const t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new by,
                                color: new ay
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new by,
                                direction: new by,
                                color: new ay,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new by,
                                color: new ay,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new by,
                                skyColor: new ay,
                                groundColor: new ay
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new ay,
                                position: new by,
                                halfWidth: new by,
                                halfHeight: new by
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        let Hw = 0;

        function Vw(t, e) {
            return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
        }

        function Gw(t, e) {
            const n = new jw,
                i = function () {
                    const t = {};
                    return {
                        get: function (e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Xv
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Xv,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }(),
                r = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0
                };
            for (let t = 0; t < 9; t++) r.probe.push(new by);
            const s = new by,
                o = new Yy,
                a = new Yy;
            return {
                setup: function (s, o) {
                    let a = 0,
                        l = 0,
                        u = 0;
                    for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                    let c = 0,
                        h = 0,
                        d = 0,
                        f = 0,
                        p = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0,
                        b = 0;
                    s.sort(Vw);
                    const _ = !0 !== o ? Math.PI : 1;
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t],
                            o = e.color,
                            x = e.intensity,
                            w = e.distance,
                            M = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) a += o.r * x * _, l += o.g * x * _, u += o.b * x * _;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], x);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * _), e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = M, r.directionalShadowMatrix[c] = e.shadow.matrix, m++
                            }
                            r.directional[c] = t, c++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(o).multiplyScalar(x * _), t.distance = w, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, r.spot[d] = t;
                            const s = e.shadow;
                            if (e.map && (r.spotLightMap[y] = e.map, y++, s.updateMatrices(e), e.castShadow && b++), r.spotLightMatrix[d] = s.matrix, e.castShadow) {
                                const t = i.get(e);
                                t.shadowBias = s.bias, t.shadowNormalBias = s.normalBias, t.shadowRadius = s.radius, t.shadowMapSize = s.mapSize, r.spotShadow[d] = t, r.spotShadowMap[d] = M, v++
                            }
                            d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(o).multiplyScalar(x), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[f] = t, f++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * _), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow,
                                    n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = M, r.pointShadowMatrix[h] = e.shadow.matrix, g++
                            }
                            r.point[h] = t, h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(x * _), t.groundColor.copy(e.groundColor).multiplyScalar(x * _), r.hemi[p] = t, p++
                        }
                    }
                    f > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = F_.LTC_FLOAT_1, r.rectAreaLTC2 = F_.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = F_.LTC_HALF_1, r.rectAreaLTC2 = F_.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a, r.ambient[1] = l, r.ambient[2] = u;
                    const x = r.hash;
                    x.directionalLength === c && x.pointLength === h && x.spotLength === d && x.rectAreaLength === f && x.hemiLength === p && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v && x.numSpotMaps === y || (r.directional.length = c, r.spot.length = d, r.rectArea.length = f, r.point.length = h, r.hemi.length = p, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = v + y - b, r.spotLightMap.length = y, r.numSpotLightShadowsWithMaps = b, x.directionalLength = c, x.pointLength = h, x.spotLength = d, x.rectAreaLength = f, x.hemiLength = p, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = v, x.numSpotMaps = y, r.version = Hw++)
                },
                setupView: function (t, e) {
                    let n = 0,
                        i = 0,
                        l = 0,
                        u = 0,
                        c = 0;
                    const h = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), n++
                        } else if (d.isSpotLight) {
                            const t = r.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), l++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[u];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), a.identity(), o.copy(d.matrixWorld), o.premultiply(h), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), u++
                        } else if (d.isPointLight) {
                            const t = r.point[i];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), i++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[c];
                            t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), c++
                        }
                    }
                },
                state: r
            }
        }

        function Ww(t, e) {
            const n = new Gw(t, e),
                i = [],
                r = [];
            return {
                init: function () {
                    i.length = 0, r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function (t) {
                    n.setup(i, t)
                },
                setupLightsView: function (t) {
                    n.setupView(i, t)
                },
                pushLight: function (t) {
                    i.push(t)
                },
                pushShadow: function (t) {
                    r.push(t)
                }
            }
        }

        function $w(t, e) {
            let n = new WeakMap;
            return {
                get: function (i, r = 0) {
                    const s = n.get(i);
                    let o;
                    return void 0 === s ? (o = new Ww(t, e), n.set(i, [o])) : r >= s.length ? (o = new Ww(t, e), s.push(o)) : o = s[r], o
                },
                dispose: function () {
                    n = new WeakMap
                }
            }
        }
        class Xw extends kb {
            constructor(t) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }
        }
        class qw extends kb {
            constructor(t) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new by, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }
        }
        const Yw = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            Kw = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

        function Jw(t, e, n) {
            let i = new L_;
            const r = new Xv,
                s = new Xv,
                o = new py,
                a = new Xw({
                    depthPacking: Mv
                }),
                l = new qw,
                u = {},
                c = n.maxTextureSize,
                h = {
                    0: wm,
                    1: xm,
                    2: Mm
                },
                d = new y_({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Xv
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: Yw,
                    fragmentShader: Kw
                }),
                f = d.clone();
            f.defines.HORIZONTAL_PASS = 1;
            const p = new qb;
            p.setAttribute("position", new Nb(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const m = new d_(p, d),
                g = this;

            function v(n, i) {
                const s = e.update(m);
                d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), null === n.mapPass && (n.mapPass = new my(r.x, r.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, s, d, m, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, s, f, m, null)
            }

            function y(e, n, i, r, s, o) {
                let c = null;
                const d = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (c = void 0 !== d ? d : !0 === i.isPointLight ? l : a, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
                    const t = c.uuid,
                        e = n.uuid;
                    let i = u[t];
                    void 0 === i && (i = {}, u[t] = i);
                    let r = i[e];
                    void 0 === r && (r = c.clone(), i[e] = r), c = r
                }
                return c.visible = n.visible, c.wireframe = n.wireframe, c.side = o === _m ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], c.alphaMap = n.alphaMap, c.alphaTest = n.alphaTest, c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.displacementMap = n.displacementMap, c.displacementScale = n.displacementScale, c.displacementBias = n.displacementBias, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), c.nearDistance = r, c.farDistance = s), c
            }

            function b(n, r, s, o, a) {
                if (!1 === n.visible) return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === _m) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n),
                        r = n.material;
                    if (Array.isArray(r)) {
                        const e = i.groups;
                        for (let l = 0, u = e.length; l < u; l++) {
                            const u = e[l],
                                c = r[u.materialIndex];
                            if (c && c.visible) {
                                const e = y(n, c, o, s.near, s.far, a);
                                t.renderBufferDirect(s, null, i, e, n, u)
                            }
                        }
                    } else if (r.visible) {
                        const e = y(n, r, o, s.near, s.far, a);
                        t.renderBufferDirect(s, null, i, e, n, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++) b(l[t], r, s, o, a)
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ym, this.render = function (e, n, a) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === e.length) return;
                const l = t.getRenderTarget(),
                    u = t.getActiveCubeFace(),
                    h = t.getActiveMipmapLevel(),
                    d = t.state;
                d.setBlending(Sm), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                for (let l = 0, u = e.length; l < u; l++) {
                    const u = e[l],
                        h = u.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                    r.copy(h.mapSize);
                    const f = h.getFrameExtents();
                    if (r.multiply(f), s.copy(h.mapSize), (r.x > c || r.y > c) && (r.x > c && (s.x = Math.floor(c / f.x), r.x = s.x * f.x, h.mapSize.x = s.x), r.y > c && (s.y = Math.floor(c / f.y), r.y = s.y * f.y, h.mapSize.y = s.y)), null === h.map) {
                        const t = this.type !== _m ? {
                            minFilter: vg,
                            magFilter: vg
                        } : {};
                        h.map = new my(r.x, r.y, t), h.map.texture.name = u.name + ".shadowMap", h.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(h.map), t.clear();
                    const p = h.getViewportCount();
                    for (let t = 0; t < p; t++) {
                        const e = h.getViewport(t);
                        o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), h.updateMatrices(u, t), i = h.getFrustum(), b(n, a, h.camera, u, this.type)
                    } !0 !== h.isPointLightShadow && this.type === _m && v(h, a), h.needsUpdate = !1
                }
                g.needsUpdate = !1, t.setRenderTarget(l, u, h)
            }
        }

        function Zw(t, e, n) {
            const i = n.isWebGL2,
                r = new function () {
                    let e = !1;
                    const n = new py;
                    let i = null;
                    const r = new py(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            i === n || e || (t.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e, i, s, o, a) {
                            !0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n))
                        },
                        reset: function () {
                            e = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                s = new function () {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function (t) {
                            t ? B(2929) : j(2929)
                        },
                        setMask: function (i) {
                            n === i || e || (t.depthMask(i), n = i)
                        },
                        setFunc: function (e) {
                            if (i !== e) {
                                switch (e) {
                                    case $m:
                                        t.depthFunc(512);
                                        break;
                                    case Xm:
                                        t.depthFunc(519);
                                        break;
                                    case qm:
                                        t.depthFunc(513);
                                        break;
                                    case Ym:
                                        t.depthFunc(515);
                                        break;
                                    case Km:
                                        t.depthFunc(514);
                                        break;
                                    case Jm:
                                        t.depthFunc(518);
                                        break;
                                    case Zm:
                                        t.depthFunc(516);
                                        break;
                                    case Qm:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                }
                                i = e
                            }
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            r !== e && (t.clearDepth(e), r = e)
                        },
                        reset: function () {
                            e = !1, n = null, i = null, r = null
                        }
                    }
                },
                o = new function () {
                    let e = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        o = null,
                        a = null,
                        l = null,
                        u = null;
                    return {
                        setTest: function (t) {
                            e || (t ? B(2960) : j(2960))
                        },
                        setMask: function (i) {
                            n === i || e || (t.stencilMask(i), n = i)
                        },
                        setFunc: function (e, n, o) {
                            i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o)
                        },
                        setOp: function (e, n, i) {
                            o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i)
                        },
                        setLocked: function (t) {
                            e = t
                        },
                        setClear: function (e) {
                            u !== e && (t.clearStencil(e), u = e)
                        },
                        reset: function () {
                            e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, u = null
                        }
                    }
                },
                a = new WeakMap,
                l = new WeakMap;
            let u = {},
                c = {},
                h = new WeakMap,
                d = [],
                f = null,
                p = !1,
                m = null,
                g = null,
                v = null,
                y = null,
                b = null,
                _ = null,
                x = null,
                w = !1,
                M = null,
                S = null,
                T = null,
                E = null,
                D = null;
            const C = t.getParameter(35661);
            let A = !1,
                P = 0;
            const L = t.getParameter(7938); - 1 !== L.indexOf("WebGL") ? (P = parseFloat(/^WebGL (\d)/.exec(L)[1]), A = P >= 1) : -1 !== L.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), A = P >= 2);
            let R = null,
                k = {};
            const O = t.getParameter(3088),
                I = t.getParameter(2978),
                F = (new py).fromArray(O),
                N = (new py).fromArray(I);

            function z(e, n, i) {
                const r = new Uint8Array(4),
                    s = t.createTexture();
                t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return s
            }
            const U = {};

            function B(e) {
                !0 !== u[e] && (t.enable(e), u[e] = !0)
            }

            function j(e) {
                !1 !== u[e] && (t.disable(e), u[e] = !1)
            }
            U[3553] = z(3553, 3553, 1), U[34067] = z(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), B(2929), s.setFunc(Ym), W(!1), $(gm), B(2884), G(Sm);
            const H = {
                [Pm]: 32774,
                [Lm]: 32778,
                [Rm]: 32779
            };
            if (i) H[km] = 32775, H[Om] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (H[km] = t.MIN_EXT, H[Om] = t.MAX_EXT)
            }
            const V = {
                [Im]: 0,
                [Fm]: 1,
                [Nm]: 768,
                [Um]: 770,
                [Wm]: 776,
                [Vm]: 774,
                [jm]: 772,
                [zm]: 769,
                [Bm]: 771,
                [Gm]: 775,
                [Hm]: 773
            };

            function G(e, n, i, r, s, o, a, l) {
                if (e !== Sm) {
                    if (!1 === p && (B(3042), p = !0), e === Am) s = s || n, o = o || i, a = a || r, n === g && s === b || (t.blendEquationSeparate(H[n], H[s]), g = n, b = s), i === v && r === y && o === _ && a === x || (t.blendFuncSeparate(V[i], V[r], V[o], V[a]), v = i, y = r, _ = o, x = a), m = e, w = null;
                    else if (e !== m || l !== w) {
                        if (g === Pm && b === Pm || (t.blendEquation(32774), g = Pm, b = Pm), l) switch (e) {
                            case Tm:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case Em:
                                t.blendFunc(1, 1);
                                break;
                            case Dm:
                                t.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case Cm:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case Tm:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case Em:
                                t.blendFunc(770, 1);
                                break;
                            case Dm:
                                t.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case Cm:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        v = null, y = null, _ = null, x = null, m = e, w = l
                    }
                } else !0 === p && (j(3042), p = !1)
            }

            function W(e) {
                M !== e && (e ? t.frontFace(2304) : t.frontFace(2305), M = e)
            }

            function $(e) {
                e !== mm ? (B(2884), e !== S && (e === gm ? t.cullFace(1029) : e === vm ? t.cullFace(1028) : t.cullFace(1032))) : j(2884), S = e
            }

            function X(e, n, i) {
                e ? (B(32823), E === n && D === i || (t.polygonOffset(n, i), E = n, D = i)) : j(32823)
            }
            return {
                buffers: {
                    color: r,
                    depth: s,
                    stencil: o
                },
                enable: B,
                disable: j,
                bindFramebuffer: function (e, n) {
                    return c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, i && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)), !0)
                },
                drawBuffers: function (i, r) {
                    let s = d,
                        o = !1;
                    if (i)
                        if (s = h.get(r), void 0 === s && (s = [], h.set(r, s)), i.isWebGLMultipleRenderTargets) {
                            const t = i.texture;
                            if (s.length !== t.length || 36064 !== s[0]) {
                                for (let e = 0, n = t.length; e < n; e++) s[e] = 36064 + e;
                                s.length = t.length, o = !0
                            }
                        } else 36064 !== s[0] && (s[0] = 36064, o = !0);
                    else 1029 !== s[0] && (s[0] = 1029, o = !0);
                    o && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                },
                useProgram: function (e) {
                    return f !== e && (t.useProgram(e), f = e, !0)
                },
                setBlending: G,
                setMaterial: function (t, e) {
                    t.side === Mm ? j(2884) : B(2884);
                    let n = t.side === wm;
                    e && (n = !n), W(n), t.blending === Tm && !1 === t.transparent ? G(Sm) : G(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                    const i = t.stencilWrite;
                    o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? B(32926) : j(32926)
                },
                setFlipSided: W,
                setCullFace: $,
                setLineWidth: function (e) {
                    e !== T && (A && t.lineWidth(e), T = e)
                },
                setPolygonOffset: X,
                setScissorTest: function (t) {
                    t ? B(3089) : j(3089)
                },
                activeTexture: function (e) {
                    void 0 === e && (e = 33984 + C - 1), R !== e && (t.activeTexture(e), R = e)
                },
                bindTexture: function (e, n, i) {
                    void 0 === i && (i = null === R ? 33984 + C - 1 : R);
                    let r = k[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, k[i] = r), r.type === e && r.texture === n || (R !== i && (t.activeTexture(i), R = i), t.bindTexture(e, n || U[e]), r.type = e, r.texture = n)
                },
                unbindTexture: function () {
                    const e = k[R];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function () {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexImage3D: function () {
                    try {
                        t.compressedTexImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function () {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function () {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                updateUBOMapping: function (e, n) {
                    let i = l.get(n);
                    void 0 === i && (i = new WeakMap, l.set(n, i));
                    let r = i.get(e);
                    void 0 === r && (r = t.getUniformBlockIndex(n, e.name), i.set(e, r))
                },
                uniformBlockBinding: function (e, n) {
                    const i = l.get(n).get(e);
                    a.get(e) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), a.set(e, i))
                },
                texStorage2D: function () {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function () {
                    try {
                        t.texStorage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function () {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function () {
                    try {
                        t.texSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function () {
                    try {
                        t.compressedTexSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage3D: function () {
                    try {
                        t.compressedTexSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function (e) {
                    !1 === F.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), F.copy(e))
                },
                viewport: function (e) {
                    !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e))
                },
                reset: function () {
                    t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), u = {}, R = null, k = {}, c = {}, h = new WeakMap, d = [], f = null, p = !1, m = null, g = null, v = null, y = null, b = null, _ = null, x = null, w = !1, M = null, S = null, T = null, E = null, D = null, F.set(0, 0, t.canvas.width, t.canvas.height), N.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), o.reset()
                }
            }
        }

        function Qw(t, e, n, i, r, s, o) {
            const a = r.isWebGL2,
                l = r.maxTextures,
                u = r.maxCubemapSize,
                c = r.maxTextureSize,
                h = r.maxSamples,
                d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                f = /OculusBrowser/g.test("undefined" == typeof navigator ? "" : navigator.userAgent),
                p = new WeakMap;
            let m;
            const g = new WeakMap;
            let v = !1;
            try {
                v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) { }

            function y(t, e) {
                return v ? new OffscreenCanvas(t, e) : Kv("canvas")
            }

            function b(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? Vv : Math.floor,
                            s = i(r * t.width),
                            o = i(r * t.height);
                        void 0 === m && (m = y(s, o));
                        const a = n ? y(s, o) : m;
                        return a.width = s, a.height = o, a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
                    }
                    return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                }
                return t
            }

            function _(t) {
                return jv(t.width) && jv(t.height)
            }

            function x(t, e) {
                return t.generateMipmaps && e && t.minFilter !== vg && t.minFilter !== _g
            }

            function w(e) {
                t.generateMipmap(e)
            }

            function M(n, i, r, s, o = !1) {
                if (!1 === a) return i;
                if (null !== n) {
                    if (void 0 !== t[n]) return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = i;
                return 6403 === i && (5126 === r && (l = 33326), 5131 === r && (l = 33325), 5121 === r && (l = 33321)), 33319 === i && (5126 === r && (l = 33328), 5131 === r && (l = 33327), 5121 === r && (l = 33323)), 6408 === i && (5126 === r && (l = 34836), 5131 === r && (l = 34842), 5121 === r && (l = s === wv && !1 === o ? 35907 : 32856), 32819 === r && (l = 32854), 32820 === r && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"), l
            }

            function S(t, e, n) {
                return !0 === x(t, n) || t.isFramebufferTexture && t.minFilter !== vg && t.minFilter !== _g ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }

            function T(t) {
                return t === vg || t === yg || t === bg ? 9728 : 9729
            }

            function E(t) {
                const e = t.target;
                e.removeEventListener("dispose", E),
                    function (t) {
                        const e = i.get(t);
                        if (void 0 === e.__webglInit) return;
                        const n = t.source,
                            r = g.get(n);
                        if (r) {
                            const i = r[e.__cacheKey];
                            i.usedTimes--, 0 === i.usedTimes && C(t), 0 === Object.keys(r).length && g.delete(n)
                        }
                        i.remove(t)
                    }(e), e.isVideoTexture && p.delete(e)
            }

            function D(e) {
                const n = e.target;
                n.removeEventListener("dispose", D),
                    function (e) {
                        const n = e.texture,
                            r = i.get(e),
                            s = i.get(n);
                        if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                        else {
                            if (t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer)
                                for (let e = 0; e < r.__webglColorRenderbuffer.length; e++) r.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                            r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                        }
                        if (e.isWebGLMultipleRenderTargets)
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = i.get(n[e]);
                                r.__webglTexture && (t.deleteTexture(r.__webglTexture), o.memory.textures--), i.remove(n[e])
                            }
                        i.remove(n), i.remove(e)
                    }(n)
            }

            function C(e) {
                const n = i.get(e);
                t.deleteTexture(n.__webglTexture);
                const r = e.source;
                delete g.get(r)[n.__cacheKey], o.memory.textures--
            }
            let A = 0;

            function P(t, e) {
                const r = i.get(t);
                if (t.isVideoTexture && function (t) {
                    const e = o.render.frame;
                    p.get(t) !== e && (p.set(t, e), t.update())
                }(t), !1 === t.isRenderTargetTexture && t.version > 0 && r.__version !== t.version) {
                    const n = t.image;
                    if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== n.complete) return void I(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(3553, r.__webglTexture, 33984 + e)
            }
            const L = {
                [pg]: 10497,
                [mg]: 33071,
                [gg]: 33648
            },
                R = {
                    [vg]: 9728,
                    [yg]: 9984,
                    [bg]: 9986,
                    [_g]: 9729,
                    [xg]: 9985,
                    [wg]: 9987
                };

            function k(n, s, o) {
                if (o ? (t.texParameteri(n, 10242, L[s.wrapS]), t.texParameteri(n, 10243, L[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, L[s.wrapR]), t.texParameteri(n, 10240, R[s.magFilter]), t.texParameteri(n, 10241, R[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === mg && s.wrapT === mg || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, T(s.magFilter)), t.texParameteri(n, 10241, T(s.minFilter)), s.minFilter !== vg && s.minFilter !== _g && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const o = e.get("EXT_texture_filter_anisotropic");
                    if (s.type === Ag && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === a && s.type === Pg && !1 === e.has("OES_texture_half_float_linear")) return;
                    (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                }
            }

            function O(e, n) {
                let i = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", E));
                const r = n.source;
                let s = g.get(r);
                void 0 === s && (s = {}, g.set(r, s));
                const a = function (t) {
                    const e = [];
                    return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.encoding), e.join()
                }(n);
                if (a !== e.__cacheKey) {
                    void 0 === s[a] && (s[a] = {
                        texture: t.createTexture(),
                        usedTimes: 0
                    }, o.memory.textures++, i = !0), s[a].usedTimes++;
                    const r = s[e.__cacheKey];
                    void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && C(n)), e.__cacheKey = a, e.__webglTexture = s[a].texture
                }
                return i
            }

            function I(e, r, o) {
                let l = 3553;
                (r.isDataArrayTexture || r.isCompressedArrayTexture) && (l = 35866), r.isData3DTexture && (l = 32879);
                const u = O(e, r),
                    h = r.source;
                n.bindTexture(l, e.__webglTexture, 33984 + o);
                const d = i.get(h);
                if (h.version !== d.__version || !0 === u) {
                    n.activeTexture(33984 + o), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                    const e = function (t) {
                        return !a && (t.wrapS !== mg || t.wrapT !== mg || t.minFilter !== vg && t.minFilter !== _g)
                    }(r) && !1 === _(r.image);
                    let i = b(r.image, e, !1, c);
                    i = j(r, i);
                    const f = _(i) || a,
                        p = s.convert(r.format, r.encoding);
                    let m, g = s.convert(r.type),
                        v = M(r.internalFormat, p, g, r.encoding, r.isVideoTexture);
                    k(l, r, f);
                    const y = r.mipmaps,
                        T = a && !0 !== r.isVideoTexture,
                        E = void 0 === d.__version || !0 === u,
                        D = S(r, i, f);
                    if (r.isDepthTexture) v = 6402, a ? v = r.type === Ag ? 36012 : r.type === Cg ? 33190 : r.type === kg ? 35056 : 33189 : r.type === Ag && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Ug && 6402 === v && r.type !== Eg && r.type !== Cg && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Cg, g = s.convert(r.type)), r.format === Bg && 6402 === v && (v = 34041, r.type !== kg && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = kg, g = s.convert(r.type))), E && (T ? n.texStorage2D(3553, 1, v, i.width, i.height) : n.texImage2D(3553, 0, v, i.width, i.height, 0, p, g, null));
                    else if (r.isDataTexture)
                        if (y.length > 0 && f) {
                            T && E && n.texStorage2D(3553, D, v, y[0].width, y[0].height);
                            for (let t = 0, e = y.length; t < e; t++) m = y[t], T ? n.texSubImage2D(3553, t, 0, 0, m.width, m.height, p, g, m.data) : n.texImage2D(3553, t, v, m.width, m.height, 0, p, g, m.data);
                            r.generateMipmaps = !1
                        } else T ? (E && n.texStorage2D(3553, D, v, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, i.width, i.height, p, g, i.data)) : n.texImage2D(3553, 0, v, i.width, i.height, 0, p, g, i.data);
                    else if (r.isCompressedTexture)
                        if (r.isCompressedArrayTexture) {
                            T && E && n.texStorage3D(35866, D, v, y[0].width, y[0].height, i.depth);
                            for (let t = 0, e = y.length; t < e; t++) m = y[t], r.format !== Fg ? null !== p ? T ? n.compressedTexSubImage3D(35866, t, 0, 0, 0, m.width, m.height, i.depth, p, m.data, 0, 0) : n.compressedTexImage3D(35866, t, v, m.width, m.height, i.depth, 0, m.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T ? n.texSubImage3D(35866, t, 0, 0, 0, m.width, m.height, i.depth, p, g, m.data) : n.texImage3D(35866, t, v, m.width, m.height, i.depth, 0, p, g, m.data)
                        } else {
                            T && E && n.texStorage2D(3553, D, v, y[0].width, y[0].height);
                            for (let t = 0, e = y.length; t < e; t++) m = y[t], r.format !== Fg ? null !== p ? T ? n.compressedTexSubImage2D(3553, t, 0, 0, m.width, m.height, p, m.data) : n.compressedTexImage2D(3553, t, v, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T ? n.texSubImage2D(3553, t, 0, 0, m.width, m.height, p, g, m.data) : n.texImage2D(3553, t, v, m.width, m.height, 0, p, g, m.data)
                        }
                    else if (r.isDataArrayTexture) T ? (E && n.texStorage3D(35866, D, v, i.width, i.height, i.depth), n.texSubImage3D(35866, 0, 0, 0, 0, i.width, i.height, i.depth, p, g, i.data)) : n.texImage3D(35866, 0, v, i.width, i.height, i.depth, 0, p, g, i.data);
                    else if (r.isData3DTexture) T ? (E && n.texStorage3D(32879, D, v, i.width, i.height, i.depth), n.texSubImage3D(32879, 0, 0, 0, 0, i.width, i.height, i.depth, p, g, i.data)) : n.texImage3D(32879, 0, v, i.width, i.height, i.depth, 0, p, g, i.data);
                    else if (r.isFramebufferTexture) {
                        if (E)
                            if (T) n.texStorage2D(3553, D, v, i.width, i.height);
                            else {
                                let t = i.width,
                                    e = i.height;
                                for (let i = 0; i < D; i++) n.texImage2D(3553, i, v, t, e, 0, p, g, null), t >>= 1, e >>= 1
                            }
                    } else if (y.length > 0 && f) {
                        T && E && n.texStorage2D(3553, D, v, y[0].width, y[0].height);
                        for (let t = 0, e = y.length; t < e; t++) m = y[t], T ? n.texSubImage2D(3553, t, 0, 0, p, g, m) : n.texImage2D(3553, t, v, p, g, m);
                        r.generateMipmaps = !1
                    } else T ? (E && n.texStorage2D(3553, D, v, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, p, g, i)) : n.texImage2D(3553, 0, v, p, g, i);
                    x(r, f) && w(l), d.__version = h.version, r.onUpdate && r.onUpdate(r)
                }
                e.__version = r.version
            }

            function F(e, r, o, a, l) {
                const u = s.convert(o.format, o.encoding),
                    c = s.convert(o.type),
                    h = M(o.internalFormat, u, c, o.encoding);
                i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, u, c, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, u, c, null)), n.bindFramebuffer(36160, e), B(r) ? d.framebufferTexture2DMultisampleEXT(36160, a, l, i.get(o).__webglTexture, 0, U(r)) : (3553 === l || l >= 34069 && l <= 34074) && t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null)
            }

            function N(e, n, i) {
                if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                    let r = 33189;
                    if (i || B(n)) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === Ag ? r = 36012 : e.type === Cg && (r = 33190));
                        const i = U(n);
                        B(n) ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                    } else t.renderbufferStorage(36161, r, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = U(n);
                    i && !1 === B(n) ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : B(n) ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let r = 0; r < e.length; r++) {
                        const o = e[r],
                            a = s.convert(o.format, o.encoding),
                            l = s.convert(o.type),
                            u = M(o.internalFormat, a, l, o.encoding),
                            c = U(n);
                        i && !1 === B(n) ? t.renderbufferStorageMultisample(36161, c, u, n.width, n.height) : B(n) ? d.renderbufferStorageMultisampleEXT(36161, c, u, n.width, n.height) : t.renderbufferStorage(36161, u, n.width, n.height)
                    }
                }
                t.bindRenderbuffer(36161, null)
            }

            function z(e) {
                const r = i.get(e),
                    s = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function (e, r) {
                        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), P(r.depthTexture, 0);
                        const s = i.get(r.depthTexture).__webglTexture,
                            o = U(r);
                        if (r.depthTexture.format === Ug) B(r) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                        else {
                            if (r.depthTexture.format !== Bg) throw new Error("Unknown depthTexture format");
                            B(r) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), N(r.__webglDepthbuffer[i], e, !1)
                } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), N(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }

            function U(t) {
                return Math.min(h, t.samples)
            }

            function B(t) {
                const n = i.get(t);
                return a && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function j(t, n) {
                const i = t.encoding,
                    r = t.format,
                    s = t.type;
                return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === Lv || i !== xv && (i === wv ? !1 === a ? !0 === e.has("EXT_sRGB") && r === Fg ? (t.format = Lv, t.minFilter = _g, t.generateMipmaps = !1) : n = uy.sRGBToLinear(n) : r === Fg && s === Mg || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n
            }
            this.allocateTextureUnit = function () {
                const t = A;
                return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), A += 1, t
            }, this.resetTextureUnits = function () {
                A = 0
            }, this.setTexture2D = P, this.setTexture2DArray = function (t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? I(r, t, e) : n.bindTexture(35866, r.__webglTexture, 33984 + e)
            }, this.setTexture3D = function (t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? I(r, t, e) : n.bindTexture(32879, r.__webglTexture, 33984 + e)
            }, this.setTextureCube = function (e, r) {
                const o = i.get(e);
                e.version > 0 && o.__version !== e.version ? function (e, r, o) {
                    if (6 !== r.image.length) return;
                    const l = O(e, r),
                        c = r.source;
                    n.bindTexture(34067, e.__webglTexture, 33984 + o);
                    const h = i.get(c);
                    if (c.version !== h.__version || !0 === l) {
                        n.activeTexture(33984 + o), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                        const e = r.isCompressedTexture || r.image[0].isCompressedTexture,
                            i = r.image[0] && r.image[0].isDataTexture,
                            d = [];
                        for (let t = 0; t < 6; t++) d[t] = e || i ? i ? r.image[t].image : r.image[t] : b(r.image[t], !1, !0, u), d[t] = j(r, d[t]);
                        const f = d[0],
                            p = _(f) || a,
                            m = s.convert(r.format, r.encoding),
                            g = s.convert(r.type),
                            v = M(r.internalFormat, m, g, r.encoding),
                            y = a && !0 !== r.isVideoTexture,
                            T = void 0 === h.__version || !0 === l;
                        let E, D = S(r, f, p);
                        if (k(34067, r, p), e) {
                            y && T && n.texStorage2D(34067, D, v, f.width, f.height);
                            for (let t = 0; t < 6; t++) {
                                E = d[t].mipmaps;
                                for (let e = 0; e < E.length; e++) {
                                    const i = E[e];
                                    r.format !== Fg ? null !== m ? y ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, i.width, i.height, m, i.data) : n.compressedTexImage2D(34069 + t, e, v, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : y ? n.texSubImage2D(34069 + t, e, 0, 0, i.width, i.height, m, g, i.data) : n.texImage2D(34069 + t, e, v, i.width, i.height, 0, m, g, i.data)
                                }
                            }
                        } else {
                            E = r.mipmaps, y && T && (E.length > 0 && D++, n.texStorage2D(34067, D, v, d[0].width, d[0].height));
                            for (let t = 0; t < 6; t++)
                                if (i) {
                                    y ? n.texSubImage2D(34069 + t, 0, 0, 0, d[t].width, d[t].height, m, g, d[t].data) : n.texImage2D(34069 + t, 0, v, d[t].width, d[t].height, 0, m, g, d[t].data);
                                    for (let e = 0; e < E.length; e++) {
                                        const i = E[e].image[t].image;
                                        y ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, m, g, i.data) : n.texImage2D(34069 + t, e + 1, v, i.width, i.height, 0, m, g, i.data)
                                    }
                                } else {
                                    y ? n.texSubImage2D(34069 + t, 0, 0, 0, m, g, d[t]) : n.texImage2D(34069 + t, 0, v, m, g, d[t]);
                                    for (let e = 0; e < E.length; e++) {
                                        const i = E[e];
                                        y ? n.texSubImage2D(34069 + t, e + 1, 0, 0, m, g, i.image[t]) : n.texImage2D(34069 + t, e + 1, v, m, g, i.image[t])
                                    }
                                }
                        }
                        x(r, p) && w(34067), h.__version = c.version, r.onUpdate && r.onUpdate(r)
                    }
                    e.__version = r.version
                }(o, e, r) : n.bindTexture(34067, o.__webglTexture, 33984 + r)
            }, this.rebindTextures = function (t, e, n) {
                const r = i.get(t);
                void 0 !== e && F(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && z(t)
            }, this.setupRenderTarget = function (e) {
                const l = e.texture,
                    u = i.get(e),
                    c = i.get(l);
                e.addEventListener("dispose", D), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()), c.__version = l.version, o.memory.textures++);
                const h = !0 === e.isWebGLCubeRenderTarget,
                    d = !0 === e.isWebGLMultipleRenderTargets,
                    f = _(e) || a;
                if (h) {
                    u.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++) u.__webglFramebuffer[e] = t.createFramebuffer()
                } else {
                    if (u.__webglFramebuffer = t.createFramebuffer(), d)
                        if (r.drawBuffers) {
                            const n = e.texture;
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = i.get(n[e]);
                                void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), o.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (a && e.samples > 0 && !1 === B(e)) {
                        const i = d ? l : [l];
                        u.__webglMultisampledFramebuffer = t.createFramebuffer(), u.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            const r = i[n];
                            u.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(36161, u.__webglColorRenderbuffer[n]);
                            const o = s.convert(r.format, r.encoding),
                                a = s.convert(r.type),
                                l = M(r.internalFormat, o, a, r.encoding, !0 === e.isXRRenderTarget),
                                c = U(e);
                            t.renderbufferStorageMultisample(36161, c, l, e.width, e.height), t.framebufferRenderbuffer(36160, 36064 + n, 36161, u.__webglColorRenderbuffer[n])
                        }
                        t.bindRenderbuffer(36161, null), e.depthBuffer && (u.__webglDepthRenderbuffer = t.createRenderbuffer(), N(u.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                    }
                }
                if (h) {
                    n.bindTexture(34067, c.__webglTexture), k(34067, l, f);
                    for (let t = 0; t < 6; t++) F(u.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                    x(l, f) && w(34067), n.unbindTexture()
                } else if (d) {
                    const t = e.texture;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r],
                            o = i.get(s);
                        n.bindTexture(3553, o.__webglTexture), k(3553, s, f), F(u.__webglFramebuffer, e, s, 36064 + r, 3553), x(s, f) && w(3553)
                    }
                    n.unbindTexture()
                } else {
                    let t = 3553;
                    (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (a ? t = e.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(t, c.__webglTexture), k(t, l, f), F(u.__webglFramebuffer, e, l, 36064, t), x(l, f) && w(t), n.unbindTexture()
                }
                e.depthBuffer && z(e)
            }, this.updateRenderTargetMipmap = function (t) {
                const e = _(t) || a,
                    r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let s = 0, o = r.length; s < o; s++) {
                    const o = r[s];
                    if (x(o, e)) {
                        const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                            r = i.get(o).__webglTexture;
                        n.bindTexture(e, r), w(e), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function (e) {
                if (a && e.samples > 0 && !1 === B(e)) {
                    const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
                        s = e.width,
                        o = e.height;
                    let a = 16384;
                    const l = [],
                        u = e.stencilBuffer ? 33306 : 36096,
                        c = i.get(e),
                        h = !0 === e.isWebGLMultipleRenderTargets;
                    if (h)
                        for (let e = 0; e < r.length; e++) n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + e, 36161, null), n.bindFramebuffer(36160, c.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + e, 3553, null, 0);
                    n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer);
                    for (let n = 0; n < r.length; n++) {
                        l.push(36064 + n), e.depthBuffer && l.push(u);
                        const d = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues;
                        if (!1 === d && (e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024)), h && t.framebufferRenderbuffer(36008, 36064, 36161, c.__webglColorRenderbuffer[n]), !0 === d && (t.invalidateFramebuffer(36008, [u]), t.invalidateFramebuffer(36009, [u])), h) {
                            const e = i.get(r[n]).__webglTexture;
                            t.framebufferTexture2D(36009, 36064, 3553, e, 0)
                        }
                        t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, 9728), f && t.invalidateFramebuffer(36008, l)
                    }
                    if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), h)
                        for (let e = 0; e < r.length; e++) {
                            n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + e, 36161, c.__webglColorRenderbuffer[e]);
                            const s = i.get(r[e]).__webglTexture;
                            n.bindFramebuffer(36160, c.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + e, 3553, s, 0)
                        }
                    n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = z, this.setupFrameBufferTexture = F, this.useMultisampledRTT = B
        }

        function tM(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function (n, r = null) {
                    let s;
                    if (n === Mg) return 5121;
                    if (n === Lg) return 32819;
                    if (n === Rg) return 32820;
                    if (n === Sg) return 5120;
                    if (n === Tg) return 5122;
                    if (n === Eg) return 5123;
                    if (n === Dg) return 5124;
                    if (n === Cg) return 5125;
                    if (n === Ag) return 5126;
                    if (n === Pg) return i ? 5131 : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
                    if (n === Og) return 6406;
                    if (n === Fg) return 6408;
                    if (n === Ng) return 6409;
                    if (n === zg) return 6410;
                    if (n === Ug) return 6402;
                    if (n === Bg) return 34041;
                    if (n === jg) return 6403;
                    if (n === Ig) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                    if (n === Lv) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
                    if (n === Hg) return 36244;
                    if (n === Vg) return 33319;
                    if (n === Gg) return 33320;
                    if (n === Wg) return 36249;
                    if (n === $g || n === Xg || n === qg || n === Yg)
                        if (r === wv) {
                            if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
                            if (n === $g) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === Xg) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === qg) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === Yg) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
                            if (n === $g) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === Xg) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === qg) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === Yg) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        } if (n === Kg || n === Jg || n === Zg || n === Qg) {
                            if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
                            if (n === Kg) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === Jg) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === Zg) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === Qg) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                    if (n === tv) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (n === ev || n === nv) {
                        if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null;
                        if (n === ev) return r === wv ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                        if (n === nv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === iv || n === rv || n === sv || n === ov || n === av || n === lv || n === uv || n === cv || n === hv || n === dv || n === fv || n === pv || n === mv || n === gv) {
                        if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null;
                        if (n === iv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (n === rv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (n === sv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (n === ov) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === av) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (n === lv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (n === uv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (n === cv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (n === hv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (n === dv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (n === fv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (n === pv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (n === mv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (n === gv) return r === wv ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === vv) {
                        if (s = e.get("EXT_texture_compression_bptc"), null === s) return null;
                        if (n === vv) return r === wv ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
                    }
                    return n === kg ? i ? 34042 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null
                }
            }
        }
        class eM extends __ {
            constructor(t = []) {
                super(), this.isArrayCamera = !0, this.cameras = t
            }
        }
        class nM extends _b {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }
        const iM = {
            type: "move"
        };
        class rM {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new nM, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new nM, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new by, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new by), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new nM, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new by, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new by), this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(t, e, n) {
                let i = null,
                    r = null,
                    s = null;
                const o = this._targetRay,
                    a = this._grip,
                    l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState) {
                    if (l && t.hand) {
                        s = !0;
                        for (const i of t.hand.values()) {
                            const t = e.getJointPose(i, n);
                            if (void 0 === l.joints[i.jointName]) {
                                const t = new nM;
                                t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                            }
                            const r = l.joints[i.jointName];
                            null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                        }
                        const i = l.joints["index-finger-tip"],
                            r = l.joints["thumb-tip"],
                            o = i.position.distanceTo(r.position),
                            a = .02,
                            u = .005;
                        l.inputState.pinching && o > a + u ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && o <= a - u && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                    null !== o && (i = e.getPose(t.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(iM)))
                }
                return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
            }
        }
        class sM extends fy {
            constructor(t, e, n, i, r, s, o, a, l, u) {
                if ((u = void 0 !== u ? u : Ug) !== Ug && u !== Bg) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && u === Ug && (n = Cg), void 0 === n && u === Bg && (n = kg), super(null, i, r, s, o, a, u, n, l), this.isDepthTexture = !0, this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== o ? o : vg, this.minFilter = void 0 !== a ? a : vg, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        class oM extends Rv {
            constructor(t, e) {
                super();
                const n = this;
                let i = null,
                    r = 1,
                    s = null,
                    o = "local-floor",
                    a = null,
                    l = null,
                    u = null,
                    c = null,
                    h = null,
                    d = null;
                const f = e.getContextAttributes();
                let p = null,
                    m = null;
                const g = [],
                    v = [],
                    y = new __;
                y.layers.enable(1), y.viewport = new py;
                const b = new __;
                b.layers.enable(2), b.viewport = new py;
                const _ = [y, b],
                    x = new eM;
                x.layers.enable(1), x.layers.enable(2);
                let w = null,
                    M = null;

                function S(t) {
                    const e = v.indexOf(t.inputSource);
                    if (-1 === e) return;
                    const n = g[e];
                    void 0 !== n && n.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }

                function T() {
                    i.removeEventListener("select", S), i.removeEventListener("selectstart", S), i.removeEventListener("selectend", S), i.removeEventListener("squeeze", S), i.removeEventListener("squeezestart", S), i.removeEventListener("squeezeend", S), i.removeEventListener("end", T), i.removeEventListener("inputsourceschange", E);
                    for (let t = 0; t < g.length; t++) {
                        const e = v[t];
                        null !== e && (v[t] = null, g[t].disconnect(e))
                    }
                    w = null, M = null, t.setRenderTarget(p), h = null, c = null, u = null, i = null, m = null, L.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function E(t) {
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e],
                            i = v.indexOf(n);
                        i >= 0 && (v[i] = null, g[i].dispatchEvent({
                            type: "disconnected",
                            data: n
                        }))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e];
                        let i = v.indexOf(n);
                        if (-1 === i) {
                            for (let t = 0; t < g.length; t++) {
                                if (t >= v.length) {
                                    v.push(n), i = t;
                                    break
                                }
                                if (null === v[t]) {
                                    v[t] = n, i = t;
                                    break
                                }
                            }
                            if (-1 === i) break
                        }
                        const r = g[i];
                        r && r.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
                    let e = g[t];
                    return void 0 === e && (e = new rM, g[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function (t) {
                    let e = g[t];
                    return void 0 === e && (e = new rM, g[t] = e), e.getGripSpace()
                }, this.getHand = function (t) {
                    let e = g[t];
                    return void 0 === e && (e = new rM, g[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function (t) {
                    r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function (t) {
                    o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function () {
                    return a || s
                }, this.setReferenceSpace = function (t) {
                    a = t
                }, this.getBaseLayer = function () {
                    return null !== c ? c : h
                }, this.getBinding = function () {
                    return u
                }, this.getFrame = function () {
                    return d
                }, this.getSession = function () {
                    return i
                }, this.setSession = async function (l) {
                    if (i = l, null !== i) {
                        if (p = t.getRenderTarget(), i.addEventListener("select", S), i.addEventListener("selectstart", S), i.addEventListener("selectend", S), i.addEventListener("squeeze", S), i.addEventListener("squeezestart", S), i.addEventListener("squeezeend", S), i.addEventListener("end", T), i.addEventListener("inputsourceschange", E), !0 !== f.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== i.renderState.layers || f.antialias,
                                alpha: f.alpha,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: r
                            };
                            h = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                baseLayer: h
                            }), m = new my(h.framebufferWidth, h.framebufferHeight, {
                                format: Fg,
                                type: Mg,
                                encoding: t.outputEncoding,
                                stencilBuffer: f.stencil
                            })
                        } else {
                            let n = null,
                                s = null,
                                o = null;
                            f.depth && (o = f.stencil ? 35056 : 33190, n = f.stencil ? Bg : Ug, s = f.stencil ? kg : Cg);
                            const a = {
                                colorFormat: 32856,
                                depthFormat: o,
                                scaleFactor: r
                            };
                            u = new XRWebGLBinding(i, e), c = u.createProjectionLayer(a), i.updateRenderState({
                                layers: [c]
                            }), m = new my(c.textureWidth, c.textureHeight, {
                                format: Fg,
                                type: Mg,
                                depthTexture: new sM(c.textureWidth, c.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: f.stencil,
                                encoding: t.outputEncoding,
                                samples: f.antialias ? 4 : 0
                            }), t.properties.get(m).__ignoreDepthValues = c.ignoreDepthValues
                        }
                        m.isXRRenderTarget = !0, this.setFoveation(1), a = null, s = await i.requestReferenceSpace(o), L.setContext(i), L.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                };
                const D = new by,
                    C = new by;

                function A(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function (t) {
                    if (null === i) return;
                    x.near = b.near = y.near = t.near, x.far = b.far = y.far = t.far, w === x.near && M === x.far || (i.updateRenderState({
                        depthNear: x.near,
                        depthFar: x.far
                    }), w = x.near, M = x.far);
                    const e = t.parent,
                        n = x.cameras;
                    A(x, e);
                    for (let t = 0; t < n.length; t++) A(n[t], e);
                    x.matrixWorld.decompose(x.position, x.quaternion, x.scale), t.matrix.copy(x.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale);
                    const r = t.children;
                    for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                    2 === n.length ? function (t, e, n) {
                        D.setFromMatrixPosition(e.matrixWorld), C.setFromMatrixPosition(n.matrixWorld);
                        const i = D.distanceTo(C),
                            r = e.projectionMatrix.elements,
                            s = n.projectionMatrix.elements,
                            o = r[14] / (r[10] - 1),
                            a = r[14] / (r[10] + 1),
                            l = (r[9] + 1) / r[5],
                            u = (r[9] - 1) / r[5],
                            c = (r[8] - 1) / r[0],
                            h = (s[8] + 1) / s[0],
                            d = o * c,
                            f = o * h,
                            p = i / (-c + h),
                            m = p * -c;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(p), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = o + p,
                            v = a + p,
                            y = d - m,
                            b = f + (i - m),
                            _ = l * a / v * g,
                            x = u * a / v * g;
                        t.projectionMatrix.makePerspective(y, b, _, x, g, v)
                    }(x, y, b) : x.projectionMatrix.copy(y.projectionMatrix)
                }, this.getCamera = function () {
                    return x
                }, this.getFoveation = function () {
                    return null !== c ? c.fixedFoveation : null !== h ? h.fixedFoveation : void 0
                }, this.setFoveation = function (t) {
                    null !== c && (c.fixedFoveation = t), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = t)
                };
                let P = null;
                const L = new R_;
                L.setAnimationLoop((function (e, n) {
                    if (l = n.getViewerPose(a || s), d = n, null !== l) {
                        const e = l.views;
                        null !== h && (t.setRenderTargetFramebuffer(m, h.framebuffer), t.setRenderTarget(m));
                        let n = !1;
                        e.length !== x.cameras.length && (x.cameras.length = 0, n = !0);
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            let s = null;
                            if (null !== h) s = h.getViewport(r);
                            else {
                                const e = u.getViewSubImage(c, r);
                                s = e.viewport, 0 === i && (t.setRenderTargetTextures(m, e.colorTexture, c.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(m))
                            }
                            let o = _[i];
                            void 0 === o && (o = new __, o.layers.enable(i), o.viewport = new py, _[i] = o), o.matrix.fromArray(r.transform.matrix), o.projectionMatrix.fromArray(r.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === i && x.matrix.copy(o.matrix), !0 === n && x.cameras.push(o)
                        }
                    }
                    for (let t = 0; t < g.length; t++) {
                        const e = v[t],
                            i = g[t];
                        null !== e && void 0 !== i && i.update(e, n, a || s)
                    }
                    P && P(e, n), d = null
                })), this.setAnimationLoop = function (t) {
                    P = t
                }, this.dispose = function () { }
            }
        }

        function aM(t, e) {
            function n(n, i) {
                n.opacity.value = i.opacity, i.color && n.diffuse.value.copy(i.color), i.emissive && n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (n.map.value = i.map), i.alphaMap && (n.alphaMap.value = i.alphaMap), i.bumpMap && (n.bumpMap.value = i.bumpMap, n.bumpScale.value = i.bumpScale, i.side === wm && (n.bumpScale.value *= -1)), i.displacementMap && (n.displacementMap.value = i.displacementMap, n.displacementScale.value = i.displacementScale, n.displacementBias.value = i.displacementBias), i.emissiveMap && (n.emissiveMap.value = i.emissiveMap), i.normalMap && (n.normalMap.value = i.normalMap, n.normalScale.value.copy(i.normalScale), i.side === wm && n.normalScale.value.negate()), i.specularMap && (n.specularMap.value = i.specularMap), i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest);
                const r = e.get(i).envMap;
                if (r && (n.envMap.value = r, n.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = i.reflectivity, n.ior.value = i.ior, n.refractionRatio.value = i.refractionRatio), i.lightMap) {
                    n.lightMap.value = i.lightMap;
                    const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1;
                    n.lightMapIntensity.value = i.lightMapIntensity * e
                }
                let s, o;
                i.aoMap && (n.aoMap.value = i.aoMap, n.aoMapIntensity.value = i.aoMapIntensity), i.map ? s = i.map : i.specularMap ? s = i.specularMap : i.displacementMap ? s = i.displacementMap : i.normalMap ? s = i.normalMap : i.bumpMap ? s = i.bumpMap : i.roughnessMap ? s = i.roughnessMap : i.metalnessMap ? s = i.metalnessMap : i.alphaMap ? s = i.alphaMap : i.emissiveMap ? s = i.emissiveMap : i.clearcoatMap ? s = i.clearcoatMap : i.clearcoatNormalMap ? s = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? s = i.clearcoatRoughnessMap : i.iridescenceMap ? s = i.iridescenceMap : i.iridescenceThicknessMap ? s = i.iridescenceThicknessMap : i.specularIntensityMap ? s = i.specularIntensityMap : i.specularColorMap ? s = i.specularColorMap : i.transmissionMap ? s = i.transmissionMap : i.thicknessMap ? s = i.thicknessMap : i.sheenColorMap ? s = i.sheenColorMap : i.sheenRoughnessMap && (s = i.sheenRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), n.uvTransform.value.copy(s.matrix)), i.aoMap ? o = i.aoMap : i.lightMap && (o = i.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), n.uv2Transform.value.copy(o.matrix))
            }
            return {
                refreshFogUniforms: function (t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function (t, i, r, s, o) {
                    i.isMeshBasicMaterial || i.isMeshLambertMaterial ? n(t, i) : i.isMeshToonMaterial ? (n(t, i), function (t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(t, i)) : i.isMeshPhongMaterial ? (n(t, i), function (t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                    }(t, i)) : i.isMeshStandardMaterial ? (n(t, i), function (t, n) {
                        t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap);
                        e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
                    }(t, i), i.isMeshPhysicalMaterial && function (t, e, n) {
                        t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === wm && t.clearcoatNormalScale.value.negate())), e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap)), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                    }(t, i, o)) : i.isMeshMatcapMaterial ? (n(t, i), function (t, e) {
                        e.matcap && (t.matcap.value = e.matcap)
                    }(t, i)) : i.isMeshDepthMaterial ? n(t, i) : i.isMeshDistanceMaterial ? (n(t, i), function (t, e) {
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(t, i)) : i.isMeshNormalMaterial ? n(t, i) : i.isLineBasicMaterial ? (function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                    }(t, i), i.isLineDashedMaterial && function (t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) {
                        let r;
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                    }(t, i, r, s) : i.isSpriteMaterial ? function (t, e) {
                        let n;
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                    }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }

        function lM(t, e, n, i) {
            let r = {},
                s = {},
                o = [];
            const a = n.isWebGL2 ? t.getParameter(35375) : 0;

            function l(t, e, n) {
                const i = t.value;
                if (void 0 === n[e]) return n[e] = "number" == typeof i ? i : i.clone(), !0;
                if ("number" == typeof i) {
                    if (n[e] !== i) return n[e] = i, !0
                } else {
                    const t = n[e];
                    if (!1 === t.equals(i)) return t.copy(i), !0
                }
                return !1
            }

            function u(t) {
                const e = t.value,
                    n = {
                        boundary: 0,
                        storage: 0
                    };
                return "number" == typeof e ? (n.boundary = 4, n.storage = 4) : e.isVector2 ? (n.boundary = 8, n.storage = 8) : e.isVector3 || e.isColor ? (n.boundary = 16, n.storage = 12) : e.isVector4 ? (n.boundary = 16, n.storage = 16) : e.isMatrix3 ? (n.boundary = 48, n.storage = 48) : e.isMatrix4 ? (n.boundary = 64, n.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), n
            }

            function c(e) {
                const n = e.target;
                n.removeEventListener("dispose", c);
                const i = o.indexOf(n.__bindingPointIndex);
                o.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id]
            }
            return {
                bind: function (t, e) {
                    const n = e.program;
                    i.uniformBlockBinding(t, n)
                },
                update: function (n, h) {
                    let d = r[n.id];
                    void 0 === d && (function (t) {
                        const e = t.uniforms;
                        let n = 0;
                        let i = 0;
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t],
                                s = u(r);
                            r.__data = new Float32Array(s.storage / Float32Array.BYTES_PER_ELEMENT), r.__offset = n, t > 0 && (i = n % 16, 0 !== i && 16 - i - s.boundary < 0 && (n += 16 - i, r.__offset = n)), n += s.storage
                        }
                        i = n % 16, i > 0 && (n += 16 - i), t.__size = n, t.__cache = {}
                    }(n), d = function (e) {
                        const n = function () {
                            for (let t = 0; t < a; t++)
                                if (-1 === o.indexOf(t)) return o.push(t), t;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }();
                        e.__bindingPointIndex = n;
                        const i = t.createBuffer(),
                            r = e.__size,
                            s = e.usage;
                        return t.bindBuffer(35345, i), t.bufferData(35345, r, s), t.bindBuffer(35345, null), t.bindBufferBase(35345, n, i), i
                    }(n), r[n.id] = d, n.addEventListener("dispose", c));
                    const f = h.program;
                    i.updateUBOMapping(n, f);
                    const p = e.render.frame;
                    s[n.id] !== p && (function (e) {
                        const n = r[e.id],
                            i = e.uniforms,
                            s = e.__cache;
                        t.bindBuffer(35345, n);
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            if (!0 === l(n, e, s)) {
                                const e = n.value,
                                    i = n.__offset;
                                "number" == typeof e ? (n.__data[0] = e, t.bufferSubData(35345, i, n.__data)) : (n.value.isMatrix3 ? (n.__data[0] = n.value.elements[0], n.__data[1] = n.value.elements[1], n.__data[2] = n.value.elements[2], n.__data[3] = n.value.elements[0], n.__data[4] = n.value.elements[3], n.__data[5] = n.value.elements[4], n.__data[6] = n.value.elements[5], n.__data[7] = n.value.elements[0], n.__data[8] = n.value.elements[6], n.__data[9] = n.value.elements[7], n.__data[10] = n.value.elements[8], n.__data[11] = n.value.elements[0]) : e.toArray(n.__data), t.bufferSubData(35345, i, n.__data))
                            }
                        }
                        t.bindBuffer(35345, null)
                    }(n), s[n.id] = p)
                },
                dispose: function () {
                    for (const e in r) t.deleteBuffer(r[e]);
                    o = [], r = {}, s = {}
                }
            }
        }

        function uM(t = {}) {
            this.isWebGLRenderer = !0;
            const e = void 0 !== t.canvas ? t.canvas : function () {
                const t = Kv("canvas");
                return t.style.display = "block", t
            }(),
                n = void 0 !== t.context ? t.context : null,
                i = void 0 === t.depth || t.depth,
                r = void 0 === t.stencil || t.stencil,
                s = void 0 !== t.antialias && t.antialias,
                o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                a = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                l = void 0 !== t.powerPreference ? t.powerPreference : "default",
                u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let c;
            c = null !== n ? n.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha;
            let h = null,
                d = null;
            const f = [],
                p = [];
            this.domElement = e, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = xv, this.physicallyCorrectLights = !1, this.toneMapping = ig, this.toneMappingExposure = 1, Object.defineProperties(this, {
                gammaFactor: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                    }
                }
            });
            const m = this;
            let g = !1,
                v = 0,
                y = 0,
                b = null,
                _ = -1,
                x = null;
            const w = new py,
                M = new py;
            let S = null,
                T = e.width,
                E = e.height,
                D = 1,
                C = null,
                A = null;
            const P = new py(0, 0, T, E),
                L = new py(0, 0, T, E);
            let R = !1;
            const k = new L_;
            let O = !1,
                I = !1,
                F = null;
            const N = new Yy,
                z = new Xv,
                U = new by,
                B = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function j() {
                return null === b ? D : 1
            }
            let H, V, G, W, $, X, q, Y, K, J, Z, Q, tt, et, nt, it, rt, st, ot, at, lt, ut, ct, ht, dt = n;

            function ft(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i],
                        s = e.getContext(r, n);
                    if (null !== s) return s
                }
                return null
            }
            try {
                const t = {
                    alpha: !0,
                    depth: i,
                    stencil: r,
                    antialias: s,
                    premultipliedAlpha: o,
                    preserveDrawingBuffer: a,
                    powerPreference: l,
                    failIfMajorPerformanceCaveat: u
                };
                if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${pm}`), e.addEventListener("webglcontextlost", gt, !1), e.addEventListener("webglcontextrestored", vt, !1), e.addEventListener("webglcontextcreationerror", yt, !1), null === dt) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === m.isWebGL1Renderer && e.shift(), dt = ft(e, t), null === dt) throw ft(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === dt.getShaderPrecisionFormat && (dt.getShaderPrecisionFormat = function () {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }

            function pt() {
                H = new rx(dt), V = new j_(dt, H, t), H.init(V), ut = new tM(dt, H, V), G = new Zw(dt, H, V), W = new ax, $ = new Fw, X = new Qw(dt, H, G, $, V, ut, W), q = new V_(m), Y = new ix(m), K = new k_(dt, V), ct = new U_(dt, H, K, V), J = new sx(dt, K, W, ct), Z = new hx(dt, J, K, W), ot = new cx(dt, V, X), it = new H_($), Q = new Iw(m, q, Y, H, V, ct, it), tt = new aM(m, $), et = new Bw, nt = new $w(H, V), st = new z_(m, q, Y, G, Z, c, o), rt = new Jw(m, Z, V), ht = new lM(dt, W, V, G), at = new B_(dt, H, W, V), lt = new ox(dt, H, W, V), W.programs = Q.programs, m.capabilities = V, m.extensions = H, m.properties = $, m.renderLists = et, m.shadowMap = rt, m.state = G, m.info = W
            }
            pt();
            const mt = new oM(m, dt);

            function gt(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
            }

            function vt() {
                console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
                const t = W.autoReset,
                    e = rt.enabled,
                    n = rt.autoUpdate,
                    i = rt.needsUpdate,
                    r = rt.type;
                pt(), W.autoReset = t, rt.enabled = e, rt.autoUpdate = n, rt.needsUpdate = i, rt.type = r
            }

            function yt(t) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
            }

            function bt(t) {
                const e = t.target;
                e.removeEventListener("dispose", bt),
                    function (t) {
                        (function (t) {
                            const e = $.get(t).programs;
                            void 0 !== e && (e.forEach((function (t) {
                                Q.releaseProgram(t)
                            })), t.isShaderMaterial && Q.releaseShaderCache(t))
                        })(t), $.remove(t)
                    }(e)
            }
            this.xr = mt, this.getContext = function () {
                return dt
            }, this.getContextAttributes = function () {
                return dt.getContextAttributes()
            }, this.forceContextLoss = function () {
                const t = H.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function () {
                const t = H.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function () {
                return D
            }, this.setPixelRatio = function (t) {
                void 0 !== t && (D = t, this.setSize(T, E, !1))
            }, this.getSize = function (t) {
                return t.set(T, E)
            }, this.setSize = function (t, n, i) {
                mt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, E = n, e.width = Math.floor(t * D), e.height = Math.floor(n * D), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
            }, this.getDrawingBufferSize = function (t) {
                return t.set(T * D, E * D).floor()
            }, this.setDrawingBufferSize = function (t, n, i) {
                T = t, E = n, D = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
            }, this.getCurrentViewport = function (t) {
                return t.copy(w)
            }, this.getViewport = function (t) {
                return t.copy(P)
            }, this.setViewport = function (t, e, n, i) {
                t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i), G.viewport(w.copy(P).multiplyScalar(D).floor())
            }, this.getScissor = function (t) {
                return t.copy(L)
            }, this.setScissor = function (t, e, n, i) {
                t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, n, i), G.scissor(M.copy(L).multiplyScalar(D).floor())
            }, this.getScissorTest = function () {
                return R
            }, this.setScissorTest = function (t) {
                G.setScissorTest(R = t)
            }, this.setOpaqueSort = function (t) {
                C = t
            }, this.setTransparentSort = function (t) {
                A = t
            }, this.getClearColor = function (t) {
                return t.copy(st.getClearColor())
            }, this.setClearColor = function () {
                st.setClearColor.apply(st, arguments)
            }, this.getClearAlpha = function () {
                return st.getClearAlpha()
            }, this.setClearAlpha = function () {
                st.setClearAlpha.apply(st, arguments)
            }, this.clear = function (t = !0, e = !0, n = !0) {
                let i = 0;
                t && (i |= 16384), e && (i |= 256), n && (i |= 1024), dt.clear(i)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.dispose = function () {
                e.removeEventListener("webglcontextlost", gt, !1), e.removeEventListener("webglcontextrestored", vt, !1), e.removeEventListener("webglcontextcreationerror", yt, !1), et.dispose(), nt.dispose(), $.dispose(), q.dispose(), Y.dispose(), Z.dispose(), ct.dispose(), ht.dispose(), Q.dispose(), mt.dispose(), mt.removeEventListener("sessionstart", xt), mt.removeEventListener("sessionend", wt), F && (F.dispose(), F = null), Mt.stop()
            }, this.renderBufferDirect = function (t, e, n, i, r, s) {
                null === e && (e = B);
                const o = r.isMesh && r.matrixWorld.determinant() < 0,
                    a = function (t, e, n, i, r) {
                        !0 !== e.isScene && (e = B), X.resetTextureUnits();
                        const s = e.fog,
                            o = i.isMeshStandardMaterial ? e.environment : null,
                            a = null === b ? m.outputEncoding : !0 === b.isXRRenderTarget ? b.texture.encoding : xv,
                            l = (i.isMeshStandardMaterial ? Y : q).get(i.envMap || o),
                            u = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                            c = !!i.normalMap && !!n.attributes.tangent,
                            h = !!n.morphAttributes.position,
                            f = !!n.morphAttributes.normal,
                            p = !!n.morphAttributes.color,
                            g = i.toneMapped ? m.toneMapping : ig,
                            v = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                            y = void 0 !== v ? v.length : 0,
                            w = $.get(i),
                            M = d.state.lights;
                        if (!0 === O && (!0 === I || t !== x)) {
                            const e = t === x && i.id === _;
                            it.setState(i, t, e)
                        }
                        let S = !1;
                        i.version === w.__version ? w.needsLights && w.lightsStateVersion !== M.state.version || w.outputEncoding !== a || r.isInstancedMesh && !1 === w.instancing ? S = !0 : r.isInstancedMesh || !0 !== w.instancing ? r.isSkinnedMesh && !1 === w.skinning ? S = !0 : r.isSkinnedMesh || !0 !== w.skinning ? w.envMap !== l || !0 === i.fog && w.fog !== s ? S = !0 : void 0 === w.numClippingPlanes || w.numClippingPlanes === it.numPlanes && w.numIntersection === it.numIntersection ? (w.vertexAlphas !== u || w.vertexTangents !== c || w.morphTargets !== h || w.morphNormals !== f || w.morphColors !== p || w.toneMapping !== g || !0 === V.isWebGL2 && w.morphTargetsCount !== y) && (S = !0) : S = !0 : S = !0 : S = !0 : (S = !0, w.__version = i.version);
                        let T = w.currentProgram;
                        !0 === S && (T = Ct(i, e, r));
                        let C = !1,
                            A = !1,
                            P = !1;
                        const L = T.getUniforms(),
                            R = w.uniforms;
                        if (G.useProgram(T.program) && (C = !0, A = !0, P = !0), i.id !== _ && (_ = i.id, A = !0), C || x !== t) {
                            if (L.setValue(dt, "projectionMatrix", t.projectionMatrix), V.logarithmicDepthBuffer && L.setValue(dt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), x !== t && (x = t, A = !0, P = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                                const e = L.map.cameraPosition;
                                void 0 !== e && e.setValue(dt, U.setFromMatrixPosition(t.matrixWorld))
                            } (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && L.setValue(dt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && L.setValue(dt, "viewMatrix", t.matrixWorldInverse)
                        }
                        if (r.isSkinnedMesh) {
                            L.setOptional(dt, r, "bindMatrix"), L.setOptional(dt, r, "bindMatrixInverse");
                            const t = r.skeleton;
                            t && (V.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), L.setValue(dt, "boneTexture", t.boneTexture, X), L.setValue(dt, "boneTextureSize", t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        const k = n.morphAttributes;
                        var N, z;
                        if ((void 0 !== k.position || void 0 !== k.normal || void 0 !== k.color && !0 === V.isWebGL2) && ot.update(r, n, i, T), (A || w.receiveShadow !== r.receiveShadow) && (w.receiveShadow = r.receiveShadow, L.setValue(dt, "receiveShadow", r.receiveShadow)), i.isMeshGouraudMaterial && null !== i.envMap && (R.envMap.value = l, R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), A && (L.setValue(dt, "toneMappingExposure", m.toneMappingExposure), w.needsLights && (z = P, (N = R).ambientLightColor.needsUpdate = z, N.lightProbe.needsUpdate = z, N.directionalLights.needsUpdate = z, N.directionalLightShadows.needsUpdate = z, N.pointLights.needsUpdate = z, N.pointLightShadows.needsUpdate = z, N.spotLights.needsUpdate = z, N.spotLightShadows.needsUpdate = z, N.rectAreaLights.needsUpdate = z, N.hemisphereLights.needsUpdate = z), s && !0 === i.fog && tt.refreshFogUniforms(R, s), tt.refreshMaterialUniforms(R, i, D, E, F), mw.upload(dt, w.uniformsList, R, X)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (mw.upload(dt, w.uniformsList, R, X), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && L.setValue(dt, "center", r.center), L.setValue(dt, "modelViewMatrix", r.modelViewMatrix), L.setValue(dt, "normalMatrix", r.normalMatrix), L.setValue(dt, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                            const t = i.uniformsGroups;
                            for (let e = 0, n = t.length; e < n; e++)
                                if (V.isWebGL2) {
                                    const n = t[e];
                                    ht.update(n, T), ht.bind(n, T)
                                } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return T
                    }(t, e, n, i, r);
                G.setMaterial(i, o);
                let l = n.index;
                const u = n.attributes.position;
                if (null === l) {
                    if (void 0 === u || 0 === u.count) return
                } else if (0 === l.count) return;
                let c, h = 1;
                !0 === i.wireframe && (l = J.getWireframeAttribute(n), h = 2), ct.setup(r, i, a, n, l);
                let f = at;
                null !== l && (c = K.get(l), f = lt, f.setIndex(c));
                const p = null !== l ? l.count : u.count,
                    g = n.drawRange.start * h,
                    v = n.drawRange.count * h,
                    y = null !== s ? s.start * h : 0,
                    w = null !== s ? s.count * h : 1 / 0,
                    M = Math.max(g, y),
                    S = Math.min(p, g + v, y + w) - 1,
                    T = Math.max(0, S - M + 1);
                if (0 !== T) {
                    if (r.isMesh) !0 === i.wireframe ? (G.setLineWidth(i.wireframeLinewidth * j()), f.setMode(1)) : f.setMode(4);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1), G.setLineWidth(t * j()), r.isLineSegments ? f.setMode(1) : r.isLineLoop ? f.setMode(2) : f.setMode(3)
                    } else r.isPoints ? f.setMode(0) : r.isSprite && f.setMode(4);
                    if (r.isInstancedMesh) f.renderInstances(M, T, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        f.renderInstances(M, T, t)
                    } else f.render(M, T)
                }
            }, this.compile = function (t, e) {
                function n(t, e, n) {
                    !0 === t.transparent && t.side === Mm ? (t.side = wm, t.needsUpdate = !0, Ct(t, e, n), t.side = xm, t.needsUpdate = !0, Ct(t, e, n), t.side = Mm) : Ct(t, e, n)
                }
                d = nt.get(t), d.init(), p.push(d), t.traverseVisible((function (t) {
                    t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                })), d.setupLights(m.physicallyCorrectLights), t.traverse((function (e) {
                    const i = e.material;
                    if (i)
                        if (Array.isArray(i))
                            for (let r = 0; r < i.length; r++) n(i[r], t, e);
                        else n(i, t, e)
                })), p.pop(), d = null
            };
            let _t = null;

            function xt() {
                Mt.stop()
            }

            function wt() {
                Mt.start()
            }
            const Mt = new R_;

            function St(t, e, n, i) {
                if (!1 === t.visible) return;
                if (t.layers.test(e.layers))
                    if (t.isGroup) n = t.renderOrder;
                    else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || k.intersectsSprite(t)) {
                            i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(N);
                            const e = Z.update(t),
                                r = t.material;
                            r.visible && h.push(t, e, r, n, U.z, null)
                        }
                    } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== W.render.frame && (t.skeleton.update(), t.skeleton.frame = W.render.frame), !t.frustumCulled || k.intersectsObject(t))) {
                        i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(N);
                        const e = Z.update(t),
                            r = t.material;
                        if (Array.isArray(r)) {
                            const i = e.groups;
                            for (let s = 0, o = i.length; s < o; s++) {
                                const o = i[s],
                                    a = r[o.materialIndex];
                                a && a.visible && h.push(t, e, a, n, U.z, o)
                            }
                        } else r.visible && h.push(t, e, r, n, U.z, null)
                    }
                const r = t.children;
                for (let t = 0, s = r.length; t < s; t++) St(r[t], e, n, i)
            }

            function Tt(t, e, n, i) {
                const r = t.opaque,
                    o = t.transmissive,
                    a = t.transparent;
                d.setupLightsView(n), o.length > 0 && function (t, e, n) {
                    const i = V.isWebGL2;
                    null === F && (F = new my(1, 1, {
                        generateMipmaps: !0,
                        type: H.has("EXT_color_buffer_half_float") ? Pg : Mg,
                        minFilter: wg,
                        samples: i && !0 === s ? 4 : 0
                    })), m.getDrawingBufferSize(z), i ? F.setSize(z.x, z.y) : F.setSize(Vv(z.x), Vv(z.y));
                    const r = m.getRenderTarget();
                    m.setRenderTarget(F), m.clear();
                    const o = m.toneMapping;
                    m.toneMapping = ig, Et(t, e, n), m.toneMapping = o, X.updateMultisampleRenderTarget(F), X.updateRenderTargetMipmap(F), m.setRenderTarget(r)
                }(r, e, n), i && G.viewport(w.copy(i)), r.length > 0 && Et(r, e, n), o.length > 0 && Et(o, e, n), a.length > 0 && Et(a, e, n), G.buffers.depth.setTest(!0), G.buffers.depth.setMask(!0), G.buffers.color.setMask(!0), G.setPolygonOffset(!1)
            }

            function Et(t, e, n) {
                const i = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r],
                        o = s.object,
                        a = s.geometry,
                        l = null === i ? s.material : i,
                        u = s.group;
                    o.layers.test(n.layers) && Dt(o, e, n, a, l, u)
                }
            }

            function Dt(t, e, n, i, r, s) {
                t.onBeforeRender(m, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(m, e, n, i, t, s), !0 === r.transparent && r.side === Mm ? (r.side = wm, r.needsUpdate = !0, m.renderBufferDirect(n, e, i, r, t, s), r.side = xm, r.needsUpdate = !0, m.renderBufferDirect(n, e, i, r, t, s), r.side = Mm) : m.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(m, e, n, i, r, s)
            }

            function Ct(t, e, n) {
                !0 !== e.isScene && (e = B);
                const i = $.get(t),
                    r = d.state.lights,
                    s = d.state.shadowsArray,
                    o = r.state.version,
                    a = Q.getParameters(t, r.state, s, e, n),
                    l = Q.getProgramCacheKey(a);
                let u = i.programs;
                i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? Y : q).get(t.envMap || i.environment), void 0 === u && (t.addEventListener("dispose", bt), u = new Map, i.programs = u);
                let c = u.get(l);
                if (void 0 !== c) {
                    if (i.currentProgram === c && i.lightsStateVersion === o) return At(t, a), c
                } else a.uniforms = Q.getUniforms(t), t.onBuild(n, a, m), t.onBeforeCompile(a, m), c = Q.acquireProgram(a, l), u.set(l, c), i.uniforms = a.uniforms;
                const h = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = it.uniform), At(t, a), i.needsLights = function (t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t), i.lightsStateVersion = o, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotLightMatrix.value = r.state.spotLightMatrix, h.spotLightMap.value = r.state.spotLightMap, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const f = c.getUniforms(),
                    p = mw.seqWithValue(f.seq, h);
                return i.currentProgram = c, i.uniformsList = p, c
            }

            function At(t, e) {
                const n = $.get(t);
                n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
            }
            Mt.setAnimationLoop((function (t) {
                _t && _t(t)
            })), "undefined" != typeof self && Mt.setContext(self), this.setAnimationLoop = function (t) {
                _t = t, mt.setAnimationLoop(t), null === t ? Mt.stop() : Mt.start()
            }, mt.addEventListener("sessionstart", xt), mt.addEventListener("sessionend", wt), this.render = function (t, e) {
                if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === g) return;
                !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === mt.enabled && !0 === mt.isPresenting && (!0 === mt.cameraAutoUpdate && mt.updateCamera(e), e = mt.getCamera()), !0 === t.isScene && t.onBeforeRender(m, t, e, b), d = nt.get(t, p.length), d.init(), p.push(d), N.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), k.setFromProjectionMatrix(N), I = this.localClippingEnabled, O = it.init(this.clippingPlanes, I, e), h = et.get(t, f.length), h.init(), f.push(h), St(t, e, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(C, A), !0 === O && it.beginShadows();
                const n = d.state.shadowsArray;
                if (rt.render(n, t, e), !0 === O && it.endShadows(), !0 === this.info.autoReset && this.info.reset(), st.render(h, t), d.setupLights(m.physicallyCorrectLights), e.isArrayCamera) {
                    const n = e.cameras;
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        Tt(h, t, i, i.viewport)
                    }
                } else Tt(h, t, e);
                null !== b && (X.updateMultisampleRenderTarget(b), X.updateRenderTargetMipmap(b)), !0 === t.isScene && t.onAfterRender(m, t, e), ct.resetDefaultState(), _ = -1, x = null, p.pop(), d = p.length > 0 ? p[p.length - 1] : null, f.pop(), h = f.length > 0 ? f[f.length - 1] : null
            }, this.getActiveCubeFace = function () {
                return v
            }, this.getActiveMipmapLevel = function () {
                return y
            }, this.getRenderTarget = function () {
                return b
            }, this.setRenderTargetTextures = function (t, e, n) {
                $.get(t.texture).__webglTexture = e, $.get(t.depthTexture).__webglTexture = n;
                const i = $.get(t);
                i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === H.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1))
            }, this.setRenderTargetFramebuffer = function (t, e) {
                const n = $.get(t);
                n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
            }, this.setRenderTarget = function (t, e = 0, n = 0) {
                b = t, v = e, y = n;
                let i = !0,
                    r = null,
                    s = !1,
                    o = !1;
                if (t) {
                    const n = $.get(t);
                    void 0 !== n.__useDefaultFramebuffer ? (G.bindFramebuffer(36160, null), i = !1) : void 0 === n.__webglFramebuffer ? X.setupRenderTarget(t) : n.__hasExternalTextures && X.rebindTextures(t, $.get(t.texture).__webglTexture, $.get(t.depthTexture).__webglTexture);
                    const a = t.texture;
                    (a.isData3DTexture || a.isDataArrayTexture || a.isCompressedArrayTexture) && (o = !0);
                    const l = $.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (r = l[e], s = !0) : r = V.isWebGL2 && t.samples > 0 && !1 === X.useMultisampledRTT(t) ? $.get(t).__webglMultisampledFramebuffer : l, w.copy(t.viewport), M.copy(t.scissor), S = t.scissorTest
                } else w.copy(P).multiplyScalar(D).floor(), M.copy(L).multiplyScalar(D).floor(), S = R;
                if (G.bindFramebuffer(36160, r) && V.drawBuffers && i && G.drawBuffers(t, r), G.viewport(w), G.scissor(M), G.setScissorTest(S), s) {
                    const i = $.get(t.texture);
                    dt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                } else if (o) {
                    const i = $.get(t.texture),
                        r = e || 0;
                    dt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                }
                _ = -1
            }, this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
                if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let a = $.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                    G.bindFramebuffer(36160, a);
                    try {
                        const o = t.texture,
                            a = o.format,
                            l = o.type;
                        if (a !== Fg && ut.convert(a) !== dt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const u = l === Pg && (H.has("EXT_color_buffer_half_float") || V.isWebGL2 && H.has("EXT_color_buffer_float"));
                        if (!(l === Mg || ut.convert(l) === dt.getParameter(35738) || l === Ag && (V.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || u)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && dt.readPixels(e, n, i, r, ut.convert(a), ut.convert(l), s)
                    } finally {
                        const t = null !== b ? $.get(b).__webglFramebuffer : null;
                        G.bindFramebuffer(36160, t)
                    }
                }
            }, this.copyFramebufferToTexture = function (t, e, n = 0) {
                const i = Math.pow(2, -n),
                    r = Math.floor(e.image.width * i),
                    s = Math.floor(e.image.height * i);
                X.setTexture2D(e, 0), dt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s), G.unbindTexture()
            }, this.copyTextureToTexture = function (t, e, n, i = 0) {
                const r = e.image.width,
                    s = e.image.height,
                    o = ut.convert(n.format),
                    a = ut.convert(n.type);
                X.setTexture2D(n, 0), dt.pixelStorei(37440, n.flipY), dt.pixelStorei(37441, n.premultiplyAlpha), dt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? dt.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? dt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : dt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && dt.generateMipmap(3553), G.unbindTexture()
            }, this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const s = t.max.x - t.min.x + 1,
                    o = t.max.y - t.min.y + 1,
                    a = t.max.z - t.min.z + 1,
                    l = ut.convert(i.format),
                    u = ut.convert(i.type);
                let c;
                if (i.isData3DTexture) X.setTexture3D(i, 0), c = 32879;
                else {
                    if (!i.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    X.setTexture2DArray(i, 0), c = 35866
                }
                dt.pixelStorei(37440, i.flipY), dt.pixelStorei(37441, i.premultiplyAlpha), dt.pixelStorei(3317, i.unpackAlignment);
                const h = dt.getParameter(3314),
                    d = dt.getParameter(32878),
                    f = dt.getParameter(3316),
                    p = dt.getParameter(3315),
                    g = dt.getParameter(32877),
                    v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                dt.pixelStorei(3314, v.width), dt.pixelStorei(32878, v.height), dt.pixelStorei(3316, t.min.x), dt.pixelStorei(3315, t.min.y), dt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isData3DTexture ? dt.texSubImage3D(c, r, e.x, e.y, e.z, s, o, a, l, u, v.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), dt.compressedTexSubImage3D(c, r, e.x, e.y, e.z, s, o, a, l, v.data)) : dt.texSubImage3D(c, r, e.x, e.y, e.z, s, o, a, l, u, v), dt.pixelStorei(3314, h), dt.pixelStorei(32878, d), dt.pixelStorei(3316, f), dt.pixelStorei(3315, p), dt.pixelStorei(32877, g), 0 === r && i.generateMipmaps && dt.generateMipmap(c), G.unbindTexture()
            }, this.initTexture = function (t) {
                t.isCubeTexture ? X.setTextureCube(t, 0) : t.isData3DTexture ? X.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? X.setTexture2DArray(t, 0) : X.setTexture2D(t, 0), G.unbindTexture()
            }, this.resetState = function () {
                v = 0, y = 0, b = null, G.reset(), ct.reset()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        } (class extends uM { }).prototype.isWebGL1Renderer = !0;
        class cM extends _b {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.backgroundBlurriness = this.backgroundBlurriness), e
            }
            get autoUpdate() {
                return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
            }
            set autoUpdate(t) {
                console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = t
            }
        }
        class hM {
            constructor(t, e) {
                this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Av, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = Nv()
            }
            onUploadCallback() { }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t, this
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
            }
            copyAt(t, e, n) {
                t *= this.stride, n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Nv()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(e, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Nv()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const dM = new by;
        class fM {
            constructor(t, e, n, i = !1) {
                this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++) dM.fromBufferAttribute(this, e), dM.applyMatrix4(t), this.setXYZ(e, dM.x, dM.y, dM.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) dM.fromBufferAttribute(this, e), dM.applyNormalMatrix(t), this.setXYZ(e, dM.x, dM.y, dM.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) dM.fromBufferAttribute(this, e), dM.transformDirection(t), this.setXYZ(e, dM.x, dM.y, dM.z);
                return this
            }
            setX(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
            }
            setY(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }
            setZ(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }
            setW(t, e) {
                return this.normalized && (e = Wv(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }
            getX(t) {
                let e = this.data.array[t * this.data.stride + this.offset];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            getY(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 1];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            getZ(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 2];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            getW(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 3];
                return this.normalized && (e = Gv(e, this.array)), e
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = Wv(e, this.array), n = Wv(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            }
            setXYZ(t, e, n, i) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = Wv(e, this.array), n = Wv(n, this.array), i = Wv(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
            }
            setXYZW(t, e, n, i, r) {
                return t = t * this.data.stride + this.offset, this.normalized && (e = Wv(e, this.array), n = Wv(n, this.array), i = Wv(i, this.array), r = Wv(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
            }
            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return new Nb(new this.array.constructor(t), this.itemSize, this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new fM(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const pM = new by,
            mM = new py,
            gM = new py,
            vM = new by,
            yM = new Yy;
        class bM extends d_ {
            constructor(t, e) {
                super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Yy, this.bindMatrixInverse = new Yy
            }
            copy(t, e) {
                return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
            }
            bind(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new py,
                    e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.fromBufferAttribute(e, n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(t, e) {
                const n = this.skeleton,
                    i = this.geometry;
                mM.fromBufferAttribute(i.attributes.skinIndex, t), gM.fromBufferAttribute(i.attributes.skinWeight, t), pM.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const i = gM.getComponent(t);
                    if (0 !== i) {
                        const r = mM.getComponent(t);
                        yM.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(vM.copy(pM).applyMatrix4(yM), i)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class _M extends _b {
            constructor() {
                super(), this.isBone = !0, this.type = "Bone"
            }
        }
        class xM extends fy {
            constructor(t = null, e = 1, n = 1, i, r, s, o, a, l = vg, u = vg, c, h) {
                super(null, s, o, a, l, u, i, r, c, h), this.isDataTexture = !0, this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        const wM = new Yy,
            MM = new Yy;
        class SM {
            constructor(t = [], e = []) {
                this.uuid = Nv(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
            }
            init() {
                const t = this.bones,
                    e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                else if (t.length !== e.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Yy)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new Yy;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones,
                    e = this.boneInverses,
                    n = this.boneMatrices,
                    i = this.boneTexture;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i] ? t[i].matrixWorld : MM;
                    wM.multiplyMatrices(r, e[i]), wM.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new SM(this.bones, this.boneInverses)
            }
            computeBoneTexture() {
                let t = Math.sqrt(4 * this.bones.length);
                t = Hv(t), t = Math.max(t, 4);
                const e = new Float32Array(t * t * 4);
                e.set(this.boneMatrices);
                const n = new xM(e, t, t, Fg, Ag);
                return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
            }
            getBoneByName(t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t) return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let n = 0, i = t.bones.length; n < i; n++) {
                    const i = t.bones[n];
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new _M), this.bones.push(r), this.boneInverses.push((new Yy).fromArray(t.boneInverses[n]))
                }
                return this.init(), this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones,
                    n = this.boneInverses;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i];
                    t.bones.push(r.uuid);
                    const s = n[i];
                    t.boneInverses.push(s.toArray())
                }
                return t
            }
        }
        class TM extends Nb {
            constructor(t, e, n, i = 1) {
                super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
            }
            copy(t) {
                return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }
        const EM = new Yy,
            DM = new Yy,
            CM = [],
            AM = new Yy,
            PM = new d_;
        class LM extends d_ {
            constructor(t, e, n) {
                super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new TM(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
                for (let t = 0; t < n; t++) this.setMatrixAt(t, AM)
            }
            copy(t, e) {
                return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld,
                    i = this.count;
                if (PM.geometry = this.geometry, PM.material = this.material, void 0 !== PM.material)
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, EM), DM.multiplyMatrices(n, EM), PM.matrixWorld = DM, PM.raycast(t, CM);
                        for (let t = 0, n = CM.length; t < n; t++) {
                            const n = CM[t];
                            n.instanceId = r, n.object = this, e.push(n)
                        }
                        CM.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new TM(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() { }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class RM extends kb {
            constructor(t) {
                super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ay(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
            }
        }
        const kM = new by,
            OM = new by,
            IM = new Yy,
            FM = new qy,
            NM = new By;
        class zM extends _b {
            constructor(t = new qb, e = new RM) {
                super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [0];
                    for (let t = 1, i = e.count; t < i; t++) kM.fromBufferAttribute(e, t - 1), OM.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += kM.distanceTo(OM);
                    t.setAttribute("lineDistance", new Bb(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = t.params.Line.threshold,
                    s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), NM.copy(n.boundingSphere), NM.applyMatrix4(i), NM.radius += r, !1 === t.ray.intersectsSphere(NM)) return;
                IM.copy(i).invert(), FM.copy(t.ray).applyMatrix4(IM);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o,
                    l = new by,
                    u = new by,
                    c = new by,
                    h = new by,
                    d = this.isLineSegments ? 2 : 1,
                    f = n.index,
                    p = n.attributes.position;
                if (null !== f)
                    for (let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1; n < i; n += d) {
                        const i = f.getX(n),
                            r = f.getX(n + 1);
                        if (l.fromBufferAttribute(p, i), u.fromBufferAttribute(p, r), FM.distanceSqToSegment(l, u, h, c) > a) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const s = t.ray.origin.distanceTo(h);
                        s < t.near || s > t.far || e.push({
                            distance: s,
                            point: c.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    } else
                    for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) {
                        if (l.fromBufferAttribute(p, n), u.fromBufferAttribute(p, n + 1), FM.distanceSqToSegment(l, u, h, c) > a) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const i = t.ray.origin.distanceTo(h);
                        i < t.near || i > t.far || e.push({
                            distance: i,
                            point: c.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }
        const UM = new by,
            BM = new by;
        class jM extends zM {
            constructor(t, e) {
                super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position,
                        n = [];
                    for (let t = 0, i = e.count; t < i; t += 2) UM.fromBufferAttribute(e, t), BM.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + UM.distanceTo(BM);
                    t.setAttribute("lineDistance", new Bb(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class HM extends zM {
            constructor(t, e) {
                super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
            }
        }
        class VM extends kb {
            constructor(t) {
                super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ay(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
            }
        }
        const GM = new Yy,
            WM = new qy,
            $M = new By,
            XM = new by;
        class qM extends _b {
            constructor(t = new qb, e = new VM) {
                super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
            }
            raycast(t, e) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = t.params.Points.threshold,
                    s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), $M.copy(n.boundingSphere), $M.applyMatrix4(i), $M.radius += r, !1 === t.ray.intersectsSphere($M)) return;
                GM.copy(i).invert(), WM.copy(t.ray).applyMatrix4(GM);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o,
                    l = n.index,
                    u = n.attributes.position;
                if (null !== l)
                    for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                        const r = l.getX(n);
                        XM.fromBufferAttribute(u, r), YM(XM, r, a, i, t, e, this)
                    } else
                    for (let n = Math.max(0, s.start), r = Math.min(u.count, s.start + s.count); n < r; n++) XM.fromBufferAttribute(u, n), YM(XM, n, a, i, t, e, this)
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes,
                    e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }

        function YM(t, e, n, i, r, s, o) {
            const a = WM.distanceSqToPoint(t);
            if (a < n) {
                const n = new by;
                WM.closestPointToPoint(t, n), n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far) return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: e,
                    face: null,
                    object: o
                })
            }
        }
        class KM extends kb {
            constructor(t) {
                super(), this.isMeshStandardMaterial = !0, this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new ay(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ay(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Sv, this.normalScale = new Xv(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
            }
        }
        class JM extends KM {
            constructor(t) {
                super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Xv(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function () {
                        return zv(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function (t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ay(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ay(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ay(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(t)
            }
            get sheen() {
                return this._sheen
            }
            set sheen(t) {
                this._sheen > 0 != t > 0 && this.version++, this._sheen = t
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(t) {
                this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
            }
            get transmission() {
                return this._transmission
            }
            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++, this._transmission = t
            }
            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
            }
        }

        function ZM(t, e, n) {
            return tS(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        }

        function QM(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        }

        function tS(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        }

        function eS(t) {
            const e = t.length,
                n = new Array(e);
            for (let t = 0; t !== e; ++t) n[t] = t;
            return n.sort((function (e, n) {
                return t[e] - t[n]
            })), n
        }

        function nS(t, e, n) {
            const i = t.length,
                r = new t.constructor(i);
            for (let s = 0, o = 0; o !== i; ++s) {
                const i = n[s] * e;
                for (let n = 0; n !== e; ++n) r[o++] = t[i + n]
            }
            return r
        }

        function iS(t, e, n, i) {
            let r = 1,
                s = t[0];
            for (; void 0 !== s && void 0 === s[i];) s = t[r++];
            if (void 0 === s) return;
            let o = s[i];
            if (void 0 !== o)
                if (Array.isArray(o))
                    do {
                        o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++]
                    } while (void 0 !== s);
                else if (void 0 !== o.toArray)
                    do {
                        o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++]
                    } while (void 0 !== s);
                else
                    do {
                        o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++]
                    } while (void 0 !== s)
        }
        class rS {
            constructor(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex,
                    i = e[n],
                    r = e[n - 1];
                t: {
                    e: {
                        let s; n: {
                            i: if (!(t < i)) {
                                for (let s = n + 2; ;) {
                                    if (void 0 === i) {
                                        if (t < r) break i;
                                        return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                    }
                                    if (n === s) break;
                                    if (r = i, i = e[++n], t < i) break e
                                }
                                s = e.length;
                                break n
                            } if (t >= r) break t;
                            {
                                const o = e[1];
                                t < o && (n = 2, r = o);
                                for (let s = n - 2; ;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === s) break;
                                    if (i = r, r = e[--n - 1], t >= r) break e
                                }
                                s = n, n = 0
                            }
                        }
                        for (; n < s;) {
                            const i = n + s >>> 1;
                            t < e[i] ? s = i : n = i + 1
                        }
                        if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (void 0 === i) return n = e.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = t * i;
                for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() { }
        }
        class sS extends rS {
            constructor(t, e, n, i) {
                super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: 2400,
                    endingEnd: 2400
                }
            }
            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2,
                    s = t + 1,
                    o = i[r],
                    a = i[s];
                if (void 0 === o) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t, o = 2 * e - n;
                        break;
                    case 2402:
                        r = i.length - 2, o = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t, o = n
                }
                if (void 0 === a) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        s = t, a = 2 * n - e;
                        break;
                    case 2402:
                        s = 1, a = n + i[1] - i[0];
                        break;
                    default:
                        s = t - 1, a = e
                }
                const l = .5 * (n - e),
                    u = this.valueSize;
                this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * u, this._offsetNext = s * u
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = t * o,
                    l = a - o,
                    u = this._offsetPrev,
                    c = this._offsetNext,
                    h = this._weightPrev,
                    d = this._weightNext,
                    f = (n - e) / (i - e),
                    p = f * f,
                    m = p * f,
                    g = -h * m + 2 * h * p - h * f,
                    v = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1,
                    y = (-1 - d) * m + (1.5 + d) * p + .5 * f,
                    b = d * m - d * p;
                for (let t = 0; t !== o; ++t) r[t] = g * s[u + t] + v * s[l + t] + y * s[a + t] + b * s[c + t];
                return r
            }
        }
        class oS extends rS {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = t * o,
                    l = a - o,
                    u = (n - e) / (i - e),
                    c = 1 - u;
                for (let t = 0; t !== o; ++t) r[t] = s[l + t] * c + s[a + t] * u;
                return r
            }
        }
        class aS extends rS {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class lS {
            constructor(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = QM(e, this.TimeBufferType), this.values = QM(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: QM(t.times, Array),
                        values: QM(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new aS(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new oS(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new sS(this.times, this.values, this.getValueSize(), t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                    case yv:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case bv:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case _v:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return yv;
                    case this.InterpolantFactoryMethodLinear:
                        return bv;
                    case this.InterpolantFactoryMethodSmooth:
                        return _v
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times,
                    i = n.length;
                let r = 0,
                    s = i - 1;
                for (; r !== i && n[r] < t;) ++r;
                for (; - 1 !== s && n[s] > e;) --s;
                if (++s, 0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1), r = s - 1);
                    const t = this.getValueSize();
                    this.times = ZM(n, r, s), this.values = ZM(this.values, r * t, s * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                const n = this.times,
                    i = this.values,
                    r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                let s = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && tS(i))
                    for (let e = 0, n = i.length; e !== n; ++e) {
                        const n = i[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = ZM(this.times),
                    e = ZM(this.values),
                    n = this.getValueSize(),
                    i = this.getInterpolation() === _v,
                    r = t.length - 1;
                let s = 1;
                for (let o = 1; o < r; ++o) {
                    let r = !1;
                    const a = t[o];
                    if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                        if (i) r = !0;
                        else {
                            const t = o * n,
                                i = t - n,
                                s = t + n;
                            for (let o = 0; o !== n; ++o) {
                                const n = e[t + o];
                                if (n !== e[i + o] || n !== e[s + o]) {
                                    r = !0;
                                    break
                                }
                            }
                        } if (r) {
                            if (o !== s) {
                                t[s] = t[o];
                                const i = o * n,
                                    r = s * n;
                                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                            } ++s
                        }
                }
                if (r > 0) {
                    t[s] = t[r];
                    for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];
                    ++s
                }
                return s !== t.length ? (this.times = ZM(t, 0, s), this.values = ZM(e, 0, s * n)) : (this.times = t, this.values = e), this
            }
            clone() {
                const t = ZM(this.times, 0),
                    e = ZM(this.values, 0),
                    n = new (0, this.constructor)(this.name, t, e);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        lS.prototype.TimeBufferType = Float32Array, lS.prototype.ValueBufferType = Float32Array, lS.prototype.DefaultInterpolation = bv;
        class uS extends lS { }
        uS.prototype.ValueTypeName = "bool", uS.prototype.ValueBufferType = Array, uS.prototype.DefaultInterpolation = yv, uS.prototype.InterpolantFactoryMethodLinear = void 0, uS.prototype.InterpolantFactoryMethodSmooth = void 0;
        class cS extends lS { }
        cS.prototype.ValueTypeName = "color";
        class hS extends lS { }
        hS.prototype.ValueTypeName = "number";
        class dS extends rS {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = (n - e) / (i - e);
                let l = t * o;
                for (let t = l + o; l !== t; l += 4) yy.slerpFlat(r, 0, s, l - o, s, l, a);
                return r
            }
        }
        class fS extends lS {
            InterpolantFactoryMethodLinear(t) {
                return new dS(this.times, this.values, this.getValueSize(), t)
            }
        }
        fS.prototype.ValueTypeName = "quaternion", fS.prototype.DefaultInterpolation = bv, fS.prototype.InterpolantFactoryMethodSmooth = void 0;
        class pS extends lS { }
        pS.prototype.ValueTypeName = "string", pS.prototype.ValueBufferType = Array, pS.prototype.DefaultInterpolation = yv, pS.prototype.InterpolantFactoryMethodLinear = void 0, pS.prototype.InterpolantFactoryMethodSmooth = void 0;
        class mS extends lS { }
        mS.prototype.ValueTypeName = "vector";
        class gS {
            constructor(t, e = -1, n, i = 2500) {
                this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Nv(), this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = [],
                    n = t.tracks,
                    i = 1 / (t.fps || 1);
                for (let t = 0, r = n.length; t !== r; ++t) e.push(vS(n[t]).scale(i));
                const r = new this(t.name, t.duration, e, t.blendMode);
                return r.uuid = t.uuid, r
            }
            static toJSON(t) {
                const e = [],
                    n = t.tracks,
                    i = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode
                    };
                for (let t = 0, i = n.length; t !== i; ++t) e.push(lS.toJSON(n[t]));
                return i
            }
            static CreateFromMorphTargetSequence(t, e, n, i) {
                const r = e.length,
                    s = [];
                for (let t = 0; t < r; t++) {
                    let o = [],
                        a = [];
                    o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                    const l = eS(o);
                    o = nS(o, 1, l), a = nS(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new hS(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                }
                return new this(t, -1, s)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e) return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const i = {},
                    r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e],
                        s = n.name.match(r);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = i[t];
                        e || (i[t] = e = []), e.push(n)
                    }
                }
                const s = [];
                for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                return s
            }
            static parseAnimation(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function (t, e, n, i, r) {
                    if (0 !== n.length) {
                        const s = [],
                            o = [];
                        iS(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                    }
                },
                    i = [],
                    r = t.name || "default",
                    s = t.fps || 30,
                    o = t.blendMode;
                let a = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const r = l[t].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < r.length; e++)
                                if (r[e].morphTargets)
                                    for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = [],
                                    s = [];
                                for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                    const i = r[e];
                                    t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new hS(".morphTargetInfluence[" + n + "]", t, s))
                            }
                            a = t.length * s
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            n(mS, s + ".position", r, "pos", i), n(fS, s + ".quaternion", r, "rot", i), n(mS, s + ".scale", r, "scl", i)
                        }
                }
                return 0 === i.length ? null : new this(r, a, i, o)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new this.constructor(this.name, this.duration, t, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function vS(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function (t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return hS;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return mS;
                    case "color":
                        return cS;
                    case "quaternion":
                        return fS;
                    case "bool":
                    case "boolean":
                        return uS;
                    case "string":
                        return pS
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = [],
                    n = [];
                iS(t.keys, e, n, "value"), t.times = e, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }
        const yS = {
            enabled: !1,
            files: {},
            add: function (t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function (t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function (t) {
                delete this.files[t]
            },
            clear: function () {
                this.files = {}
            }
        };
        class bS {
            constructor(t, e, n) {
                const i = this;
                let r, s = !1,
                    o = 0,
                    a = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
                    a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), s = !0
                }, this.itemEnd = function (t) {
                    o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function (t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function (t) {
                    return r ? r(t) : t
                }, this.setURLModifier = function (t) {
                    return r = t, this
                }, this.addHandler = function (t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function (t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function (t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e],
                            i = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return i
                    }
                    return null
                }
            }
        }
        const _S = new bS;
        class xS {
            constructor(t) {
                this.manager = void 0 !== t ? t : _S, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() { }
            loadAsync(t, e) {
                const n = this;
                return new Promise((function (i, r) {
                    n.load(t, i, e, r)
                }))
            }
            parse() { }
            setCrossOrigin(t) {
                return this.crossOrigin = t, this
            }
            setWithCredentials(t) {
                return this.withCredentials = t, this
            }
            setPath(t) {
                return this.path = t, this
            }
            setResourcePath(t) {
                return this.resourcePath = t, this
            }
            setRequestHeader(t) {
                return this.requestHeader = t, this
            }
        }
        const wS = {};
        class MS extends Error {
            constructor(t, e) {
                super(t), this.response = e
            }
        }
        class SS extends xS {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = yS.get(t);
                if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                    e && e(r), this.manager.itemEnd(t)
                }), 0), r;
                if (void 0 !== wS[t]) return void wS[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                wS[t] = [], wS[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                const s = new Request(t, {
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                }),
                    o = this.mimeType,
                    a = this.responseType;
                fetch(s).then((e => {
                    if (200 === e.status || 0 === e.status) {
                        if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                        const n = wS[t],
                            i = e.body.getReader(),
                            r = e.headers.get("Content-Length"),
                            s = r ? parseInt(r) : 0,
                            o = 0 !== s;
                        let a = 0;
                        const l = new ReadableStream({
                            start(t) {
                                ! function e() {
                                    i.read().then((({
                                        done: i,
                                        value: r
                                    }) => {
                                        if (i) t.close();
                                        else {
                                            a += r.byteLength;
                                            const i = new ProgressEvent("progress", {
                                                lengthComputable: o,
                                                loaded: a,
                                                total: s
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(i)
                                            }
                                            t.enqueue(r), e()
                                        }
                                    }))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new MS(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
                })).then((t => {
                    switch (a) {
                        case "arraybuffer":
                            return t.arrayBuffer();
                        case "blob":
                            return t.blob();
                        case "document":
                            return t.text().then((t => (new DOMParser).parseFromString(t, o)));
                        case "json":
                            return t.json();
                        default:
                            if (void 0 === o) return t.text();
                            {
                                const e = /charset="?([^;"\s]*)"?/i.exec(o),
                                    n = e && e[1] ? e[1].toLowerCase() : void 0,
                                    i = new TextDecoder(n);
                                return t.arrayBuffer().then((t => i.decode(t)))
                            }
                    }
                })).then((e => {
                    yS.add(t, e);
                    const n = wS[t];
                    delete wS[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onLoad && i.onLoad(e)
                    }
                })).catch((e => {
                    const n = wS[t];
                    if (void 0 === n) throw this.manager.itemError(t), e;
                    delete wS[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    this.manager.itemError(t)
                })).finally((() => {
                    this.manager.itemEnd(t)
                })), this.manager.itemStart(t)
            }
            setResponseType(t) {
                return this.responseType = t, this
            }
            setMimeType(t) {
                return this.mimeType = t, this
            }
        }
        class TS extends xS {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this,
                    s = yS.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                const o = Kv("img");

                function a() {
                    u(), yS.add(t, this), e && e(this), r.manager.itemEnd(t)
                }

                function l(e) {
                    u(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }

                function u() {
                    o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1)
                }
                return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
            }
        }
        class ES extends xS {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new fy,
                    s = new TS(this.manager);
                return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function (t) {
                    r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                }), n, i), r
            }
        }
        class DS extends _b {
            constructor(t, e = 1) {
                super(), this.isLight = !0, this.type = "Light", this.color = new ay(t), this.intensity = e
            }
            dispose() { }
            copy(t, e) {
                return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }
        const CS = new Yy,
            AS = new by,
            PS = new by;
        class LS {
            constructor(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Xv(512, 512), this.map = null, this.mapPass = null, this.matrix = new Yy, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new L_, this._frameExtents = new Xv(1, 1), this._viewportCount = 1, this._viewports = [new py(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = this.matrix;
                AS.setFromMatrixPosition(t.matrixWorld), e.position.copy(AS), PS.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(PS), e.updateMatrixWorld(), CS.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(CS), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(CS)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }
        class RS extends LS {
            constructor() {
                super(new __(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = 2 * Fv * t.angle * this.focus,
                    i = this.mapSize.width / this.mapSize.height,
                    r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t), this.focus = t.focus, this
            }
        }
        class kS extends DS {
            constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
                super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(_b.DefaultUp), this.updateMatrix(), this.target = new _b, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.map = null, this.shadow = new RS
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }
        const OS = new Yy,
            IS = new by,
            FS = new by;
        class NS extends LS {
            constructor() {
                super(new __(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Xv(4, 2), this._viewportCount = 6, this._viewports = [new py(2, 1, 1, 1), new py(0, 1, 1, 1), new py(3, 1, 1, 1), new py(1, 1, 1, 1), new py(3, 0, 1, 1), new py(1, 0, 1, 1)], this._cubeDirections = [new by(1, 0, 0), new by(-1, 0, 0), new by(0, 0, 1), new by(0, 0, -1), new by(0, 1, 0), new by(0, -1, 0)], this._cubeUps = [new by(0, 1, 0), new by(0, 1, 0), new by(0, 1, 0), new by(0, 1, 0), new by(0, 0, 1), new by(0, 0, -1)]
            }
            updateMatrices(t, e = 0) {
                const n = this.camera,
                    i = this.matrix,
                    r = t.distance || n.far;
                r !== n.far && (n.far = r, n.updateProjectionMatrix()), IS.setFromMatrixPosition(t.matrixWorld), n.position.copy(IS), FS.copy(n.position), FS.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(FS), n.updateMatrixWorld(), i.makeTranslation(-IS.x, -IS.y, -IS.z), OS.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(OS)
            }
        }
        class zS extends DS {
            constructor(t, e, n = 0, i = 1) {
                super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new NS
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }
        class US extends LS {
            constructor() {
                super(new G_(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
            }
        }
        class BS extends DS {
            constructor(t, e) {
                super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(_b.DefaultUp), this.updateMatrix(), this.target = new _b, this.shadow = new US
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }
        class jS {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.slice(0, e + 1)
            }
            static resolveURL(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
        }
        class HS extends xS {
            constructor(t) {
                super(t), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t, this
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this,
                    s = yS.get(t);
                if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(s), r.manager.itemEnd(t)
                }), 0), s;
                const o = {};
                o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function (t) {
                    return t.blob()
                })).then((function (t) {
                    return createImageBitmap(t, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function (n) {
                    yS.add(t, n), e && e(n), r.manager.itemEnd(t)
                })).catch((function (e) {
                    i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                })), r.manager.itemStart(t)
            }
        }
        const VS = "\\[\\]\\.:\\/",
            GS = new RegExp("[" + VS + "]", "g"),
            WS = "[^" + VS + "]",
            $S = "[^" + VS.replace("\\.", "") + "]",
            XS = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", WS) + /(WCOD+)?/.source.replace("WCOD", $S) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", WS) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", WS) + "$"),
            qS = ["material", "materials", "bones", "map"];
        class YS {
            constructor(t, e, n) {
                this.path = e, this.parsedPath = n || YS.parseTrackName(e), this.node = YS.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new YS.Composite(t, e, n) : new YS(t, e, n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(GS, "")
            }
            static parseTrackName(t) {
                const e = XS.exec(t);
                if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1); - 1 !== qS.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function (t) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            if (r.name === e || r.uuid === e) return r;
                            const s = n(r.children);
                            if (s) return s
                        }
                        return null
                    },
                        i = n(t.children);
                    if (i) return i
                }
                return null
            }
            _getValue_unavailable() { }
            _setValue_unavailable() { }
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(), this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(), this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath,
                    n = e.objectName,
                    i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = YS.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (let e = 0; e < t.length; e++)
                                if (t[e].name === i) {
                                    i = e;
                                    break
                                } break;
                        case "map":
                            if ("map" in t) {
                                t = t.map;
                                break
                            }
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            t = t.material.map;
                            break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[i]
                    }
                }
                const s = t[i];
                if (void 0 === s) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                }
                let o = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        YS.Composite = class {
            constructor(t, e, n) {
                const i = n || YS.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }, YS.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, YS.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, YS.prototype.GetterByBindingType = [YS.prototype._getValue_direct, YS.prototype._getValue_array, YS.prototype._getValue_arrayElement, YS.prototype._getValue_toArray], YS.prototype.SetterByBindingTypeAndVersioning = [
            [YS.prototype._setValue_direct, YS.prototype._setValue_direct_setNeedsUpdate, YS.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [YS.prototype._setValue_array, YS.prototype._setValue_array_setNeedsUpdate, YS.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [YS.prototype._setValue_arrayElement, YS.prototype._setValue_arrayElement_setNeedsUpdate, YS.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [YS.prototype._setValue_fromArray, YS.prototype._setValue_fromArray_setNeedsUpdate, YS.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ], new Float32Array(1), "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: pm
            }
        })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = pm);
        class KS extends xS {
            constructor(t) {
                super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (t) {
                    return new nT(t)
                })), this.register((function (t) {
                    return new uT(t)
                })), this.register((function (t) {
                    return new cT(t)
                })), this.register((function (t) {
                    return new rT(t)
                })), this.register((function (t) {
                    return new sT(t)
                })), this.register((function (t) {
                    return new oT(t)
                })), this.register((function (t) {
                    return new aT(t)
                })), this.register((function (t) {
                    return new eT(t)
                })), this.register((function (t) {
                    return new lT(t)
                })), this.register((function (t) {
                    return new iT(t)
                })), this.register((function (t) {
                    return new QS(t)
                })), this.register((function (t) {
                    return new hT(t)
                })), this.register((function (t) {
                    return new dT(t)
                }))
            }
            load(t, e, n, i) {
                const r = this;
                let s;
                s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : jS.extractUrlBase(t), this.manager.itemStart(t);
                const o = function (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t), r.manager.itemEnd(t)
                },
                    a = new SS(this.manager);
                a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function (n) {
                    try {
                        r.parse(n, s, (function (n) {
                            e(n), r.manager.itemEnd(t)
                        }), o)
                    } catch (t) {
                        o(t)
                    }
                }), n, o)
            }
            setDRACOLoader(t) {
                return this.dracoLoader = t, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(t) {
                return this.ktx2Loader = t, this
            }
            setMeshoptDecoder(t) {
                return this.meshoptDecoder = t, this
            }
            register(t) {
                return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
            }
            unregister(t) {
                return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
            }
            parse(t, e, n, i) {
                let r;
                const s = {},
                    o = {};
                if ("string" == typeof t) r = JSON.parse(t);
                else if (t instanceof ArrayBuffer)
                    if (jS.decodeText(new Uint8Array(t, 0, 4)) === fT) {
                        try {
                            s[ZS.KHR_BINARY_GLTF] = new pT(t)
                        } catch (t) {
                            return void (i && i(t))
                        }
                        r = JSON.parse(s[ZS.KHR_BINARY_GLTF].content)
                    } else r = JSON.parse(jS.decodeText(new Uint8Array(t)));
                else r = t;
                if (void 0 === r.asset || r.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const a = new NT(r, {
                    path: e || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                a.fileLoader.setRequestHeader(this.requestHeader);
                for (let t = 0; t < this.pluginCallbacks.length; t++) {
                    const e = this.pluginCallbacks[t](a);
                    o[e.name] = e, s[e.name] = !0
                }
                if (r.extensionsUsed)
                    for (let t = 0; t < r.extensionsUsed.length; ++t) {
                        const e = r.extensionsUsed[t],
                            n = r.extensionsRequired || [];
                        switch (e) {
                            case ZS.KHR_MATERIALS_UNLIT:
                                s[e] = new tT;
                                break;
                            case ZS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                s[e] = new yT;
                                break;
                            case ZS.KHR_DRACO_MESH_COMPRESSION:
                                s[e] = new mT(r, this.dracoLoader);
                                break;
                            case ZS.KHR_TEXTURE_TRANSFORM:
                                s[e] = new gT;
                                break;
                            case ZS.KHR_MESH_QUANTIZATION:
                                s[e] = new bT;
                                break;
                            default:
                                n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                a.setExtensions(s), a.setPlugins(o), a.parse(n, i)
            }
            parseAsync(t, e) {
                const n = this;
                return new Promise((function (i, r) {
                    n.parse(t, e, i, r)
                }))
            }
        }

        function JS() {
            let t = {};
            return {
                get: function (e) {
                    return t[e]
                },
                add: function (e, n) {
                    t[e] = n
                },
                remove: function (e) {
                    delete t[e]
                },
                removeAll: function () {
                    t = {}
                }
            }
        }
        const ZS = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class QS {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const t = this.parser,
                    e = this.parser.json.nodes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(t) {
                const e = this.parser,
                    n = "light:" + t;
                let i = e.cache.get(n);
                if (i) return i;
                const r = e.json,
                    s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
                let o;
                const a = new ay(16777215);
                void 0 !== s.color && a.fromArray(s.color);
                const l = void 0 !== s.range ? s.range : 0;
                switch (s.type) {
                    case "directional":
                        o = new BS(a), o.target.position.set(0, 0, -1), o.add(o.target);
                        break;
                    case "point":
                        o = new zS(a), o.distance = l;
                        break;
                    case "spot":
                        o = new kS(a), o.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, o.angle = s.spot.outerConeAngle, o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                }
                return o.position.set(0, 0, 0), o.decay = 2, void 0 !== s.intensity && (o.intensity = s.intensity), o.name = e.createUniqueName(s.name || "light_" + t), i = Promise.resolve(o), e.cache.add(n, i), i
            }
            createNodeAttachment(t) {
                const e = this,
                    n = this.parser,
                    i = n.json.nodes[t],
                    r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function (t) {
                    return n._getNodeRef(e.cache, r, t)
                }))
            }
        }
        class tT {
            constructor() {
                this.name = ZS.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return Ob
            }
            extendParams(t, e, n) {
                const i = [];
                t.color = new ay(1, 1, 1), t.opacity = 1;
                const r = e.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const e = r.baseColorFactor;
                        t.color.fromArray(e), t.opacity = e[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture, wv))
                }
                return Promise.all(i)
            }
        }
        class eT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve()
            }
        }
        class nT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? JM : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                    const t = s.clearcoatNormalTexture.scale;
                    e.clearcoatNormalScale = new Xv(t, t)
                }
                return Promise.all(r)
            }
        }
        class iT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? JM : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return void 0 !== s.iridescenceFactor && (e.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && r.push(n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (e.iridescenceIOR = s.iridescenceIor), void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (e.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (e.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(e, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(r)
            }
        }
        class rT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_SHEEN
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? JM : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [];
                e.sheenColor = new ay(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
                const s = i.extensions[this.name];
                return void 0 !== s.sheenColorFactor && e.sheenColor.fromArray(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && (e.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture, wv)), void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(r)
            }
        }
        class sT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? JM : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(r)
            }
        }
        class oT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_VOLUME
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? JM : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)), e.attenuationDistance = s.attenuationDistance || 1 / 0;
                const o = s.attenuationColor || [1, 1, 1];
                return e.attenuationColor = new ay(o[0], o[1], o[2]), Promise.all(r)
            }
        }
        class aT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_IOR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? JM : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name];
                return e.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
            }
        }
        class lT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? JM : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser,
                    i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    s = i.extensions[this.name];
                e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
                const o = s.specularColorFactor || [1, 1, 1];
                return e.specularColor = new ay(o[0], o[1], o[2]), void 0 !== s.specularColorTexture && r.push(n.assignTexture(e, "specularColorMap", s.specularColorTexture, wv)), Promise.all(r)
            }
        }
        class uT {
            constructor(t) {
                this.parser = t, this.name = ZS.KHR_TEXTURE_BASISU
            }
            loadTexture(t) {
                const e = this.parser,
                    n = e.json,
                    i = n.textures[t];
                if (!i.extensions || !i.extensions[this.name]) return null;
                const r = i.extensions[this.name],
                    s = e.options.ktx2Loader;
                if (!s) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return e.loadTextureImage(t, r.source, s)
            }
        }
        class cT {
            constructor(t) {
                this.parser = t, this.name = ZS.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name,
                    n = this.parser,
                    i = n.json,
                    r = i.textures[t];
                if (!r.extensions || !r.extensions[e]) return null;
                const s = r.extensions[e],
                    o = i.images[s.source];
                let a = n.textureLoader;
                if (o.uri) {
                    const t = n.options.manager.getHandler(o.uri);
                    null !== t && (a = t)
                }
                return this.detectSupport().then((function (r) {
                    if (r) return n.loadTextureImage(t, s.source, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(t)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function (t) {
                    const e = new Image;
                    e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function () {
                        t(1 === e.height)
                    }
                }))), this.isSupported
            }
        }
        class hT {
            constructor(t) {
                this.name = ZS.EXT_MESHOPT_COMPRESSION, this.parser = t
            }
            loadBufferView(t) {
                const e = this.parser.json,
                    n = e.bufferViews[t];
                if (n.extensions && n.extensions[this.name]) {
                    const t = n.extensions[this.name],
                        i = this.parser.getDependency("buffer", t.buffer),
                        r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return i.then((function (e) {
                        const n = t.byteOffset || 0,
                            i = t.byteLength || 0,
                            s = t.count,
                            o = t.byteStride,
                            a = new Uint8Array(e, n, i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, o, a, t.mode, t.filter).then((function (t) {
                            return t.buffer
                        })) : r.ready.then((function () {
                            const e = new ArrayBuffer(s * o);
                            return r.decodeGltfBuffer(new Uint8Array(e), s, o, a, t.mode, t.filter), e
                        }))
                    }))
                }
                return null
            }
        }
        class dT {
            constructor(t) {
                this.name = ZS.EXT_MESH_GPU_INSTANCING, this.parser = t
            }
            createNodeMesh(t) {
                const e = this.parser.json,
                    n = e.nodes[t];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                const i = e.meshes[n.mesh];
                for (const t of i.primitives)
                    if (t.mode !== MT.TRIANGLES && t.mode !== MT.TRIANGLE_STRIP && t.mode !== MT.TRIANGLE_FAN && void 0 !== t.mode) return null;
                const r = n.extensions[this.name].attributes,
                    s = [],
                    o = {};
                for (const t in r) s.push(this.parser.getDependency("accessor", r[t]).then((e => (o[t] = e, o[t]))));
                return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(t)), Promise.all(s).then((t => {
                    const e = t.pop(),
                        n = e.isGroup ? e.children : [e],
                        i = t[0].count,
                        r = [];
                    for (const t of n) {
                        const e = new Yy,
                            n = new by,
                            s = new yy,
                            a = new by(1, 1, 1),
                            l = new LM(t.geometry, t.material, i);
                        for (let t = 0; t < i; t++) o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, t), o.ROTATION && s.fromBufferAttribute(o.ROTATION, t), o.SCALE && a.fromBufferAttribute(o.SCALE, t), l.setMatrixAt(t, e.compose(n, s, a));
                        for (const e in o) "TRANSLATION" !== e && "ROTATION" !== e && "SCALE" !== e && t.geometry.setAttribute(e, o[e]);
                        _b.prototype.copy.call(l, t), l.frustumCulled = !1, this.parser.assignFinalMaterial(l), r.push(l)
                    }
                    return e.isGroup ? (e.clear(), e.add(...r), e) : r[0]
                })))
            }
        }
        const fT = "glTF";
        class pT {
            constructor(t) {
                this.name = ZS.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const e = new DataView(t, 0, 12);
                if (this.header = {
                    magic: jS.decodeText(new Uint8Array(t.slice(0, 4))),
                    version: e.getUint32(4, !0),
                    length: e.getUint32(8, !0)
                }, this.header.magic !== fT) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const n = this.header.length - 12,
                    i = new DataView(t, 12);
                let r = 0;
                for (; r < n;) {
                    const e = i.getUint32(r, !0);
                    r += 4;
                    const n = i.getUint32(r, !0);
                    if (r += 4, 1313821514 === n) {
                        const n = new Uint8Array(t, 12 + r, e);
                        this.content = jS.decodeText(n)
                    } else if (5130562 === n) {
                        const n = 12 + r;
                        this.body = t.slice(n, n + e)
                    }
                    r += e
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class mT {
            constructor(t, e) {
                if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = ZS.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
            }
            decodePrimitive(t, e) {
                const n = this.json,
                    i = this.dracoLoader,
                    r = t.extensions[this.name].bufferView,
                    s = t.extensions[this.name].attributes,
                    o = {},
                    a = {},
                    l = {};
                for (const t in s) {
                    const e = CT[t] || t.toLowerCase();
                    o[e] = s[t]
                }
                for (const e in t.attributes) {
                    const i = CT[e] || e.toLowerCase();
                    if (void 0 !== s[e]) {
                        const r = n.accessors[t.attributes[e]],
                            s = ST[r.componentType];
                        l[i] = s.name, a[i] = !0 === r.normalized
                    }
                }
                return e.getDependency("bufferView", r).then((function (t) {
                    return new Promise((function (e) {
                        i.decodeDracoFile(t, (function (t) {
                            for (const e in t.attributes) {
                                const n = t.attributes[e],
                                    i = a[e];
                                void 0 !== i && (n.normalized = i)
                            }
                            e(t)
                        }), o, l)
                    }))
                }))
            }
        }
        class gT {
            constructor() {
                this.name = ZS.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(t, e) {
                return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t
            }
        }
        class vT extends KM {
            constructor(t) {
                super(), this.isGLTFSpecularGlossinessMaterial = !0;
                const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                    n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                    i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                    r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                    s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                    o = {
                        specular: {
                            value: (new ay).setHex(16777215)
                        },
                        glossiness: {
                            value: 1
                        },
                        specularMap: {
                            value: null
                        },
                        glossinessMap: {
                            value: null
                        }
                    };
                this._extraUniforms = o, this.onBeforeCompile = function (t) {
                    for (const e in o) t.uniforms[e] = o[e];
                    t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
                }, Object.defineProperties(this, {
                    specular: {
                        get: function () {
                            return o.specular.value
                        },
                        set: function (t) {
                            o.specular.value = t
                        }
                    },
                    specularMap: {
                        get: function () {
                            return o.specularMap.value
                        },
                        set: function (t) {
                            o.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                        }
                    },
                    glossiness: {
                        get: function () {
                            return o.glossiness.value
                        },
                        set: function (t) {
                            o.glossiness.value = t
                        }
                    },
                    glossinessMap: {
                        get: function () {
                            return o.glossinessMap.value
                        },
                        set: function (t) {
                            o.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                        }
                    }
                }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
            }
            copy(t) {
                return super.copy(t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
            }
        }
        class yT {
            constructor() {
                this.name = ZS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
            }
            getMaterialType() {
                return vT
            }
            extendParams(t, e, n) {
                const i = e.extensions[this.name];
                t.color = new ay(1, 1, 1), t.opacity = 1;
                const r = [];
                if (Array.isArray(i.diffuseFactor)) {
                    const e = i.diffuseFactor;
                    t.color.fromArray(e), t.opacity = e[3]
                }
                if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, "map", i.diffuseTexture, wv)), t.emissive = new ay(0, 0, 0), t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, t.specular = new ay(1, 1, 1), Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                    const e = i.specularGlossinessTexture;
                    r.push(n.assignTexture(t, "glossinessMap", e)), r.push(n.assignTexture(t, "specularMap", e, wv))
                }
                return Promise.all(r)
            }
            createMaterial(t) {
                const e = new vT(t);
                return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = void 0 === t.emissiveIntensity ? 1 : t.emissiveIntensity, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = Sv, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e
            }
        }
        class bT {
            constructor() {
                this.name = ZS.KHR_MESH_QUANTIZATION
            }
        }
        class _T extends rS {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = t * i * 3 + i;
                for (let t = 0; t !== i; t++) e[t] = n[r + t];
                return e
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    o = this.valueSize,
                    a = 2 * o,
                    l = 3 * o,
                    u = i - e,
                    c = (n - e) / u,
                    h = c * c,
                    d = h * c,
                    f = t * l,
                    p = f - l,
                    m = -2 * d + 3 * h,
                    g = d - h,
                    v = 1 - m,
                    y = g - h + c;
                for (let t = 0; t !== o; t++) {
                    const e = s[p + t + o],
                        n = s[p + t + a] * u,
                        i = s[f + t + o],
                        l = s[f + t] * u;
                    r[t] = v * e + y * n + m * i + g * l
                }
                return r
            }
        }
        const xT = new yy;
        class wT extends _T {
            interpolate_(t, e, n, i) {
                const r = super.interpolate_(t, e, n, i);
                return xT.fromArray(r).normalize().toArray(r), r
            }
        }
        const MT = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        },
            ST = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            TT = {
                9728: vg,
                9729: _g,
                9984: yg,
                9985: xg,
                9986: bg,
                9987: wg
            },
            ET = {
                33071: mg,
                33648: gg,
                10497: pg
            },
            DT = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            CT = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv2",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            AT = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            PT = {
                CUBICSPLINE: void 0,
                LINEAR: bv,
                STEP: yv
            };

        function LT(t, e, n) {
            for (const i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i])
        }

        function RT(t, e) {
            void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
        }

        function kT(t, e) {
            if (t.updateMorphTargets(), void 0 !== e.weights)
                for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
            if (e.extras && Array.isArray(e.extras.targetNames)) {
                const n = e.extras.targetNames;
                if (t.morphTargetInfluences.length === n.length) {
                    t.morphTargetDictionary = {};
                    for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function OT(t) {
            const e = t.extensions && t.extensions[ZS.KHR_DRACO_MESH_COMPRESSION];
            let n;
            return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + IT(e.attributes) : t.indices + ":" + IT(t.attributes) + ":" + t.mode, n
        }

        function IT(t) {
            let e = "";
            const n = Object.keys(t).sort();
            for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
            return e
        }

        function FT(t) {
            switch (t) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        class NT {
            constructor(t = {}, e = {}) {
                this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new JS, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                const n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                    i = navigator.userAgent.indexOf("Firefox") > -1,
                    r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
                "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new ES(this.options.manager) : this.textureLoader = new HS(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new SS(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(t) {
                this.extensions = t
            }
            setPlugins(t) {
                this.plugins = t
            }
            parse(t, e) {
                const n = this,
                    i = this.json,
                    r = this.extensions;
                this.cache.removeAll(), this._invokeAll((function (t) {
                    return t._markDefs && t._markDefs()
                })), Promise.all(this._invokeAll((function (t) {
                    return t.beforeRoot && t.beforeRoot()
                }))).then((function () {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                })).then((function (e) {
                    const s = {
                        scene: e[0][i.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    LT(r, s, i), RT(s, i), Promise.all(n._invokeAll((function (t) {
                        return t.afterRoot && t.afterRoot(s)
                    }))).then((function () {
                        t(s)
                    }))
                })).catch(e)
            }
            _markDefs() {
                const t = this.json.nodes || [],
                    e = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n].joints;
                    for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0
                }
                for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(t, e) {
                void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
            }
            _getNodeRef(t, e, n) {
                if (t.refs[e] <= 1) return n;
                const i = n.clone(),
                    r = (t, e) => {
                        const n = this.associations.get(t);
                        null != n && this.associations.set(e, n);
                        for (const [n, i] of t.children.entries()) r(i, e.children[n])
                    };
                return r(n, i), i.name += "_instance_" + t.uses[e]++, i
            }
            _invokeOne(t) {
                const e = Object.values(this.plugins);
                e.push(this);
                for (let n = 0; n < e.length; n++) {
                    const i = t(e[n]);
                    if (i) return i
                }
                return null
            }
            _invokeAll(t) {
                const e = Object.values(this.plugins);
                e.unshift(this);
                const n = [];
                for (let i = 0; i < e.length; i++) {
                    const r = t(e[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(t, e) {
                const n = t + ":" + e;
                let i = this.cache.get(n);
                if (!i) {
                    switch (t) {
                        case "scene":
                            i = this.loadScene(e);
                            break;
                        case "node":
                            i = this.loadNode(e);
                            break;
                        case "mesh":
                            i = this._invokeOne((function (t) {
                                return t.loadMesh && t.loadMesh(e)
                            }));
                            break;
                        case "accessor":
                            i = this.loadAccessor(e);
                            break;
                        case "bufferView":
                            i = this._invokeOne((function (t) {
                                return t.loadBufferView && t.loadBufferView(e)
                            }));
                            break;
                        case "buffer":
                            i = this.loadBuffer(e);
                            break;
                        case "material":
                            i = this._invokeOne((function (t) {
                                return t.loadMaterial && t.loadMaterial(e)
                            }));
                            break;
                        case "texture":
                            i = this._invokeOne((function (t) {
                                return t.loadTexture && t.loadTexture(e)
                            }));
                            break;
                        case "skin":
                            i = this.loadSkin(e);
                            break;
                        case "animation":
                            i = this._invokeOne((function (t) {
                                return t.loadAnimation && t.loadAnimation(e)
                            }));
                            break;
                        case "camera":
                            i = this.loadCamera(e);
                            break;
                        default:
                            throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(t) {
                let e = this.cache.get(t);
                if (!e) {
                    const n = this,
                        i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                    e = Promise.all(i.map((function (e, i) {
                        return n.getDependency(t, i)
                    }))), this.cache.add(t, e)
                }
                return e
            }
            loadBuffer(t) {
                const e = this.json.buffers[t],
                    n = this.fileLoader;
                if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[ZS.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function (t, r) {
                    n.load(jS.resolveURL(e.uri, i.path), t, void 0, (function () {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                    }))
                }))
            }
            loadBufferView(t) {
                const e = this.json.bufferViews[t];
                return this.getDependency("buffer", e.buffer).then((function (t) {
                    const n = e.byteLength || 0,
                        i = e.byteOffset || 0;
                    return t.slice(i, i + n)
                }))
            }
            loadAccessor(t) {
                const e = this,
                    n = this.json,
                    i = this.json.accessors[t];
                if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (t) {
                    const r = t[0],
                        s = DT[i.type],
                        o = ST[i.componentType],
                        a = o.BYTES_PER_ELEMENT,
                        l = a * s,
                        u = i.byteOffset || 0,
                        c = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                        h = !0 === i.normalized;
                    let d, f;
                    if (c && c !== l) {
                        const t = Math.floor(u / c),
                            n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                        let l = e.cache.get(n);
                        l || (d = new o(r, t * c, i.count * c / a), l = new hM(d, c / a), e.cache.add(n, l)), f = new fM(l, s, u % c / a, h)
                    } else d = null === r ? new o(i.count * s) : new o(r, u, i.count * s), f = new Nb(d, s, h);
                    if (void 0 !== i.sparse) {
                        const e = DT.SCALAR,
                            n = ST[i.sparse.indices.componentType],
                            a = i.sparse.indices.byteOffset || 0,
                            l = i.sparse.values.byteOffset || 0,
                            u = new n(t[1], a, i.sparse.count * e),
                            c = new o(t[2], l, i.sparse.count * s);
                        null !== r && (f = new Nb(f.array.slice(), f.itemSize, f.normalized));
                        for (let t = 0, e = u.length; t < e; t++) {
                            const e = u[t];
                            if (f.setX(e, c[t * s]), s >= 2 && f.setY(e, c[t * s + 1]), s >= 3 && f.setZ(e, c[t * s + 2]), s >= 4 && f.setW(e, c[t * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return f
                }))
            }
            loadTexture(t) {
                const e = this.json,
                    n = this.options,
                    i = e.textures[t].source,
                    r = e.images[i];
                let s = this.textureLoader;
                if (r.uri) {
                    const t = n.manager.getHandler(r.uri);
                    null !== t && (s = t)
                }
                return this.loadTextureImage(t, i, s)
            }
            loadTextureImage(t, e, n) {
                const i = this,
                    r = this.json,
                    s = r.textures[t],
                    o = r.images[e],
                    a = (o.uri || o.bufferView) + ":" + s.sampler;
                if (this.textureCache[a]) return this.textureCache[a];
                const l = this.loadImageSource(e, n).then((function (e) {
                    e.flipY = !1, e.name = s.name || o.name || "";
                    const n = (r.samplers || {})[s.sampler] || {};
                    return e.magFilter = TT[n.magFilter] || _g, e.minFilter = TT[n.minFilter] || wg, e.wrapS = ET[n.wrapS] || pg, e.wrapT = ET[n.wrapT] || pg, i.associations.set(e, {
                        textures: t
                    }), e
                })).catch((function () {
                    return null
                }));
                return this.textureCache[a] = l, l
            }
            loadImageSource(t, e) {
                const n = this.json,
                    i = this.options;
                if (void 0 !== this.sourceCache[t]) return this.sourceCache[t].then((t => t.clone()));
                const r = n.images[t],
                    s = self.URL || self.webkitURL;
                let o = r.uri || "",
                    a = !1;
                if (void 0 !== r.bufferView) o = this.getDependency("bufferView", r.bufferView).then((function (t) {
                    a = !0;
                    const e = new Blob([t], {
                        type: r.mimeType
                    });
                    return o = s.createObjectURL(e), o
                }));
                else if (void 0 === r.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                const l = Promise.resolve(o).then((function (t) {
                    return new Promise((function (n, r) {
                        let s = n;
                        !0 === e.isImageBitmapLoader && (s = function (t) {
                            const e = new fy(t);
                            e.needsUpdate = !0, n(e)
                        }), e.load(jS.resolveURL(t, i.path), s, void 0, r)
                    }))
                })).then((function (t) {
                    var e;
                    return !0 === a && s.revokeObjectURL(o), t.userData.mimeType = r.mimeType || ((e = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), t
                })).catch((function (t) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", o), t
                }));
                return this.sourceCache[t] = l, l
            }
            assignTexture(t, e, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function (s) {
                    if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), r.extensions[ZS.KHR_TEXTURE_TRANSFORM]) {
                        const t = void 0 !== n.extensions ? n.extensions[ZS.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (t) {
                            const e = r.associations.get(s);
                            s = r.extensions[ZS.KHR_TEXTURE_TRANSFORM].extendTexture(s, t), r.associations.set(s, e)
                        }
                    }
                    return void 0 !== i && (s.encoding = i), t[e] = s, s
                }))
            }
            assignFinalMaterial(t) {
                const e = t.geometry;
                let n = t.material;
                const i = void 0 === e.attributes.tangent,
                    r = void 0 !== e.attributes.color,
                    s = void 0 === e.attributes.normal;
                if (t.isPoints) {
                    const t = "PointsMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new VM, kb.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
                } else if (t.isLine) {
                    const t = "LineBasicMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new RM, kb.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e
                }
                if (i || r || s) {
                    let t = "ClonedMaterial:" + n.uuid + ":";
                    n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), i && (t += "derivative-tangents:"), r && (t += "vertex-colors:"), s && (t += "flat-shading:");
                    let e = this.cache.get(t);
                    e || (e = n.clone(), r && (e.vertexColors = !0), s && (e.flatShading = !0), i && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
                }
                n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n
            }
            getMaterialType() {
                return KM
            }
            loadMaterial(t) {
                const e = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.materials[t];
                let s;
                const o = {},
                    a = r.extensions || {},
                    l = [];
                if (a[ZS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                    const t = i[ZS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    s = t.getMaterialType(), l.push(t.extendParams(o, r, e))
                } else if (a[ZS.KHR_MATERIALS_UNLIT]) {
                    const t = i[ZS.KHR_MATERIALS_UNLIT];
                    s = t.getMaterialType(), l.push(t.extendParams(o, r, e))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (o.color = new ay(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const t = n.baseColorFactor;
                        o.color.fromArray(t), o.opacity = t[3]
                    }
                    void 0 !== n.baseColorTexture && l.push(e.assignTexture(o, "map", n.baseColorTexture, wv)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), l.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (e) {
                        return e.getMaterialType && e.getMaterialType(t)
                    })), l.push(Promise.all(this._invokeAll((function (e) {
                        return e.extendMaterialParams && e.extendMaterialParams(t, o)
                    }))))
                } !0 === r.doubleSided && (o.side = Mm);
                const u = r.alphaMode || "OPAQUE";
                if ("BLEND" === u ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, "MASK" === u && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Ob && (l.push(e.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new Xv(1, 1), void 0 !== r.normalTexture.scale)) {
                    const t = r.normalTexture.scale;
                    o.normalScale.set(t, t)
                }
                return void 0 !== r.occlusionTexture && s !== Ob && (l.push(e.assignTexture(o, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Ob && (o.emissive = (new ay).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== Ob && l.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture, wv)), Promise.all(l).then((function () {
                    let n;
                    return n = s === vT ? i[ZS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new s(o), r.name && (n.name = r.name), RT(n, r), e.associations.set(n, {
                        materials: t
                    }), r.extensions && LT(i, n, r), n
                }))
            }
            createUniqueName(t) {
                const e = YS.sanitizeNodeName(t || "");
                let n = e;
                for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + "_" + t;
                return this.nodeNamesUsed[n] = !0, n
            }
            loadGeometries(t) {
                const e = this,
                    n = this.extensions,
                    i = this.primitiveCache;

                function r(t) {
                    return n[ZS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function (n) {
                        return UT(n, t, e)
                    }))
                }
                const s = [];
                for (let n = 0, o = t.length; n < o; n++) {
                    const o = t[n],
                        a = OT(o),
                        l = i[a];
                    if (l) s.push(l.promise);
                    else {
                        let t;
                        t = o.extensions && o.extensions[ZS.KHR_DRACO_MESH_COMPRESSION] ? r(o) : UT(new qb, o, e), i[a] = {
                            primitive: o,
                            promise: t
                        }, s.push(t)
                    }
                }
                return Promise.all(s)
            }
            loadMesh(t) {
                const e = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.meshes[t],
                    s = r.primitives,
                    o = [];
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = void 0 === s[t].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new KM({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: xm
                    })), a.DefaultMaterial) : this.getDependency("material", s[t].material);
                    o.push(e)
                }
                var a;
                return o.push(e.loadGeometries(s)), Promise.all(o).then((function (n) {
                    const o = n.slice(0, n.length - 1),
                        a = n[n.length - 1],
                        l = [];
                    for (let n = 0, u = a.length; n < u; n++) {
                        const u = a[n],
                            c = s[n];
                        let h;
                        const d = o[n];
                        if (c.mode === MT.TRIANGLES || c.mode === MT.TRIANGLE_STRIP || c.mode === MT.TRIANGLE_FAN || void 0 === c.mode) h = !0 === r.isSkinnedMesh ? new bM(u, d) : new d_(u, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), c.mode === MT.TRIANGLE_STRIP ? h.geometry = BT(h.geometry, 1) : c.mode === MT.TRIANGLE_FAN && (h.geometry = BT(h.geometry, 2));
                        else if (c.mode === MT.LINES) h = new jM(u, d);
                        else if (c.mode === MT.LINE_STRIP) h = new zM(u, d);
                        else if (c.mode === MT.LINE_LOOP) h = new HM(u, d);
                        else {
                            if (c.mode !== MT.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
                            h = new qM(u, d)
                        }
                        Object.keys(h.geometry.morphAttributes).length > 0 && kT(h, r), h.name = e.createUniqueName(r.name || "mesh_" + t), RT(h, r), c.extensions && LT(i, h, c), e.assignFinalMaterial(h), l.push(h)
                    }
                    for (let n = 0, i = l.length; n < i; n++) e.associations.set(l[n], {
                        meshes: t,
                        primitives: n
                    });
                    if (1 === l.length) return l[0];
                    const u = new nM;
                    e.associations.set(u, {
                        meshes: t
                    });
                    for (let t = 0, e = l.length; t < e; t++) u.add(l[t]);
                    return u
                }))
            }
            loadCamera(t) {
                let e;
                const n = this.json.cameras[t],
                    i = n[n.type];
                if (i) return "perspective" === n.type ? e = new __($v.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new G_(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), RT(e, n), Promise.resolve(e);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(t) {
                const e = this.json.skins[t],
                    n = {
                        joints: e.joints
                    };
                return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function (t) {
                    return n.inverseBindMatrices = t, n
                }))
            }
            loadAnimation(t) {
                const e = this.json.animations[t],
                    n = [],
                    i = [],
                    r = [],
                    s = [],
                    o = [];
                for (let t = 0, a = e.channels.length; t < a; t++) {
                    const a = e.channels[t],
                        l = e.samplers[a.sampler],
                        u = a.target,
                        c = u.node,
                        h = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
                        d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                    n.push(this.getDependency("node", c)), i.push(this.getDependency("accessor", h)), r.push(this.getDependency("accessor", d)), s.push(l), o.push(u)
                }
                return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o)]).then((function (n) {
                    const i = n[0],
                        r = n[1],
                        s = n[2],
                        o = n[3],
                        a = n[4],
                        l = [];
                    for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t],
                            n = r[t],
                            u = s[t],
                            c = o[t],
                            h = a[t];
                        if (void 0 === e) continue;
                        let d;
                        switch (e.updateMatrix(), AT[h.path]) {
                            case AT.weights:
                                d = hS;
                                break;
                            case AT.rotation:
                                d = fS;
                                break;
                            default:
                                d = mS
                        }
                        const f = e.name ? e.name : e.uuid,
                            p = void 0 !== c.interpolation ? PT[c.interpolation] : bv,
                            m = [];
                        AT[h.path] === AT.weights ? e.traverse((function (t) {
                            t.morphTargetInfluences && m.push(t.name ? t.name : t.uuid)
                        })) : m.push(f);
                        let g = u.array;
                        if (u.normalized) {
                            const t = FT(g.constructor),
                                e = new Float32Array(g.length);
                            for (let n = 0, i = g.length; n < i; n++) e[n] = g[n] * t;
                            g = e
                        }
                        for (let t = 0, e = m.length; t < e; t++) {
                            const e = new d(m[t] + "." + AT[h.path], n.array, g, p);
                            "CUBICSPLINE" === c.interpolation && (e.createInterpolant = function (t) {
                                return new (this instanceof fS ? wT : _T)(this.times, this.values, this.getValueSize() / 3, t)
                            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(e)
                        }
                    }
                    const u = e.name ? e.name : "animation_" + t;
                    return new gS(u, void 0, l)
                }))
            }
            createNodeMesh(t) {
                const e = this.json,
                    n = this,
                    i = e.nodes[t];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (t) {
                    const e = n._getNodeRef(n.meshCache, i.mesh, t);
                    return void 0 !== i.weights && e.traverse((function (t) {
                        if (t.isMesh)
                            for (let e = 0, n = i.weights.length; e < n; e++) t.morphTargetInfluences[e] = i.weights[e]
                    })), e
                }))
            }
            loadNode(t) {
                const e = this.json,
                    n = this.extensions,
                    i = this,
                    r = e.nodes[t],
                    s = r.name ? i.createUniqueName(r.name) : "";
                return function () {
                    const e = [],
                        n = i._invokeOne((function (e) {
                            return e.createNodeMesh && e.createNodeMesh(t)
                        }));
                    return n && e.push(n), void 0 !== r.camera && e.push(i.getDependency("camera", r.camera).then((function (t) {
                        return i._getNodeRef(i.cameraCache, r.camera, t)
                    }))), i._invokeAll((function (e) {
                        return e.createNodeAttachment && e.createNodeAttachment(t)
                    })).forEach((function (t) {
                        e.push(t)
                    })), Promise.all(e)
                }().then((function (e) {
                    let o;
                    if (o = !0 === r.isBone ? new _M : e.length > 1 ? new nM : 1 === e.length ? e[0] : new _b, o !== e[0])
                        for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
                    if (r.name && (o.userData.name = r.name, o.name = s), RT(o, r), r.extensions && LT(n, o, r), void 0 !== r.matrix) {
                        const t = new Yy;
                        t.fromArray(r.matrix), o.applyMatrix4(t)
                    } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale);
                    return i.associations.has(o) || i.associations.set(o, {}), i.associations.get(o).nodes = t, o
                }))
            }
            loadScene(t) {
                const e = this.json,
                    n = this.extensions,
                    i = this.json.scenes[t],
                    r = this,
                    s = new nM;
                i.name && (s.name = r.createUniqueName(i.name)), RT(s, i), i.extensions && LT(n, s, i);
                const o = i.nodes || [],
                    a = [];
                for (let t = 0, n = o.length; t < n; t++) a.push(zT(o[t], s, e, r));
                return Promise.all(a).then((function () {
                    return r.associations = (t => {
                        const e = new Map;
                        for (const [t, n] of r.associations) (t instanceof kb || t instanceof fy) && e.set(t, n);
                        return t.traverse((t => {
                            const n = r.associations.get(t);
                            null != n && e.set(t, n)
                        })), e
                    })(s), s
                }))
            }
        }

        function zT(t, e, n, i) {
            const r = n.nodes[t];
            return i.getDependency("node", t).then((function (t) {
                if (void 0 === r.skin) return t;
                let e;
                return i.getDependency("skin", r.skin).then((function (t) {
                    e = t;
                    const n = [];
                    for (let t = 0, r = e.joints.length; t < r; t++) n.push(i.getDependency("node", e.joints[t]));
                    return Promise.all(n)
                })).then((function (n) {
                    return t.traverse((function (t) {
                        if (!t.isMesh) return;
                        const i = [],
                            r = [];
                        for (let t = 0, s = n.length; t < s; t++) {
                            const s = n[t];
                            if (s) {
                                i.push(s);
                                const n = new Yy;
                                void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t), r.push(n)
                            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                        }
                        t.bind(new SM(i, r), t.matrixWorld)
                    })), t
                }))
            })).then((function (t) {
                e.add(t);
                const s = [];
                if (r.children) {
                    const e = r.children;
                    for (let r = 0, o = e.length; r < o; r++) {
                        const o = e[r];
                        s.push(zT(o, t, n, i))
                    }
                }
                return Promise.all(s)
            }))
        }

        function UT(t, e, n) {
            const i = e.attributes,
                r = [];

            function s(e, i) {
                return n.getDependency("accessor", e).then((function (e) {
                    t.setAttribute(i, e)
                }))
            }
            for (const e in i) {
                const n = CT[e] || e.toLowerCase();
                n in t.attributes || r.push(s(i[e], n))
            }
            if (void 0 !== e.indices && !t.index) {
                const i = n.getDependency("accessor", e.indices).then((function (e) {
                    t.setIndex(e)
                }));
                r.push(i)
            }
            return RT(t, e),
                function (t, e, n) {
                    const i = e.attributes,
                        r = new wy;
                    if (void 0 === i.POSITION) return;
                    {
                        const t = n.json.accessors[i.POSITION],
                            e = t.min,
                            s = t.max;
                        if (void 0 === e || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (r.set(new by(e[0], e[1], e[2]), new by(s[0], s[1], s[2])), t.normalized) {
                            const e = FT(ST[t.componentType]);
                            r.min.multiplyScalar(e), r.max.multiplyScalar(e)
                        }
                    }
                    const s = e.targets;
                    if (void 0 !== s) {
                        const t = new by,
                            e = new by;
                        for (let i = 0, r = s.length; i < r; i++) {
                            const r = s[i];
                            if (void 0 !== r.POSITION) {
                                const i = n.json.accessors[r.POSITION],
                                    s = i.min,
                                    o = i.max;
                                if (void 0 !== s && void 0 !== o) {
                                    if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), i.normalized) {
                                        const t = FT(ST[i.componentType]);
                                        e.multiplyScalar(t)
                                    }
                                    t.max(e)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        r.expandByVector(t)
                    }
                    t.boundingBox = r;
                    const o = new By;
                    r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, t.boundingSphere = o
                }(t, e, n), Promise.all(r).then((function () {
                    return void 0 !== e.targets ? function (t, e, n) {
                        let i = !1,
                            r = !1,
                            s = !1;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (s = !0), i && r && s) break
                        }
                        if (!i && !r && !s) return Promise.resolve(t);
                        const o = [],
                            a = [],
                            l = [];
                        for (let u = 0, c = e.length; u < c; u++) {
                            const c = e[u];
                            if (i) {
                                const e = void 0 !== c.POSITION ? n.getDependency("accessor", c.POSITION) : t.attributes.position;
                                o.push(e)
                            }
                            if (r) {
                                const e = void 0 !== c.NORMAL ? n.getDependency("accessor", c.NORMAL) : t.attributes.normal;
                                a.push(e)
                            }
                            if (s) {
                                const e = void 0 !== c.COLOR_0 ? n.getDependency("accessor", c.COLOR_0) : t.attributes.color;
                                l.push(e)
                            }
                        }
                        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then((function (e) {
                            const n = e[0],
                                o = e[1],
                                a = e[2];
                            return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = o), s && (t.morphAttributes.color = a), t.morphTargetsRelative = !0, t
                        }))
                    }(t, e.targets, n) : t
                }))
        }

        function BT(t, e) {
            let n = t.getIndex();
            if (null === n) {
                const e = [],
                    i = t.getAttribute("position");
                if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                for (let t = 0; t < i.count; t++) e.push(t);
                t.setIndex(e), n = t.getIndex()
            }
            const i = n.count - 2,
                r = [];
            if (2 === e)
                for (let t = 1; t <= i; t++) r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1));
            else
                for (let t = 0; t < i; t++) t % 2 == 0 ? (r.push(n.getX(t)), r.push(n.getX(t + 1)), r.push(n.getX(t + 2))) : (r.push(n.getX(t + 2)), r.push(n.getX(t + 1)), r.push(n.getX(t)));
            r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const s = t.clone();
            return s.setIndex(r), s
        }

        function jT(t) {
            return jT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, jT(t)
        }

        function HT(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, VT(i.key), i)
            }
        }

        function VT(t) {
            var e = function (t, e) {
                if ("object" != jT(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != jT(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == jT(e) ? e : e + ""
        }
        var GT = yc.bounds,
            WT = (yc.flags, function () {
                return function (t, e, n) {
                    return e && HT(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                        function (t, e, n) {
                            (e = VT(e)) in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n
                        }(this, "tick", (function () {
                            n.gl.render(n.scene, n.camera)
                        })), this.el = e, this.scene = new cM, this.camera = new __(75, GT.ww / GT.wh, .1, 1e3), this.camera.position.z = 50, this.gl = new uM({
                            alpha: !0
                        }), this.gl.setSize(GT.ww, GT.wh), this.gl.setPixelRatio(Math.min(2, window.devicePixelRatio)), this.gl.outputEncoding = wv, this.camera.position.z = 50;
                    var i = new BS(16777215, 1);
                    this.scene.add(i), i.position.z = 50, i.position.x = 2, this.pmremGenerator = new Z_(this.gl), this.pmremGenerator.compileEquirectangularShader(), (new ES).load(this.el.dataset.env, (function (t) {
                        n.envMap = n.pmremGenerator.fromEquirectangular(t).texture
                    })), this.gl.domElement.classList.add("absolute", "top-0", "left-0", "w-full", "h-full"), this.el.appendChild(this.gl.domElement), (new KS).load(this.el.dataset.model, (function (t) {
                        n.model = t.scene, n.model.rotation.x = Math.PI / 2, n.model.rotation.y = Math.PI, n.scene.add(n.model), n.model.traverse((function (t) {
                            t.isMesh && (t.material.envMap = n.envMap, t.material.envMapIntensity = 1, t.material.map && (t.material.map.minFilter = _g))
                        })), n.model.position.z = 30, n.tl = Ki.timeline({
                            scrollTrigger: {
                                trigger: n.el.parentNode,
                                start: "top bottom",
                                end: "bottom bottom",
                                scrub: !0
                            },
                            defaults: {
                                ease: "power1.inOut",
                                duration: .5
                            }
                        }).fromTo(n.model.position, {
                            z: 20
                        }, {
                            z: 30
                        }, 0).to(n.model.rotation, {
                            z: 2 * Math.PI
                        }, 0)
                    }), void 0, (function (t) {
                        console.error(t)
                    })), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("tick", this.tick)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("tick", this.tick)
                    }
                }, {
                    key: "umount",
                    value: function () {
                        this.unbindEvents(), this.gl.dispose(), this.tl && this.tl.kill()
                    }
                }])
            }()),
            $T = n(966),
            XT = n.n($T);

        function qT(t) {
            return qT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, qT(t)
        }

        function YT(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, JT(i.key), i)
            }
        }

        function KT(t, e, n) {
            return (e = JT(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function JT(t) {
            var e = function (t, e) {
                if ("object" != qT(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != qT(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == qT(e) ? e : e + ""
        }
        var ZT = hc,
            QT = cc,
            tE = fc,
            eE = yc.bounds,
            nE = yc.device,
            iE = function () {
                return function (t, e, n) {
                    return e && YT(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), KT(this, "redirect", (function (t) {
                        var e = t.currentTarget;
                        BC.redirect(e.dataset.href)
                    })), KT(this, "tick", (function () {
                        n.mouse.cx[0] += .09 * (n.mouse.x - n.mouse.cx[0]), n.mouse.cy[0] += .09 * (n.mouse.y - n.mouse.cy[0]), n.mouse.cx[1] += .085 * (n.mouse.x - n.mouse.cx[1]), n.mouse.cy[1] += .085 * (n.mouse.y - n.mouse.cy[1]), n.mouse.cx[2] += .08 * (n.mouse.x - n.mouse.cx[2]), n.mouse.cy[2] += .08 * (n.mouse.y - n.mouse.cy[2]), n.cache.forEach((function (t) {
                            var e = t.item,
                                i = t.idx;
                            e.style.transform = "translate3d(".concat(-n.mouse.cx[i], "px, ").concat(-n.mouse.cy[i], "px, 0)")
                        }))
                    })), KT(this, "move", (function (t) {
                        var e = t.x,
                            i = t.y;
                        n.mouse.yMap && (n.mouse.x = n.mouse.xMap(e), n.mouse.y = n.mouse.yMap(i))
                    })), nE.isMobile || (this.el = e, this.items = [], ZT(".js-item", this.el).forEach((function (t) {
                        var e = t.dataset.link,
                            i = QT("[data-srcs]", t);
                        (i = i ? JSON.parse(i.dataset.srcs) : null) && i.length && i.forEach((function (t) {
                            n.items.push({
                                image: t,
                                link: e
                            })
                        })), n.items.push({
                            image: t.dataset.image,
                            link: e
                        })
                    })), this.max = {
                        x: 0,
                        y: 0
                    }, this.mouse = {
                        x: 0,
                        y: 0,
                        cx: [0, 0, 0],
                        cy: [0, 0, 0],
                        xMap: null,
                        yMap: null
                    }, this.resize(), this.bindEvents())
                }), [{
                    key: "resize",
                    value: function () {
                        var t = this,
                            e = eE.ww <= eE.wh ? .1 * eE.wh : .1 * eE.ww;
                        this.grid = new (XT())({
                            shape: [1.5 * eE.ww, 1.5 * eE.wh],
                            minDistance: 1.5 * e,
                            maxDistance: 2 * e,
                            tries: 10
                        }), this.points = this.grid.fill(), this.cache = this.points.map((function (e, n) {
                            t.max.x = e[0] > t.max.x ? e[0] : t.max.x, t.max.y = e[1] > t.max.y ? e[1] : t.max.y;
                            var i = Ki.utils.wrap(0, 3, n),
                                r = t.add(e, n);
                            return lc.on("click", r, t.redirect), {
                                item: r,
                                idx: i
                            }
                        }));
                        var n = .5 * eE.wh;
                        this.mouse.xMap = Ki.utils.mapRange(0, eE.ww, -n, this.max.x - eE.ww + n), this.mouse.yMap = Ki.utils.mapRange(0, eE.wh, -n, this.max.y - eE.wh + n)
                    }
                }, {
                    key: "bindEvents",
                    value: function () {
                        lc.on("mousemove", this.move), lc.on("tick", this.tick)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("mousemove", this.move), lc.off("tick", this.tick)
                    }
                }, {
                    key: "add",
                    value: function (t, e) {
                        var n = tE(.1 * eE.ww, .2 * eE.ww),
                            i = n * tE(.75, 1.25),
                            r = this.items[Ki.utils.wrap(0, this.items.length, e)],
                            s = document.createElement("div");
                        s.dataset.href = r.link, s.classList.add("explore-tile", "absolute", "cursor-pointer", "image-fill"), s.style.width = "".concat(n, "px"), s.style.left = "".concat(t[0] - .5 * n, "px"), s.style.top = "".concat(t[1] - .5 * i, "px"), s.dataset.tile = !0, this.el.appendChild(s);
                        var o = new Image;
                        return o.srcset = r.image.srcset || r.image, o.sizes = "(min-width: 768px) 20vw, 100vw", o.decode().then((function () {
                            s.appendChild(o), s.style.aspectRatio = "".concat(o.naturalWidth / o.naturalHeight), Ki.from(o, {
                                alpha: 0,
                                duration: .5,
                                delay: tE(0, .5, !0),
                                ease: "power1"
                            })
                        })), s
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        nE.isMobile || (this.unbindEvents(), this.grid = null)
                    }
                }])
            }();

        function rE(t) {
            return rE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, rE(t)
        }

        function sE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, aE(i.key), i)
            }
        }

        function oE(t, e, n) {
            return (e = aE(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function aE(t) {
            var e = function (t, e) {
                if ("object" != rE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != rE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == rE(e) ? e : e + ""
        }
        var lE = hc,
            uE = dc,
            cE = yc.bounds,
            hE = yc.flags,
            dE = function () {
                return function (t, e, n) {
                    return e && sE(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), oE(this, "scroll", (function (t) {
                        var e = t.dY;
                        n.target -= e
                    })), oE(this, "tick", (function () {
                        n.current = kc()(n.current, n.target, .1), n.transformSections()
                    })), oE(this, "enter", (function (t) {
                        var e = t.currentTarget,
                            i = n.cache.find((function (t) {
                                return t.el === e
                            }));
                        i.tl.clear().set(i.content, {
                            autoAlpha: 1
                        }).fromTo(i.items, {
                            alpha: 0,
                            y: "5rem"
                        }, {
                            alpha: 1,
                            y: 0,
                            stagger: .1
                        }).restart()
                    })), oE(this, "leave", (function (t) {
                        var e = t.currentTarget,
                            i = n.cache.find((function (t) {
                                return t.el === e
                            }));
                        i.tl.clear().to(i.items, {
                            alpha: 0,
                            y: "-2.5rem",
                            duration: .5,
                            stagger: .05
                        }).set(i.content, {
                            autoAlpha: 0
                        }).restart()
                    })), oE(this, "resize", (function () {
                        n.cache = n.$items.map((function (t, e) {
                            t.style.transform = "translate3d(0, 0, 0)";
                            var i = n.$content[e],
                                r = Ki.timeline({
                                    paused: !0,
                                    defaults: {
                                        duration: 1,
                                        ease: "expo"
                                    }
                                }),
                                s = uE(t),
                                o = s.top,
                                a = s.bottom,
                                l = o - cE.wh,
                                u = a,
                                c = lE(".js-item-stag", i);
                            return e === n.$items.length - 1 && (n.max = a), {
                                start: l,
                                end: u,
                                el: t,
                                tl: r,
                                items: c,
                                content: i
                            }
                        }))
                    })), hE.headDisabled = !0, this.el = e, this.$items = lE(".js-infinite-item", this.el), this.$content = lE(".js-infinite-content-item", this.el), this.target = 0, this.current = 0, this.resize(), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        lc.on("scroller", this.scroll), lc.on("tick", this.tick), lc.on("resize", this.resize), lc.on("mouseenter", this.$items, this.enter), lc.on("mouseleave", this.$items, this.leave)
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        lc.off("scroller", this.scroll), lc.off("tick", this.tick), lc.off("resize", this.resize), lc.off("mouseenter", this.$items, this.enter), lc.off("mouseleave", this.$items, this.leave)
                    }
                }, {
                    key: "transformSections",
                    value: function () {
                        var t = this;
                        this.cache.forEach((function (e, n) {
                            var i = e.el,
                                r = e.start,
                                s = e.end,
                                o = Ki.utils.wrap(-(t.max - s), s, t.current);
                            t.inView(r, s, o) ? (e.out && (e.out = !1), t.transform(i, o)) : e.out || (e.out = !0, t.transform(i, o))
                        }))
                    }
                }, {
                    key: "transform",
                    value: function (t) {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        t.style.transform = "translate3d(0, ".concat(-e, "px, 0)")
                    }
                }, {
                    key: "inView",
                    value: function (t, e, n) {
                        return n > t && n < e
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        hE.headDisabled = !1, this.cache.forEach((function (t) {
                            return t.tl.kill()
                        })), this.unbindEvents()
                    }
                }])
            }();

        function fE(t) {
            return fE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, fE(t)
        }

        function pE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, mE(i.key), i)
            }
        }

        function mE(t) {
            var e = function (t, e) {
                if ("object" != fE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != fE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == fE(e) ? e : e + ""
        }
        var gE = function () {
            return function (t, e, n) {
                return e && pE(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t
            }((function t(e) {
                var n = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t),
                    function (t, e, n) {
                        (e = mE(e)) in t ? Object.defineProperty(t, e, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[e] = n
                    }(this, "mount", (function (t) {
                        t.forEach((function (t) {
                            var e = t.target,
                                i = "VIDEO" === e.tagName;
                            t.isIntersecting && (n.o.unobserve(e), i ? e.src = e.dataset.lazyVid : n.load(e))
                        }))
                    })), this.elems = e, this.o = new IntersectionObserver(this.mount, {
                        rootMargin: "400% 400% 400% 400%"
                    }), this.elems.forEach((function (t) {
                        return n.o.observe(t)
                    }))
            }), [{
                key: "load",
                value: function (t) {
                    var e = t.dataset.lazySrcset;
                    e && (t.srcset = e, t.removeAttribute("data-lazy-srcset"), t.onload = function () {
                        t.classList.add("is-loaded")
                    }, t.onerror = function () {
                        t.classList.add("is-loaded"), console.log("There was an error loading the image")
                    })
                }
            }, {
                key: "unmount",
                value: function () {
                    this.o.disconnect()
                }
            }])
        }();

        function vE(t) {
            return vE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, vE(t)
        }

        function yE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, bE(i.key), i)
            }
        }

        function bE(t) {
            var e = function (t, e) {
                if ("object" != vE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != vE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == vE(e) ? e : e + ""
        }
        var _E = hc,
            xE = function () {
                return function (t, e, n) {
                    return e && yE(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t() {
                    var e = this,
                        n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _E("[data-toggle-vid]");
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t),
                        function (t, e, n) {
                            (e = bE(e)) in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n
                        }(this, "mount", (function (t) {
                            t.forEach((function (t) {
                                var e = t.target;
                                t.isIntersecting ? e.play() : (e.pause(), e.currentTime = 0)
                            }))
                        })), this.elems = n, this.o = new IntersectionObserver(this.mount), this.elems.forEach((function (t) {
                            return e.o.observe(t)
                        }))
                }), [{
                    key: "unmount",
                    value: function () {
                        this.o.disconnect()
                    }
                }])
            }();

        function wE(t) {
            return wE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, wE(t)
        }

        function ME(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, SE(i.key), i)
            }
        }

        function SE(t) {
            var e = function (t, e) {
                if ("object" != wE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != wE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == wE(e) ? e : e + ""
        }
        var TE = cc,
            EE = function () {
                return function (t, e, n) {
                    return e && ME(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.el = e, this.$button = TE("#show-full-transcript", e), this.bindEvents()
                }), [{
                    key: "bindEvents",
                    value: function () {
                        this.$button && (this._click = this.click.bind(this), lc.on("click", this.$button, this._click))
                    }
                }, {
                    key: "unbindEvents",
                    value: function () {
                        this.$button && lc.off("click", this.$button, this._click)
                    }
                }, {
                    key: "click",
                    value: function (t) {
                        this.el.classList.remove("transcript-collapsed"), this.$button && this.$button.classList.add("hidden")
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        this.unbindEvents()
                    }
                }])
            }();

        function DE(t) {
            return DE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, DE(t)
        }

        function CE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, PE(i.key), i)
            }
        }

        function AE(t, e, n) {
            return (e = PE(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function PE(t) {
            var e = function (t, e) {
                if ("object" != DE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != DE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == DE(e) ? e : e + ""
        }
        var LE = cc,
            RE = function () {
                return function (t, e, n) {
                    return e && CE(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), AE(this, "onResize", (function () {
                        n.screenHeight = window.innerHeight, n.asideHeight = n.aside.offsetHeight + n.startScroll
                    })), AE(this, "onScroll", (function (t) {
                        var e = t.y;
                        n.endScroll = window.innerHeight - n.aside.offsetHeight - n.startScroll / 2;
                        var i = parseInt(n.aside.style.top.replace("px;", ""));
                        n.asideHeight > n.screenHeight ? e < n.currPos ? i < n.startScroll ? n.aside.style.top = i + n.currPos - e + "px" : i >= n.startScroll && i != n.startScroll && (n.aside.style.top = n.startScroll + "px") : i > n.endScroll ? n.aside.style.top = i + n.currPos - e + "px" : i < n.endScroll && i != n.endScroll && (n.aside.style.top = n.endScroll + "px") : n.aside.style.top = n.startScroll + "px", n.currPos = e
                    })), this.el = e, this.aside = LE(".js-p-sticky-left", this.el), this.main = LE(".js-p-sticky-right"), this.startScroll = 1e3, this.endScroll = this.main.offsetHeight - this.aside.offsetHeight - this.startScroll / 2, this.currPos = 0, this.screenHeight = window.innerHeight, this.asideHeight = this.aside.offsetHeight + this.startScroll, this.aside.style.top = this.startScroll + "px", this.init()
                }), [{
                    key: "destroy",
                    value: function () {
                        lc.off("resize", this.onResize), lc.off("scroll", this.onScroll)
                    }
                }, {
                    key: "init",
                    value: function () {
                        lc.on("resize", this.onResize), lc.on("scroll", this.onScroll)
                    }
                }])
            }(),
            kE = n(52);

        function OE(t) {
            return OE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, OE(t)
        }

        function IE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, FE(i.key), i)
            }
        }

        function FE(t) {
            var e = function (t, e) {
                if ("object" != OE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != OE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == OE(e) ? e : e + ""
        }
        Ki.registerPlugin(ia);
        var NE = function () {
            return function (t, e, n) {
                return e && IE(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t
            }((function t(e) {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.riveAnimations = [], this.run()
            }), [{
                key: "run",
                value: function () {
                    var t = this;
                    [{
                        src: "/static/main.riv",
                        canvasId: "orbmain"
                    }, {
                        src: "/static/vision.riv",
                        canvasId: "vision"
                    }, {
                        src: "/static/brand.riv",
                        canvasId: "brand"
                    }, {
                        src: "/static/culture.riv",
                        canvasId: "culture"
                    }].forEach((function (e) {
                        var n = document.getElementById(e.canvasId),
                            i = new kE.Rive({
                                src: e.src,
                                canvas: n,
                                autoplay: !0,
                                layout: new kE.Layout({
                                    fit: "cover",
                                    alignment: "center"
                                }),
                                onLoadError: function () {
                                    return console.log("Error loading Rive for ".concat(e.canvasId))
                                },
                                onLoad: function () {
                                    i.resizeDrawingSurfaceToCanvas()
                                }
                            });
                        t.riveAnimations.push(i), ia.create({
                            trigger: document.getElementById(e.canvasId),
                            start: "top bottom",
                            end: "bottom top",
                            onEnter: function () {
                                return i.play()
                            },
                            onLeave: function () {
                                return i.pause()
                            },
                            onEnterBack: function () {
                                return i.play()
                            },
                            onLeaveBack: function () {
                                return i.pause()
                            }
                        })
                    }))
                }
            }, {
                key: "unmount",
                value: function () {
                    this.riveAnimations.forEach((function (t) {
                        t.cleanup()
                    }))
                }
            }])
        }();

        function zE(t) {
            return zE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, zE(t)
        }

        function UE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, BE(i.key), i)
            }
        }

        function BE(t) {
            var e = function (t, e) {
                if ("object" != zE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != zE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == zE(e) ? e : e + ""
        }
        var jE = cc,
            HE = hc,
            VE = dc,
            GE = yc.dom,
            WE = yc.bounds;
        Ki.registerPlugin(ia);
        var $E = function () {
            return function (t, e, n) {
                return e && UE(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t
            }((function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : jE(".js-sticky-section");
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t),
                    function (t, e, n) {
                        (e = BE(e)) in t ? Object.defineProperty(t, e, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[e] = n
                    }(this, "resize", (function () {
                        Ki.set(e.el, {
                            top: function () {
                                return Math.min(0, -(VE(e.el).height - WE.wh))
                            }
                        })
                    })), this.el = n, this.bg = jE(".bg", this.el), this.items = HE(".js-sticky-section").length - 1, this.header = jE(".js-hide-sh"), this.isInSection = !1, this.resize(), this.bindEvents(), this.init()
            }), [{
                key: "init",
                value: function () {
                    this.st = Ki.timeline({
                        scrollTrigger: {
                            trigger: this.el,
                            start: "bottom bottom",
                            end: "bottom top",
                            scrub: !0,
                            invalidateOnRefresh: !0
                        }
                    }).fromTo(this.bg, {
                        alpha: 0
                    }, {
                        alpha: .5,
                        ease: "none"
                    }).fromTo(this.el, {
                        yPercent: 0
                    }, {
                        yPercent: -20,
                        ease: "none"
                    }, 0), ia.create({
                        trigger: this.el,
                        start: "top bottom",
                        end: "bottom bottom",
                        scrub: !0,
                        onUpdate: function (t) {
                            var e = t.direction,
                                n = t.progress; - 1 === e ? GE.sh.classList.remove("is-hidden") : 1 === e ? GE.sh.classList.add("is-hidden") : GE.sh.classList.remove("is-hidden"), 1 !== n && 0 !== n || GE.sh.classList.remove("is-hidden")
                        }
                    })
                }
            }, {
                key: "bindEvents",
                value: function () {
                    lc.on("resize", this.resize)
                }
            }, {
                key: "unbindEvents",
                value: function () {
                    lc.off("resize", this.resize)
                }
            }, {
                key: "unmount",
                value: function () {
                    this.unbindEvents()
                }
            }])
        }();

        function XE(t) {
            return XE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, XE(t)
        }

        function qE(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, KE(i.key), i)
            }
        }

        function YE(t, e, n) {
            return (e = KE(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function KE(t) {
            var e = function (t, e) {
                if ("object" != XE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != XE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == XE(e) ? e : e + ""
        }
        var JE = hc,
            ZE = (yc.dom, yc.bounds, function () {
                return function (t, e, n) {
                    return e && qE(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), YE(this, "enter", (function (t) {
                        var e = t.currentTarget;
                        e.classList.add("is-active");
                        var i = n.DOM.links.indexOf(e);
                        if (i === n.STATE.index) return !1;
                        var r = n.DOM.images[n.STATE.index],
                            s = n.DOM.images[i],
                            o = n.DOM.links[n.STATE.index];
                        n.STATE.index = i, Ki.killTweensOf([r, s]), n.hideImage(r, e), n.showImage(s, e), o.classList.remove("is-active")
                    })), YE(this, "resize", (function () { })), this.el = e, this.DOM = {
                        images: JE(".js-category-image", this.el),
                        links: JE(".js-category-links li", this.el)
                    }, this.STATE = {
                        pos: 0,
                        index: 0
                    }, this.mount()
                }), [{
                    key: "showImage",
                    value: function (t, e) {
                        Ki.timeline().set(t, {
                            zIndex: 1
                        }).to(t, {
                            opacity: 1,
                            duration: .5,
                            ease: "Expo.easeOut",
                            startAt: {
                                scale: 1.1
                            },
                            scale: 1
                        })
                    }
                }, {
                    key: "hideImage",
                    value: function (t, e) {
                        Ki.timeline().set(t, {
                            zIndex: 2
                        }).to(t, {
                            duration: .5,
                            ease: "Expo.easeOut",
                            opacity: 0,
                            onComplete: function () {
                                return Ki.set(t, {
                                    zIndex: 1
                                })
                            }
                        })
                    }
                }, {
                    key: "mount",
                    value: function () {
                        lc.on("resize", this.resize), lc.on("mouseenter", this.DOM.links, this.enter)
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        lc.off("resize", this.resize), lc.off("mouseenter", this.DOM.links, this.enter)
                    }
                }])
            }());

        function QE(t) {
            return QE = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, QE(t)
        }

        function tD(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, nD(i.key), i)
            }
        }

        function eD(t, e, n) {
            return (e = nD(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function nD(t) {
            var e = function (t, e) {
                if ("object" != QE(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != QE(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == QE(e) ? e : e + ""
        }
        var iD = cc,
            rD = (yc.dom, yc.bounds, yc.flags),
            sD = function () {
                return function (t, e, n) {
                    return e && tD(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), eD(this, "checkUrl", (function () {
                        if ("#compare" === window.location.hash) {
                            lc.emit("lenis:stop"), rD.locked = !0, n.openModal();
                            var t = iD("#compare");
                            t && t.scrollIntoView({
                                behavior: "smooth"
                            })
                        }
                    })), eD(this, "openModal", (function () {
                        rD.locked = !0, n.el.style.pointerEvents = "auto", Ki.timeline().to(n.el, {
                            opacity: 1,
                            duration: .5,
                            ease: "Expo.easeOut"
                        }), lc.on("keydown", n.handleKeyDown);
                        var t = window.location.pathname + window.location.search + "#compare";
                        // history.pushState(null, document.title, t), lc.emit("lenis:stop")
                    })), eD(this, "closeModal", (function () {
                        rD.locked = !1, n.el.style.pointerEvents = "none", Ki.timeline().to(n.el, {
                            duration: .5,
                            ease: "Expo.easeOut",
                            opacity: 0
                        }), lc.off("keydown", n.handleKeyDown), history.replaceState(null, document.title, window.location.pathname + window.location.search), lc.emit("lenis:start")
                    })), eD(this, "handleKeyDown", (function (t) {
                        27 === t.keyCode && n.closeModal()
                    })), eD(this, "resize", (function () { })), this.el = e, this.trigger = iD(".js-compare-button"), this.close = iD(".js-compare-close", this.el), window.addEventListener("DOMContentLoaded", this.checkUrl), this.mount()
                }), [{
                    key: "mount",
                    value: function () {
                        lc.on("click", this.trigger, this.openModal), lc.on("click", this.close, this.closeModal)
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        lc.off("click", this.trigger, this.openModal), lc.off("click", this.close, this.closeModal)
                    }
                }])
            }();

        function oD(t) {
            return oD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, oD(t)
        }

        function aD(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, uD(i.key), i)
            }
        }

        function lD(t, e, n) {
            return (e = uD(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function uD(t) {
            var e = function (t, e) {
                if ("object" != oD(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != oD(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == oD(e) ? e : e + ""
        }
        var cD = hc,
            hD = (yc.dom, yc.bounds, yc.device),
            dD = function () {
                return function (t, e, n) {
                    return e && aD(t.prototype, e), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }((function t(e) {
                    var n = this;
                    ! function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), lD(this, "enter", (function (t) {
                        var e = t.currentTarget;
                        if (!hD.isMobile) {
                            e.classList.add("is-active");
                            var i = n.DOM.links.indexOf(e);
                            if (i === n.STATE.index) return !1;
                            var r = n.DOM.images[n.STATE.index],
                                s = n.DOM.images[i],
                                o = n.DOM.links[n.STATE.index];
                            n.STATE.index = i, Ki.killTweensOf([r, s]), n.hideImage(r, e), n.showImage(s, e), o.classList.remove("is-active")
                        }
                    })), lD(this, "resize", (function () { })), this.el = e, this.DOM = {
                        images: cD(".js-hoverstate-image", this.el),
                        links: cD(".js-hoverstate-target", this.el)
                    }, this.STATE = {
                        pos: 0,
                        index: 0
                    }, this.mount()
                }), [{
                    key: "showImage",
                    value: function (t, e) {
                        Ki.timeline().set(t, {
                            zIndex: 1
                        }).to(t, {
                            opacity: 1,
                            duration: .2,
                            ease: "Expo.easeOut"
                        })
                    }
                }, {
                    key: "hideImage",
                    value: function (t, e) {
                        Ki.timeline().set(t, {
                            zIndex: 2
                        }).to(t, {
                            duration: .2,
                            ease: "Expo.easeOut",
                            opacity: 0,
                            onComplete: function () {
                                return Ki.set(t, {
                                    zIndex: 1
                                })
                            }
                        })
                    }
                }, {
                    key: "mount",
                    value: function () {
                        var t = this;
                        lc.on("resize", this.resize), lc.on("mouseenter", this.DOM.links, this.enter), hD.isMobile && this.DOM.links.forEach((function (e, n) {
                            ia.create({
                                trigger: e,
                                start: "top bottom",
                                end: "bottom top",
                                onUpdate: function (n) {
                                    var i = n.progress,
                                        r = Math.floor(i * t.DOM.images.length),
                                        s = t.DOM.images[t.STATE.index],
                                        o = t.DOM.images[r];
                                    r !== t.STATE.index && (t.STATE.index = r, Ki.killTweensOf([s, o]), t.hideImage(s, e), t.showImage(o, e))
                                },
                                scrub: !0
                            })
                        }))
                    }
                }, {
                    key: "unmount",
                    value: function () {
                        lc.off("resize", this.resize), lc.off("mouseenter", this.DOM.links, this.enter)
                    }
                }])
            }();

        function fD(t) {
            return fD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, fD(t)
        }

        function pD(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, gD(i.key), i)
            }
        }

        function mD(t, e, n) {
            return (e = gD(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function gD(t) {
            var e = function (t, e) {
                if ("object" != fD(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != fD(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == fD(e) ? e : e + ""
        }
        var vD = cc,
            yD = hc,
            bD = dc,
            _D = yc.bounds;
        yc.flags, Ki.registerPlugin(xu, ia);
        var xD = function () {
            return function (t, e, n) {
                return e && pD(t.prototype, e), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t
            }((function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vD(".js-flip");
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), mD(this, "toggle", (function () {
                    var t = xu.getState(e.$flips),
                        n = e.flipped ? e.cache[0].left : e.cache[1].left,
                        i = e.flipped ? e.cache[0].right : e.cache[1].right;
                    e.flipped ? (e.flipped = !1, e.$cache.forEach((function (t) {
                        var e = t.el,
                            n = t.parent;
                        n && n.appendChild(e)
                    })), e.$flipModule.classList.remove("is-active"), e.$flipHide.classList.remove("is-active")) : (e.flipped = !0, e.$cache.forEach((function (t) {
                        var e = t.el,
                            n = t.target;
                        n && n.appendChild(e)
                    })), e.$flipModule.classList.add("is-active"), e.$flipHide.classList.add("is-active")), e.f && e.f.kill(), e.f = xu.from(t, {
                        absolute: !0,
                        duration: 1,
                        ease: "snappy",
                        onStart: function () {
                            e.isAnimating = !0
                        },
                        onComplete: function () {
                            e.isAnimating = !1
                        }
                    }).to(e.$text, {
                        autoAlpha: e.flipped ? 1 : 0,
                        duration: .5,
                        ease: "linear"
                    }, 0).to(e.$flipHide, {
                        autoAlpha: e.flipped ? 0 : 1,
                        duration: .5,
                        ease: "linear"
                    }, 0), e.flipped && e.f.to(window, {
                        scrollTo: "#the-content",
                        duration: 1,
                        ease: "snappy"
                    }, 0);
                    var r = e.flipped ? [.75, 1] : [1, .75];
                    e.tl.clear().to(e.state, {
                        left: n,
                        duration: r[0]
                    }).to(e.state, {
                        right: i,
                        duration: r[1]
                    }, 0).restart(), Ki.killTweensOf(e.$toggleBtn), e.flipped ? (e.$toggle.classList.add("ready"), Ki.to(e.$toggleBtn, {
                        y: 0,
                        duration: r[1],
                        ease: "snappy"
                    })) : (e.$toggle.classList.remove("ready"), Ki.to(e.$toggleBtn, {
                        y: e.calcTransform("y", "calc(100% - 1rem)"),
                        duration: r[0],
                        ease: "snappy"
                    }))
                })), mD(this, "calcTransform", (function (t, e) {
                    var n = {
                        y: "translateY",
                        x: "translateX",
                        z: "translateZ",
                        rotation: "rotate"
                    };
                    return function (i, r) {
                        var s = r.style.transform;
                        r.style.transform = (n[t] || t) + "(" + e + ")";
                        var o = parseFloat(Ki.getProperty(r, t, "rot" === t.substr(0, 3) ? "deg" : "px", !0));
                        return r.style.transform = s, Ki.getProperty(r, t, "px", !0), o
                    }
                })), mD(this, "scroll", (function (t) {
                    var n = t.y,
                        i = .75 * _D.wh;
                    n > i ? e.$toggle.classList.add("is-active") : n < i && e.$toggle.classList.remove("is-active")
                })), mD(this, "resize", (function () {
                    e.$cache || (e.$cache = e.$flips.map((function (t, n) {
                        var i = t.parentNode;
                        return {
                            el: t,
                            target: e.$flipContainer[n],
                            parent: i
                        }
                    }))), Ki.set(e.$text, {
                        top: function () {
                            return Math.min(0, -(bD(e.$text).height - window.innerHeight))
                        }
                    }), e.isAnimating || (e.cache = e.$items.map((function (t) {
                        var n = bD(t);
                        return {
                            left: n.left - bD(e.$mask).left,
                            right: bD(e.$mask).right - n.right,
                            item: t
                        }
                    })), e.setActive())
                })), this.$el = n, this.$toggleBtn = vD(".js-flip-btn"), this.$switch = vD(".switch"), this.$hero = vD(".pdp-hero"), this.flipped = !1, this.$flips = yD(".js-flip", this.$el), this.$flipContainer = yD(".js-flipped", this.$el), this.$text = vD(".js-flip-text", this.$el), this.$content = vD("#the-content"), this.$flipModule = vD(".js-flip-module", this.$el), this.$flipHide = vD(".js-hide-flip", this.$el), this.$flipSwitcher = vD(".js-switcher-tabs"), this.$mask = vD(".js-switch-mask", this.$flipSwitcher), this.$items = yD(".js-flip-switch", this.$flipSwitcher), this.$toggle = vD(".js-switcher-toggle"), this.$toggleText = yD(".js-switcher-toggle-text", this.$toggle), this.$toggleBtn = vD(".circle-mask", this.$toggle), this.state = {
                    left: 0,
                    right: 0,
                    idxLast: -1,
                    idxCurrent: 0
                }, this.isAnimating = !1, this.hidden = !1, this.lastScroll = 0, this.tl = Ki.timeline({
                    paused: !0,
                    defaults: {
                        duration: .75,
                        ease: "snappy"
                    },
                    onUpdate: function () {
                        return Ki.set(e.$mask, {
                            clipPath: "inset(0 ".concat(e.state.right, "px 0 ").concat(e.state.left, "px round 3.1rem)")
                        })
                    }
                }), Ki.set(this.$toggleBtn, {
                    y: this.calcTransform("y", "calc(100% - 1rem)")
                }), this.mount()
            }), [{
                key: "mount",
                value: function () {
                    this.resize(), lc.on("click", this.$items, this.toggle), lc.on("click", this.$toggle, this.toggle), lc.on("scroll", this.scroll), lc.on("resize-reset", this.resize)
                }
            }, {
                key: "setActive",
                value: function () {
                    var t = this.flipped ? this.cache[1] : this.cache[0],
                        e = t.left,
                        n = t.right;
                    this.tl.clear().to(this.state, {
                        left: e,
                        right: n,
                        duration: .1
                    }).restart()
                }
            }, {
                key: "unmount",
                value: function () {
                    lc.off("click", this.$items, this.toggle), lc.off("scroll", this.scroll), lc.off("resize-reset", this.resize)
                }
            }])
        }();

        function wD(t) {
            return wD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, wD(t)
        }

        function MD(t) {
            return function (t) {
                if (Array.isArray(t)) return SD(t)
            }(t) || function (t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
            }(t) || function (t, e) {
                if (t) {
                    if ("string" == typeof t) return SD(t, e);
                    var n = {}.toString.call(t).slice(8, -1);
                    return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? SD(t, e) : void 0
                }
            }(t) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function SD(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
            return i
        }

        function TD(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, ED(i.key), i)
            }
        }

        function ED(t) {
            var e = function (t, e) {
                if ("object" != wD(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != wD(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == wD(e) ? e : e + ""
        }

        function DD(t, e, n) {
            return e = AD(e),
                function (t, e) {
                    if (e && ("object" == wD(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, CD() ? Reflect.construct(e, n || [], AD(t).constructor) : e.apply(t, n))
        }

        function CD() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { })))
            } catch (t) { }
            return (CD = function () {
                return !!t
            })()
        }

        function AD(t) {
            return AD = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, AD(t)
        }

        function PD(t, e) {
            return PD = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, PD(t, e)
        }
        var LD = yc.dom,
            RD = (yc.flags, yc.device),
            kD = cc,
            OD = hc,
            ID = null,
            FD = function (e) {
                function n() {
                    return function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, n), DD(this, n, arguments)
                }
                return function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && PD(t, e)
                }(n, e),
                    function (t, e, n) {
                        return e && TD(t.prototype, e), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(n, [{
                        key: "setup",
                        value: function () {
                            var t = this;
                            this.onEnter(), RD.isMobile && LD.body.classList.add("is-mobile"), this.intro = new Np, this.footer = new _p, requestAnimationFrame((function () {
                                t.load()
                            }))
                        }
                    }, {
                        key: "onEnter",
                        value: function () {
                            ID && ID.forEach((function (t) {
                                return t.kill()
                            })), this.el = this.wrap.lastElementChild, this.el.dataset.showTabs ? lc.emit("switch-enable") : LD.switch.classList.add("invisible"), this.handleActive(), this.handleToTop(), this.handleAnchors(), this.handleNativeAnchors(), kD(".js-no-mix-blend", this.el) ? LD.sh.classList.add("no-mix-blend") : LD.sh.classList.remove("no-mix-blend")
                        }
                    }, {
                        key: "onEnterCompleted",
                        value: function () {
                            var t = this;
                            this.initComponents(), this.initLazy(), this.popPopUpEarlyAccess = new _f, this.scrollAnchor = new Ef, requestAnimationFrame((function () {
                                ih(t.el)
                            }))
                        }
                    }, {
                        key: "onLeave",
                        value: function () {
                            this.toTopEl && lc.off("click", this.toTopEl, this.toTop), this.nativeAnchors && lc.off("click", this.nativeAnchors, this.nativeAnchorTo), this.anchors && lc.off("click", this.anchors, this.anchorTo), (ID = ia.getAll()).forEach((function (t) {
                                return t.disable(!1)
                            }))
                        }
                    }, {
                        key: "onLeaveCompleted",
                        value: function () {
                            this.popPopUpEarlyAccess.unmount(), this.lazy && this.lazy.unmount(), this.lazyVids && this.lazyVids.unmount(), this.components && this.components.forEach((function (t) {
                                t.unmount && t.unmount()
                            }))
                        }
                    }, {
                        key: "load",
                        value: function () {
                            this.intro.tl.restart(), new tf(LD.sh), RD.isSmall ? new Ap : (new cf, new Vf), OD(".js-mdd").forEach((function (t) {
                                new Of(t)
                            })), this.onEnterCompleted()
                        }
                    }, {
                        key: "initComponents",
                        value: function () {
                            var e = OD("[data-component]", this.el);
                            (e = RD.isMobile ? e.filter((function (t) {
                                return null == t.dataset.disabledMobile
                            })) : e).length && (this.components = e.map((function (e) {
                                var n = e.dataset.component,
                                    i = t[n],
                                    r = n.charAt(0);
                                return r === r.toUpperCase() ? new i(e) : i(e)
                            })))
                        }
                    }, {
                        key: "handleToTop",
                        value: function () {
                            this.toTopEl = kD(".js-to-top"), this.toTopEl && lc.on("click", this.toTopEl, this.toTop)
                        }
                    }, {
                        key: "toTop",
                        value: function () {
                            lc.emit("scroll-top")
                        }
                    }, {
                        key: "handleActive",
                        value: function () {
                            !this.links && (this.links = OD(".js-page-link")), this.links.forEach((function (t) {
                                t.classList.remove("is-active", "pointer-events-none"), t.href === location.href && t.classList.add("is-active", "pointer-events-none")
                            }))
                        }
                    }, {
                        key: "handleAnchors",
                        value: function () {
                            this.anchors = OD("[data-to]", this.el), this.anchors.length && lc.on("click", this.anchors, this.anchorTo)
                        }
                    }, {
                        key: "handleNativeAnchors",
                        value: function () {
                            this.nativeAnchors = OD('a[href^="#"]', this.el), this.nativeAnchors.length && lc.on("click", this.nativeAnchors, this.nativeAnchorTo)
                        }
                    }, {
                        key: "anchorTo",
                        value: function (t) {
                            var e = t.currentTarget;
                            lc.emit("scroll-to", e.dataset.to)
                        }
                    }, {
                        key: "initLazy",
                        value: function () {
                            var t = [].concat(MD(OD("[data-lazy-srcset]", this.el)), MD(OD("[data-lazy-vid]", this.el)));
                            t.length && (this.lazy = new gE(t)), (t = OD("[data-toggle-vid]", this.el)).length && (this.toggleVids = new xE(t))
                        }
                    }, {
                        key: "nativeAnchorTo",
                        value: function (t) {
                            t.preventDefault();
                            var e = new URL(t.currentTarget.href).hash;
                            lc.emit("scroll-to", e)
                        }
                    }])
            }(c.Renderer);

        function ND(t) {
            return ND = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ND(t)
        }

        function zD(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, UD(i.key), i)
            }
        }

        function UD(t) {
            var e = function (t, e) {
                if ("object" != ND(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != ND(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == ND(e) ? e : e + ""
        }

        function BD(t, e, n) {
            return e = HD(e),
                function (t, e) {
                    if (e && ("object" == ND(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, jD() ? Reflect.construct(e, n || [], HD(t).constructor) : e.apply(t, n))
        }

        function jD() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { })))
            } catch (t) { }
            return (jD = function () {
                return !!t
            })()
        }

        function HD(t) {
            return HD = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, HD(t)
        }

        function VD(t, e) {
            return VD = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, VD(t, e)
        }
        var GD = cc,
            WD = hc,
            $D = fc,
            XD = yc.dom,
            qD = yc.flags,
            YD = Ki.timeline({
                paused: !0,
                defaults: {
                    duration: 1,
                    ease: "expo.inOut",
                    force3D: !0
                }
            }),
            KD = ["#545E54", "#9D9482", "#C7CFD1", "#D4CCCC"],
            JD = GD(".js-mask-mask"),
            ZD = .5,
            QD = function (t) {
                function e() {
                    return function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), BD(this, e, arguments)
                }
                return function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && VD(t, e)
                }(e, t),
                    function (t, e, n) {
                        return e && zD(t.prototype, e), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(e, [{
                        key: "in",
                        value: function (t) {
                            var e = t.from,
                                n = t.to,
                                i = t.done,
                                r = null != n.dataset.contact && !qD.infinite;
                            ZD = r ? 1.5 : 0, e.remove(), qD.locked = !1, lc.emit("scroll-resetter"), XD.sh.classList.remove("is-hidden");
                            var s = GD(".js-image-preload", n),
                                o = GD(".js-vid-preload", n),
                                a = WD(".js-t-title-line", n),
                                l = GD(".js-t-lines", n);
                            if (YD.clear(), qD.infinite ? YD.add((function () {
                                return lc.emit("infinite-close")
                            }), 0) : (YD.to([XD.mask, JD], {
                                yPercent: Ki.utils.wrap([-100, 75])
                            }, ZD), r && YD.set(XD.maskLines, {
                                alpha: 1
                            }, 0).fromTo(XD.maskLine, {
                                yPercent: 100
                            }, {
                                yPercent: 0,
                                duration: ZD,
                                stagger: .1,
                                ease: "expo.inOut"
                            }, 0)), a.length && YD.from(a, {
                                yPercent: 100,
                                duration: 1.5,
                                stagger: .2,
                                ease: "expo"
                            }, ZD + .5), l) {
                                var u = new (Zc())(l, {
                                    type: "lines"
                                }).lines,
                                    c = new (Zc())(u, {
                                        type: "lines"
                                    }).lines;
                                YD.set(u, {
                                    overflow: "hidden"
                                }, 0).from(c, {
                                    yPercent: 100,
                                    duration: 1.25,
                                    stagger: .1,
                                    ease: "expo"
                                }, ZD + .85)
                            }
                            if (YD.set(XD.mask, {
                                autoAlpha: 0
                            }), s) {
                                var h = new Image;
                                h.src = s.currentSrc, h.onload = function () {
                                    return YD.restart()
                                }, h.onerror = function () {
                                    return YD.restart()
                                }
                            } else o ? o.oncanplay = function () {
                                return YD.restart()
                            } : YD.restart();
                            i(), setTimeout((function () {
                                lc.emit("resize"), window.scrollTo(0, 0)
                            }))
                        }
                    }, {
                        key: "out",
                        value: function (t) {
                            var e = t.done;
                            lc.emit("transition-out"), qD.infinite ? e() : YD.clear().set(XD.maskLines, {
                                alpha: 0
                            }).set(XD.mask, {
                                autoAlpha: 1,
                                backgroundColor: function () {
                                    return KD[$D(0, 2)]
                                }
                            }).fromTo([XD.mask, JD], {
                                yPercent: Ki.utils.wrap([100, -75])
                            }, {
                                yPercent: 0,
                                onComplete: function () {
                                    qD.menu && lc.emit("menu-close-instant"), e()
                                }
                            }, .025).restart()
                        }
                    }])
            }(c.Transition);

        function tC(t) {
            return tC = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, tC(t)
        }

        function eC(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, nC(i.key), i)
            }
        }

        function nC(t) {
            var e = function (t, e) {
                if ("object" != tC(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != tC(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == tC(e) ? e : e + ""
        }

        function iC(t, e, n) {
            return e = sC(e),
                function (t, e) {
                    if (e && ("object" == tC(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, rC() ? Reflect.construct(e, n || [], sC(t).constructor) : e.apply(t, n))
        }

        function rC() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { })))
            } catch (t) { }
            return (rC = function () {
                return !!t
            })()
        }

        function sC(t) {
            return sC = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, sC(t)
        }

        function oC(t, e) {
            return oC = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, oC(t, e)
        }
        var aC = cc,
            lC = hc,
            uC = yc.dom,
            cC = yc.device,
            hC = yc.flags,
            dC = Ki.timeline({
                paused: !0,
                defaults: {
                    duration: 1.25,
                    ease: "expo.inOut",
                    force3D: !0
                }
            }),
            fC = function (t) {
                function e() {
                    return function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), iC(this, e, arguments)
                }
                return function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && oC(t, e)
                }(e, t),
                    function (t, e, n) {
                        return e && eC(t.prototype, e), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(e, [{
                        key: "in",
                        value: function (t) {
                            var e = t.from,
                                n = t.to,
                                i = t.done;
                            lc.emit("scroll-reset");
                            var r = aC(".js-image-preload", n),
                                s = lC(".js-t-title-line", n),
                                o = lC(".js-t-fade", n),
                                a = new (Zc())(aC(".js-t-lines", n), {
                                    type: "lines"
                                }).lines,
                                l = new (Zc())(a, {
                                    type: "lines"
                                }).lines;
                            dC.clear().set(a, {
                                overflow: "hidden"
                            }, 0).from(s, {
                                yPercent: 100,
                                duration: 1.5,
                                stagger: .2,
                                ease: "expo"
                            }, .15).from(l, {
                                yPercent: 100,
                                duration: 1.25,
                                stagger: .1,
                                ease: "expo"
                            }, .5).from(o, {
                                alpha: 0,
                                duration: 1.25,
                                ease: "expo"
                            }, .15), uC.sh.classList.contains("is-hidden") && dC.add((function () {
                                uC.sh.classList.remove("is-hidden")
                            }), 0).fromTo(uC.sh, {
                                alpha: 0
                            }, {
                                alpha: 1,
                                duration: 1.25,
                                ease: "expo"
                            }, .15);
                            var u = new Image;
                            u.src = r.currentSrc, u.onload = function () {
                                e.remove(), i(), dC.restart()
                            }, u.onerror = function () {
                                e.remove(), i(), dC.restart()
                            }
                        }
                    }, {
                        key: "out",
                        value: function (t) {
                            var e = t.done,
                                n = t.from;
                            hC.locked = !0;
                            var i = lC(".js-t-swipe", n),
                                r = aC(".js-t-scale", n);
                            dC.clear().set(n, {
                                position: "fixed",
                                left: 0,
                                top: -window.scrollY,
                                width: "100%"
                            }).to(i, {
                                yPercent: -100,
                                duration: .5,
                                stagger: .1,
                                ease: "power2.inOut"
                            }, 0), !cC.isMobile && dC.to(r, {
                                scaleX: 0,
                                duration: .5,
                                ease: "power2.inOut"
                            }, 0), dC.add((function () {
                                return e()
                            })).restart()
                        }
                    }])
            }(c.Transition);

        function pC(t) {
            return pC = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, pC(t)
        }

        function mC(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, gC(i.key), i)
            }
        }

        function gC(t) {
            var e = function (t, e) {
                if ("object" != pC(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != pC(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == pC(e) ? e : e + ""
        }

        function vC(t, e, n) {
            return e = bC(e),
                function (t, e) {
                    if (e && ("object" == pC(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, yC() ? Reflect.construct(e, n || [], bC(t).constructor) : e.apply(t, n))
        }

        function yC() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { })))
            } catch (t) { }
            return (yC = function () {
                return !!t
            })()
        }

        function bC(t) {
            return bC = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, bC(t)
        }

        function _C(t, e) {
            return _C = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, _C(t, e)
        }
        yc.dom;
        var xC = yc.flags,
            wC = Ki.timeline({
                paused: !0,
                defaults: {
                    duration: .5,
                    ease: "power1"
                }
            }),
            MC = function (t) {
                function e() {
                    return function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), vC(this, e, arguments)
                }
                return function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && _C(t, e)
                }(e, t),
                    function (t, e, n) {
                        return e && mC(t.prototype, e), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(e, [{
                        key: "in",
                        value: function (t) {
                            var e = t.from,
                                n = t.to,
                                i = t.done;
                            e.remove(), xC.locked = !1, lc.emit("scroll-reset"), wC.clear().from(n, {
                                alpha: 0
                            }).restart(), i()
                        }
                    }, {
                        key: "out",
                        value: function (t) {
                            var e = t.from,
                                n = t.done;
                            lc.emit("transition-out"), wC.clear().to(e, {
                                alpha: 0,
                                onComplete: function () {
                                    return n()
                                }
                            }).restart()
                        }
                    }])
            }(c.Transition),
            SC = function () {
                var t = function (t) {
                    var e = {},
                        n = window.location.href.split("?")[1] || "";
                    if ("" === n) return e;
                    for (var i = n.split("&"), r = 0; r < i.length; r++) {
                        var s = i[r].split("=");
                        if (void 0 === e[s[0]]) e[s[0]] = decodeURIComponent(s[1]);
                        else if ("string" == typeof e[s[0]]) {
                            var o = [e[s[0]], decodeURIComponent(s[1])];
                            e[s[0]] = o
                        } else e[s[0]].push(decodeURIComponent(s[1]))
                    }
                    return e
                }();
                Object.keys(t).length < 1 || Object.keys(t).forEach((function (e) {
                    var n = t[e];
                    window.localStorage.setItem(e, n)
                }))
            },
            TC = function () {
                var t = document.querySelectorAll("input");
                null != t && 0 != t.length && t.forEach((function (t) {
                    null != t.dataset.gformLabel && null != localStorage[t.dataset.gformLabel] && (t.value = localStorage.getItem(t.dataset.gformLabel))
                }))
            };

        function EC(t) {
            return EC = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, EC(t)
        }

        function DC(t, e) {
            var n = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e && (i = i.filter((function (e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), n.push.apply(n, i)
            }
            return n
        }

        function CC(t, e, n) {
            return (e = PC(e)) in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }

        function AC(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, PC(i.key), i)
            }
        }

        function PC(t) {
            var e = function (t, e) {
                if ("object" != EC(t) || !t) return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, "string");
                    if ("object" != EC(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return String(t)
            }(t);
            return "symbol" == EC(e) ? e : e + ""
        }

        function LC(t, e, n) {
            return e = OC(e),
                function (t, e) {
                    if (e && ("object" == EC(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }(t, RC() ? Reflect.construct(e, n || [], OC(t).constructor) : e.apply(t, n))
        }

        function RC() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { })))
            } catch (t) { }
            return (RC = function () {
                return !!t
            })()
        }

        function kC() {
            return kC = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {
                var i = function (t, e) {
                    for (; !{}.hasOwnProperty.call(t, e) && null !== (t = OC(t)););
                    return t
                }(t, e);
                if (i) {
                    var r = Object.getOwnPropertyDescriptor(i, e);
                    return r.get ? r.get.call(arguments.length < 3 ? t : n) : r.value
                }
            }, kC.apply(null, arguments)
        }

        function OC(t) {
            return OC = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }, OC(t)
        }

        function IC(t, e) {
            return IC = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
                return t.__proto__ = e, t
            }, IC(t, e)
        }
        var FC = yc.device,
            NC = cc;
        (function () {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                e = t.el,
                n = void 0 === e ? window : e,
                i = t.mouseMultiplier,
                r = void 0 === i ? .325 : i,
                s = t.firefoxMultiplier,
                o = void 0 === s ? 20 : s,
                a = new Lc({
                    lerp: .15,
                    wheelMultiplier: 1.25
                });
            f();
            var l = {
                mouse: Nc ? 2 * r : r,
                firefox: Nc ? 2 * o : o
            },
                u = {
                    t: 0,
                    c: 0
                },
                c = 0,
                h = 0,
                d = null;

            function f() {
                console.log("lenis top"), a.scrollTo(0, {
                    duration: 1
                })
            }

            function p() {
                window.scrollTo(0, 0), a.scrollTo(window, 0), ia.refresh(), lc.emit("resize-reset")
            }

            function m() {
                window.scrollTo(0, 0), a.scrollTo(window, 0), ia.refresh(), lc.emit("resize-reset")
            }
            a.on("scroll", (function (t) {
                var e = t.scroll;
                u.t = e, ia.update(), lc.emit("scroll", {
                    y: u.t
                })
            })), Ki.ticker.add((function (t) {
                a.raf(1e3 * t), h = a.velocity, d = Math.abs(h) < .1, Fc.scroll = !d, lc.emit("tick", {
                    y: u.t,
                    time: t,
                    diff: h
                })
            })), Ki.ticker.lagSmoothing(0), lc.on("wheel", n, (function (t) {
                if (!t.composedPath().find((function (t) {
                    var e;
                    return null === (e = t.hasAttribute) || void 0 === e ? void 0 : e.call(t, "data-scroll-prevent")
                }))) {
                    t.preventDefault();
                    var e = l.mouse,
                        n = l.firefox;
                    c = t.wheelDeltaY || t.deltaY, zc && 1 === t.deltaMode && (c *= n), c *= e, Fc.locked || (u.t -= c, u.t = Ki.utils.clamp(0, Ic.maxScroll, u.t)), lc.emit("scroller", {
                        y: u.t,
                        dY: c,
                        oE: t
                    })
                }
            }), {
                passive: !1
            }), lc.on("scroll-down", (function () {
                a.scrollTo(Ic.wh, {
                    duration: 1
                })
            })), lc.on("scroll-top", f), lc.on("scroll-to", (function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    e = 0;
                if (t) {
                    var n = Uc("".concat(t));
                    n && (e = (e = n.offsetTop) <= 0 ? n.parentNode.offsetTop : e)
                }
                a.scrollTo(Math.min(e, Ic.maxScroll), {
                    duration: 1
                })
            })), lc.on("scroll-reset", p), lc.on("resize", (function () {
                var t = u.t;
                p(), window.scrollTo(0, t), u.c = u.t = t
            })), lc.on("scroll-resetter", m), lc.on("lenis:start", (function () {
                a.start()
            })), lc.on("lenis:stop", (function () {
                a.stop()
            })), lc.on("lenis:check", (function () {
                Fc.locked ? a.stop() : a.start()
            })), lc.on("lenis:destroy", (function () {
                a.destroy()
            })), lc.on("resize", (function () {
                lc.emit("resize-reset")
            })), m()
        })(),
            function () {
                var t, e, n, i = 0,
                    r = 0,
                    s = 0,
                    o = null,
                    a = {
                        move: Bc ? "touchmove" : "mousemove",
                        down: Bc ? "touchstart" : "mousedown",
                        up: Bc ? "touchend" : "mouseup"
                    };

                function l(t) {
                    i = t.changedTouches ? t.changedTouches[0].clientX : t.clientX, r = t.changedTouches ? t.changedTouches[0].clientY : t.clientY, o = t.target
                }
                t = a.move, e = a.down, n = a.up, lc.on(t, window, (function (t) {
                    l(t), lc.emit("mousemove", {
                        x: i,
                        y: r,
                        target: o,
                        e: t
                    })
                }), {
                    passive: !Bc
                }), lc.on(e, window, (function (t) {
                    l(t), s = i, lc.emit("mousedown", {
                        x: i,
                        y: r,
                        target: o
                    })
                })), lc.on(n, window, (function (t) {
                    l(t), lc.emit("mouseup", {
                        x: i,
                        y: r,
                        target: o,
                        click: Math.abs(i - s) < 10
                    })
                }))
            }(),
            function () {
                function t() {
                    var t = window.innerWidth,
                        e = window.innerHeight;
                    jc.maxScroll = Vc.body.getBoundingClientRect().height - e, jc.ww = t, jc.wh = e, jc.aspect = t / e, jc.aspect >= 2 ? Vc.body.classList.add("is-tight") : Vc.body.classList.remove("is-tight"), Hc.isSmall = window.matchMedia("(max-width: 649px)").matches, Hc.isPortrait = window.matchMedia("(orientation: portrait)").matches, document.documentElement.style.setProperty("--vh", "".concat(jc.wh / 100, "px")), lc.emit("resize")
                }
                t(), new ResizeObserver(t).observe(Vc.body), Gc && window.addEventListener("orientationchange", (function () {
                    Ki.set(Vc.body, {
                        alpha: 0
                    }), location.reload()
                })), lc.on("portfolio-resize", t)
            }(), history.scrollRestoration ? history.scrollRestoration = "manual" : window.onbeforeunload = function () {
                window.scrollTo(0, 0)
            };
        var zC = function () {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document,
                e = document.querySelector("#wpadminbar");
            if (e) {
                var n = t.querySelector("#wpadminbar");
                n && (n.querySelectorAll("a").forEach((function (t) {
                    t.dataset.routerDisabled = !0
                })), e.innerHTML = n.innerHTML, document.dispatchEvent(new Event("DOMContentLoaded")))
            }
        },
            UC = function () {
                (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                    page: document
                }).page.querySelector("#remove-footer") ? NC("footer").classList.add("hidden") : NC("footer").classList.remove("hidden")
            },
            BC = new (function (t) {
                function e() {
                    var t;
                    return function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), t = LC(this, e, [{
                        renderers: {
                            default: FD
                        },
                        transitions: {
                            default: QD,
                            contextual: {
                                next: FC.isMobile ? QD : fC,
                                works: MC
                            }
                        }
                    }]), window.onerror = t.handleErrors, t.demoteConsoleErrors(), t
                }
                return function (t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && IC(t, e)
                }(e, t),
                    function (t, e, n) {
                        return e && AC(t.prototype, e), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(e, [{
                        key: "handleErrors",
                        value: function (t, e, n) {
                            return console.log("### MOTTO ### Unhandled error:", t, "at line", "#" + n), console.log("### MOTTO ### Unhandled error url:", e), !0
                        }
                    }, {
                        key: "demoteConsoleErrors",
                        value: function () {
                            var t = function (t) {
                                for (var e = 1; e < arguments.length; e++) {
                                    var n = null != arguments[e] ? arguments[e] : {};
                                    e % 2 ? DC(Object(n), !0).forEach((function (e) {
                                        CC(t, e, n[e])
                                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : DC(Object(n)).forEach((function (e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                                    }))
                                }
                                return t
                            }({}, window.console);
                            t.error = function () {
                                for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                                return t.log.apply(t, ["### MOTTO ### Demoted console error: "].concat(n))
                            }, window.console = t
                        }
                    }, {
                        key: "navigate",
                        value: function (t) {
                            yc.dom.lastClicked = t.currentTarget, kC(OC(e.prototype), "navigate", this).call(this, t), SC()
                        }
                    }])
            }(c.Core));
        Motto.H = BC, Motto.fromTransition = !1, Kc.init(), zC(), UC(), SC(), TC(), BC.on("NAVIGATE_IN", (function (t) {
            var e = t.to;
            zC(e.page), Motto.fromTransition = !0, UC(e), TC()
        }))
    })()
})();